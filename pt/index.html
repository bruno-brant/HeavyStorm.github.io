<!doctype html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <meta property="og:image" content="https://blog.brunobrant.net/assets/technology-matters-logo.png" /> <title> &middot; TECHNOLOGY MATTERS </title> <link rel="stylesheet" href="/pt/styles.css"> <!-- <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/pt/assets/apple-touch-icon-precomposed.png"> --> <link rel="shortcut icon" href="/pt/assets/favicon.ico"> <link rel="alternate" type="application/atom+xml" title="TECHNOLOGY MATTERS" href="/pt/feed.xml"> <!-- Begin Jekyll SEO tag v2.7.1 --> <meta name="generator" content="Jekyll v4.1.1" /> <meta property="og:title" content="Home" /> <meta name="author" content="Bruno Brant" /> <meta property="og:locale" content="pt" /> <link rel="canonical" href="https://blog.brunobrant.net/" /> <meta property="og:url" content="https://blog.brunobrant.net/" /> <meta property="og:site_name" content="TECHNOLOGY MATTERS" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Home" /> <script type="application/ld+json"> {"url":"https://blog.brunobrant.net/","@type":"WebSite","author":{"@type":"Person","name":"Bruno Brant"},"headline":"Home","name":"TECHNOLOGY MATTERS","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <script> /* Toggle between adding and removing the "responsive" class to topnav when the user clicks on the icon */ function openNavigation() { const navigationElems = document.getElementsByClassName("navigation"); if (navigationElems.length != 1) { console.warn("Couldn't find navbar"); return; } const x = navigationElems[0]; if (x.className === "navigation") { x.className += " responsive"; } else { x.className = "navigation"; } } </script> <body> <div class="container content"> <header class="masthead"> <h3 class="masthead-title"> <a href="/pt/" title="Home" class="masthead-title-main">TECHNOLOGY MATTERS</a><br> <small>pensamentos desordenados sobre tecnologia, software, etc.</small> </h3> <!-- Change navigation links here --> <div class="navigation"> <ul id="navigation-list"> <li> <a href="/pt/">HOME</a> </li> <li> <a href="/pt/archive/">POSTS</a> </li> <li> <a href="/pt/tags/">TAGS</a> </li> <li> <a href="/pt/categories/">CATEGORIAS</a> </li> <li> <a href="/pt/about/">SOBRE</a> </li> <li id="subscribe"> <a href="/feed.xml"> <p>ASSINAR</p> <svg class="svg-icon grey" style="fill: #f66a0a;"> <use xlink:href="/assets/minima-social-icons.svg#rss"></use> </svg> </a> </li> </ul> <div style="float:right"> <a href="javascript:void(0);" class="navigation-icon" onclick="openNavigation()">☰</a> </div> </div> <!-- Language selector --> <div class="language-selector"> <span class="language-selector-label">ler esse site em:</span> <a href="/"><span>🇺🇸</span></a> | <a href="/pt/"><span>🇧🇷</span></a> </div> </header> <main> <!-- Multi language trick --> <div class="posts"> <article class="post"> <h1 class="post-title"> <a href="/pt/parsing-code-with-sprache-part-2/">Parsing Code With Sprache Part 2</a> </h1> <time datetime="2021-03-13T00:00:00+00:00" class="post-date"> 13th March 2021 </time> <!-- <span class="permalink"> </span> --> <!-- using excerpts: https://jekyllrb.com/docs/posts/#post-excerpts --> <blockquote> <p>😎 Este é o segundo artigo de uma série de partes múltiplas sobre <strong>como analisar código com Sprache</strong>. Você pode ler a primeira parte <a href="2021-02-13-parsing-code-with-sprache">aqui</a>.</p> </blockquote> <p>No post anterior, vimos como analisar algum texto (em particular, código Java) usando <a href="https://github.com/sprache/Sprache" target="_blank" rel="noopener noreferrer">Sprache</a>, uma poderosa biblioteca para C#. Vimos como usar uma abordagem incremental e como usar testes unitários para conduzir o desenvolvimento com esta ferramenta. Até agora, escrevemos um analisador para <code class="language-plaintext highlighter-rouge">Identifier</code> e <code class="language-plaintext highlighter-rouge">PackageName</code> (verifique <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser/blob/c5f7f6ce78382ac47e8ab0d03ca43851425d1545/src/TinyJavaParser/JavaGram.cs" target="_blank" rel="noopener noreferrer">aqui</a>).</p> <p>Agora vamos avançar um pouco mais rápido. Lembre-se de que temos como alvo o source Java/Android <a href="https://github.com/google/google-authenticator-android/tree/master/java/com/google/android/apps/authenticator" target="_blank" rel="noopener noreferrer">Google Authenticator</a> e que nosso objetivo final é gerar um gráfico de dependências de classe para este projeto. Neste artigo, vamos tentar analisar todos os elementos de nível superior do arquivo atual em que estamos trabalhando, <a href="https://github.com/google/google-authenticator-android/blob/master/java/com/google/android/apps/authenticator/AuthenticatorActivity.java" target="_blank" rel="noopener noreferrer">AuthenticatorActivity.java</a>.</p> <blockquote> <p>❗ Em todo o código do blog, eliminei a documentação interna para maior clareza. Verifique o <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser" target="_blank" rel="noopener noreferrer">repo</a> para ver os comentários.</p> </blockquote> <h1 id="refatorando-nosso-caminho-para-o-sucesso">Refatorando nosso caminho para o sucesso</h1> <p>Antes de incrementar o código atual, identifiquei um pequeno ajuste que nos ajudará na próxima etapa. Veja, o analisador <code class="language-plaintext highlighter-rouge">PackageName</code> está, na verdade, analisando uma <em>instrução package (package statement)</em>. Nomes de pacotes são usados ​​em outros lugares, portanto, facilitaremos a reutilização extraindo um <code class="language-plaintext highlighter-rouge">PackageName</code> do analisador atual.</p> <p>Primeiro, renomeie o analisador <code class="language-plaintext highlighter-rouge">JavaGrammar.PackageName</code> para <code class="language-plaintext highlighter-rouge">JavaGrammar.PackageStament</code>, o nome correto para o que está analisando; use suas ferramentas de refatoração de IDE para isso. Você também precisa renomear a unidade de teste anterior de <code class="language-plaintext highlighter-rouge">PackageNameParserTests</code> para <code class="language-plaintext highlighter-rouge">PackageStatementParserTests</code> para manter as coisas coerentes.</p> <p>A seguir, vamos extrair a análise de um <code class="language-plaintext highlighter-rouge">PackageName</code> de <code class="language-plaintext highlighter-rouge">JavaGrammar.PackageStament</code>. Veja as linhas abaixo:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">PackageStatement</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
	<span class="c1">// ↓↓↓↓↓↓↓ Parsing of Package Name ↓↓↓↓↓↓↓</span>
	<span class="k">from</span> <span class="n">packageHead</span> <span class="k">in</span> <span class="n">Identifier</span>
	<span class="k">from</span> <span class="n">packageTail</span> <span class="k">in</span> <span class="p">(</span><span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'.'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
							<span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">Identifier</span>
							<span class="k">select</span> <span class="n">identifier</span><span class="p">).</span><span class="nf">Many</span><span class="p">()</span>
	<span class="c1">// ↑↑↑↑↑↑↑ Parsing of Package Name ↑↑↑↑↑↑↑</span>
	<span class="k">from</span> <span class="n">terminator</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
	<span class="c1">// ↓↓↓↓↓↓↓ And this is how the result is build ↓↓↓↓↓↓↓</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">PackageName</span><span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="n">packageHead</span> <span class="p">}.</span><span class="nf">Concat</span><span class="p">(</span><span class="n">packageTail</span><span class="p">).</span><span class="nf">ToList</span><span class="p">());</span>
	<span class="c1">// ↑↑↑↑↑↑↑ And this is how the result is build ↑↑↑↑↑↑↑↑</span>
</code></pre></div></div> <p>Vamos extrair isso em um analisador isolado, este na verdade chamado <code class="language-plaintext highlighter-rouge">PackageName</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">PackageName</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">packageHead</span> <span class="k">in</span> <span class="n">Identifier</span>
	<span class="k">from</span> <span class="n">packageTail</span> <span class="k">in</span> <span class="p">(</span><span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'.'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
						 <span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">Identifier</span>
						 <span class="k">select</span> <span class="n">identifier</span><span class="p">).</span><span class="nf">Many</span><span class="p">()</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">PackageName</span><span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="n">packageHead</span> <span class="p">}.</span><span class="nf">Concat</span><span class="p">(</span><span class="n">packageTail</span><span class="p">).</span><span class="nf">ToList</span><span class="p">());</span>
</code></pre></div></div> <p>Precisamos criar uma estrutura para representar a <em>instrução package</em>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageStatement</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">PackageStatement</span><span class="p">(</span><span class="n">PackageName</span> <span class="n">packageName</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">PackageName</span> <span class="p">=</span> <span class="n">packageName</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">PackageName</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Vamos atualizar o analisador <code class="language-plaintext highlighter-rouge">PackageStatement</code> para retornar a estrutura, usando o analisador<code class="language-plaintext highlighter-rouge"> PackageName</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">PackageStatement</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">packageName</span> <span class="k">in</span> <span class="n">PackageName</span>
	<span class="k">from</span> <span class="n">terminator</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
	<span class="k">select</span> <span class="n">packageName</span><span class="p">;</span>
</code></pre></div></div> <p>Execute todos os testes e você descobrirá que tudo está funcionando como deveria. Esta refatoração foi confirmada sob a tag <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser/tree/Refactor_PackageName" target="_blank" rel="noopener noreferrer">Refactor_PackageName</a>.</p> <h1 id="analisando-mais-estruturas">Analisando mais estruturas</h1> <p>Vamos voltar à criação de novos analisadores. A próxima estrutura natural é uma declaração de importação que tem o seguinte BNF:</p> <h2 id="declaração-de-importação">Declaração de importação</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IMPORT = "import", PACKAGE_NAME, ";";
</code></pre></div></div> <p>Vamos começar atualizando nossa classe <code class="language-plaintext highlighter-rouge">Import</code> anterior. Mude seu nome de <code class="language-plaintext highlighter-rouge">Import</code> para <code class="language-plaintext highlighter-rouge">ImportStatement</code>, que é mais exato. <strong>Use sua ferramenta de refatoração IDE para renomear a classe.</strong> Eu também criei um construtor para ela que inicializa o <code class="language-plaintext highlighter-rouge">PackageName</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ImportStatement</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">ImportStatement</span><span class="p">(</span><span class="n">PackageName</span> <span class="n">packageName</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">PackageName</span> <span class="p">=</span> <span class="n">packageName</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">PackageName</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Agora, vamos criar um teste para isso:</p> <blockquote> <p>😎 Estou criando um arquivo de teste para cada analisador, embora eles (atualmente) sejam todos parte da mesma classe. Isso não é <em>padrão</em>; é a melhor prática ter uma classe de teste de unidade <em>por classe</em>. Entretanto, fazer dessa forma torna mais fácil localizar os testes e nos permite mantê-los mais organizados.</p> </blockquote> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ImportStatementParserTests</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
	<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"import android.annotation.TargetApi;"</span><span class="p">)]</span>
	<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"import android.app.Activity;"</span><span class="p">)]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackageName_ReturnsStructureWithCorrectName</span><span class="p">(</span><span class="kt">string</span> <span class="n">importStatement</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">ImportStatement</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">importStatement</span><span class="p">);</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">packageName</span><span class="p">,</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">PackageName</span><span class="p">.</span><span class="n">Identifiers</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Usamos as primeiras instruções de <code class="language-plaintext highlighter-rouge">import</code> de <code class="language-plaintext highlighter-rouge">AuthenticatorActivity</code>, como você pode ver. Também estamos fazendo um <code class="language-plaintext highlighter-rouge">join</code> dos identificadores assim como fizemos da última vez, o que é um pouco tedioso; vamos melhorar isso na etapa de <em>refatorar</em>.</p> <p>A execução desse teste levará a 🔴, pois o código não foi implementado. Vamos escrever o analisador agora:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">ImportStatement</span><span class="p">&gt;</span> <span class="n">ImportStatement</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">importKeyword</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"import"</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">packageName</span> <span class="k">in</span> <span class="n">PackageName</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">ImportStatement</span><span class="p">(</span><span class="n">packageName</span><span class="p">);</span>
</code></pre></div></div> <p>Leitores ávidos notarão o método anteriormente não visto <code class="language-plaintext highlighter-rouge">Token()</code> na segunda linha. Este é um dos métodos mais úteis no Sprache - removerá os espaços em branco ao redor do caractere, mas * exigirá * que ele esteja lá. Isso significa que, por exemplo, <code class="language-plaintext highlighter-rouge">Parse.String("import").Token().Parse(" import ")</code> funcionará, mas <code class="language-plaintext highlighter-rouge">Parse.String("import").Token().Parse(" importasd ")</code> não.</p> <p>O resto deve ser muito legível - procure a palavra-chave <code class="language-plaintext highlighter-rouge">import</code>, depois uma estrutura PackageName e retorne uma instrução import. <strong>Execute todos os testes.</strong> Você deve obter um 🟢.</p> <p>Continuando, vamos refatorar um pouco. Lembra que eu disse que faríamos algo sobre <code class="language-plaintext highlighter-rouge">string.Join('.', actual.PackageName.Identifiers)</code>? Agora é a hora!</p> <p>A representação de string de um nome de pacote, digamos, “android.content.ActivityNotFoundException” não é outro senão “android.content.ActivityNotFoundException”. Então, o que você acha de substituir <code class="language-plaintext highlighter-rouge">PackageName.ToString</code> para cumprir esse comportamento?</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageName</span>
<span class="p">{</span>
	<span class="c1">// ...</span>

	<span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span> <span class="n">Identifiers</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>😎 <strong>DICA:</strong> Ao realizer um <code class="language-plaintext highlighter-rouge">override</code> em métodos e propriedades, use o xml doc <code class="language-plaintext highlighter-rouge">/// &lt;inheritdoc /&gt;</code> como documentação.</p> </blockquote> <p>Agora, seguindo a mesma ideia, podemos adicionar uma substituição de <code class="language-plaintext highlighter-rouge">ToString</code> em <code class="language-plaintext highlighter-rouge">ImportStatement</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ImportStatement</span>
<span class="p">{</span>
	<span class="c1">// ...</span>

	<span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="s">$"import </span><span class="p">{</span><span class="n">PackageName</span><span class="p">}</span><span class="s">;"</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Agora podemos atualizar nosso teste de unidade para refletir este refator:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"import android.annotation.TargetApi;"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"import android.app.Activity;"</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackageName_ReturnsStructureWithCorrectName</span><span class="p">(</span><span class="kt">string</span> <span class="n">importStatement</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">ImportStatement</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">importStatement</span><span class="p">);</span>

	<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">importStatement</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="nf">ToString</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>⚠ <strong>Aviso</strong>: neste caso, a entrada é formatada exatamente como a saída de <code class="language-plaintext highlighter-rouge">ImportStatement.ToString</code>. No entanto, se você analisar algo como <code class="language-plaintext highlighter-rouge">" import name.surname"</code>, enquanto a análise funcionará, o <code class="language-plaintext highlighter-rouge">ToString</code> retornará <code class="language-plaintext highlighter-rouge">"import name.surname"</code>, sem espaços. Isso significa que a regra <code class="language-plaintext highlighter-rouge">Token ()</code> não está sendo testada em nossa suíte - a razão para isso é que ela não aparece em nosso escopo - portanto, os testes são um pouco frágeis e devem ser melhorados na maioria das circunstâncias. Não vou fazer isso durante esses exercícios, mas os leitores devem definitivamente fazê-lo.</p> </blockquote> <p>Agora, precisamos ler um bloco de importações em nosso arquivo. Chamamos isso de IMPORT_LIST no eBNF. A estrutura de dados para isso não precisa ser mais do que <code class="language-plaintext highlighter-rouge">List &lt;ImportStatement&gt;</code>, mas precisamos de um analisador para isso. Comece com um teste:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ImportListParserTests</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">[</span><span class="k">]&gt;</span> <span class="nf">ImportLists</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">string</span><span class="p">[]</span>
		<span class="p">{</span>
			<span class="s">@"
import com.google.android.apps.authenticator.util.EmptySpaceClickableDragSortListView;
import com.google.android.apps.authenticator.util.annotations.FixWhenMinSdkVersion;
import com.google.android.apps.authenticator2.R;
import com.google.common.annotations.VisibleForTesting;
			"</span><span class="p">.</span><span class="nf">Trim</span><span class="p">(),</span>
		<span class="p">};</span>

		<span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">string</span><span class="p">[]</span>
		<span class="p">{</span>
			<span class="s">@"
import android.support.v7.widget.Toolbar;
import android.text.Html;
import android.util.Log;
import android.view.ActionMode;
import android.view.ContextMenu;
			"</span><span class="p">.</span><span class="nf">Trim</span><span class="p">(),</span>
		<span class="p">};</span>
	<span class="p">}</span>

	<span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
	<span class="p">[</span><span class="nf">MemberData</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">ImportLists</span><span class="p">))]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackageName_ReturnsStructureWithCorrectName</span><span class="p">(</span><span class="kt">string</span> <span class="n">importList</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">expected</span> <span class="p">=</span> <span class="n">importList</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">).</span><span class="nf">ToList</span><span class="p">();</span>
		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">ImportList</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">importList</span><span class="p">);</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span> <span class="n">_</span><span class="p">.</span><span class="nf">ToString</span><span class="p">()));</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>A implementação da lista é simples:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">ImportStatement</span><span class="p">&gt;&gt;</span> <span class="n">ImportList</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">statements</span> <span class="k">in</span> <span class="n">ImportStatement</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">select</span> <span class="n">statements</span><span class="p">.</span><span class="nf">ToList</span><span class="p">();</span>
</code></pre></div></div> <p>Agora que as importações foram tratadas, vamos passar para a próxima estrutura de código em <code class="language-plaintext highlighter-rouge">AuthenticatorActivity.java</code>, uma <em>anotação</em>.</p> <h2 id="anotações">Anotações</h2> <p>A próxima estrutura de código em <code class="language-plaintext highlighter-rouge">AuthenticatorActivity</code> é a declaração da classe. Ele contém um trecho de código sobre o qual não falamos antes, uma anotação.</p> <p>As anotações Java são análogas aos atributos C# e têm a seguinte aparência:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FixWhenMinSdkVersion</span><span class="o">(</span><span class="mi">11</span><span class="o">)</span>
</code></pre></div></div> <p>Assim como no C#, essas estruturas só podem aparecer antes das declarações e, neste caso, é uma declaração de classe. Precisamos criar a estrutura de dados para acomodar isso e o analisador para produzi-la.</p> <p>Conforme mencionado anteriormente, estamos construindo interativamente o eBNF. Isso é para tornar nosso analisador mais simples - apenas escrever o código necessário para as estruturas que estão presentes no código-fonte. É por isso que a anotação não foi mencionada antes. Vamos atualizá-lo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ANNOTATION = "@", IDENTIFIER, "(", ARGUMENT_LIST, ")"

ARGUMENT_LIST = ARGUMENT, { "," ARGUMENT }

ARGUMENT = LITERAL

LITERAL = INTEGER_LITERAL
</code></pre></div></div> <p><strong>O eBNF acima é parcial</strong>; Por exemplo, a lista de argumentos para a anotação é mais complexa, permitindo outros tipos. Mas até agora só temos o parâmetro inteiro, então vamos nos ater a ele.</p> <p>A primeira coisa é definir a estrutura de dados de uma anotação. Olhando para ele, você pode imaginar que tem um identificador como nome e, em seguida, a lista de argumentos.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">interface</span> <span class="nc">ILiteral</span>
<span class="p">{</span>
	<span class="kt">object</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">IntegerLiteral</span>  <span class="p">:</span> <span class="n">ILiteral</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">IntegerLiteral</span><span class="p">(</span><span class="kt">int</span> <span class="k">value</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="n">Value</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> 

	<span class="kt">object</span> <span class="n">ILiteral</span><span class="p">.</span><span class="n">Value</span> <span class="p">=&gt;</span> <span class="n">Value</span><span class="p">;</span>

	<span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">Value</span><span class="p">.</span><span class="nf">ToString</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Annotation</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">Annotation</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ILiteral</span><span class="p">&gt;</span> <span class="n">arguments</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Name</span> <span class="p">=</span> <span class="n">name</span><span class="p">;</span>
		<span class="n">Arguments</span> <span class="p">=</span> <span class="n">arguments</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

	<span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Argument</span><span class="p">&gt;</span> <span class="n">Arguments</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

	<span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="s">$"@</span><span class="p">{</span><span class="n">Name</span><span class="p">}</span><span class="s">(</span><span class="p">{</span><span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="s">", "</span><span class="p">,</span> <span class="n">Arguments</span><span class="p">)}</span><span class="s">)"</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Introduzimos um pouco de abstração que pode nos poupar algum trabalho mais tarde - deixamos claro que literal pode ser muitas coisas, não apenas inteiros. A conversão para a estrutura correta permitirá que os usuários obtenham o valor digitado - caso contrário, por enquanto, encaixaremos o int e o retornamos como um objeto.</p> <p>Precisamos criar um analisador para essa nova estrutura - um literal inteiro.</p> <p>Testes:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">IntergerLiteralParserTests</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
	<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="m">11</span><span class="p">)]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">MyTheory</span><span class="p">(</span><span class="kt">int</span> <span class="k">value</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">IntegerLiteral</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="k">value</span><span class="p">.</span><span class="nf">ToString</span><span class="p">());</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="k">value</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>E o analisador:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">IntegerLiteral</span><span class="p">&gt;</span> <span class="n">IntegerLiteral</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">digits</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="n">Digit</span><span class="p">.</span><span class="nf">AtLeastOnce</span><span class="p">()</span>
	<span class="k">let</span> <span class="n">number</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Concat</span><span class="p">(</span><span class="n">digits</span><span class="p">)</span>
	<span class="k">let</span> <span class="k">value</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">IntegerLiteral</span><span class="p">(</span><span class="k">value</span><span class="p">);</span>
</code></pre></div></div> <p>Uma coisa no código acima que pode fazer você se perguntar é o <code class="language-plaintext highlighter-rouge">AtLeastOnce()</code>. Isso é muito próximo de <code class="language-plaintext highlighter-rouge">Many()</code>, com a diferença de que irá falhar na análise quando não houver pelo menos um único dígito. Se não aplicarmos isso aqui, o analisador aceitará uma lista de argumentos vazia.</p> <p>Agora vamos para a anotação real.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">AnnotationParserTests</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
	<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"@Number(11)"</span><span class="p">,</span> <span class="k">new</span> <span class="kt">object</span><span class="p">[]</span> <span class="p">{</span> <span class="m">11</span> <span class="p">})]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenAnnotationHasParameters_CorrectParameters</span><span class="p">(</span><span class="kt">string</span> <span class="n">annotation</span><span class="p">,</span> <span class="kt">object</span><span class="p">[]</span> <span class="n">parameters</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">Annotation</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">annotation</span><span class="p">);</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Arguments</span><span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;().</span><span class="nf">ToArray</span><span class="p">());</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>❗ Esses testes são muito básicos; na maioria dos cenários de produção, sugiro escrever testes que tenham mais condições; por exemplo, poderíamos testar casos como <code class="language-plaintext highlighter-rouge">@ SomeAnnotation</code>, dividindo o código em duas linhas, etc. Observe o código que está sendo testado para encontrar lacunas ou riscos e crie os testes correspondentes. Finalmente, com TDD devemos escrever um teste por vez e evoluir iterativamente.</p> <p>A razão pela qual podemos nos safar com testes tão simples é que sabemos com antecedência todo o código que precisa ser analisado, então podemos testar novamente um caso real e verificar se surgem bugs, mas mesmo assim, eu teria cuidado onde isso não apenas uma postagem no blog.</p> </blockquote> <p>A implementação irá alavancar o analisador <code class="language-plaintext highlighter-rouge">IntegerLiteral</code> que acabamos de codificar:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">Annotation</span><span class="p">&gt;</span> <span class="n">Annotation</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">at</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'@'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">Identifier</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">startList</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'('</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">literal</span> <span class="k">in</span> <span class="n">IntegerLiteral</span><span class="p">.</span><span class="nf">Token</span><span class="p">().</span><span class="nf">Optional</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">endList</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">')'</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">let</span> <span class="n">arguments</span> <span class="p">=</span> <span class="n">literal</span><span class="p">.</span><span class="n">IsDefined</span>
		<span class="p">?</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ILiteral</span><span class="p">&gt;</span> <span class="p">{</span> <span class="n">literal</span><span class="p">.</span><span class="nf">Get</span><span class="p">()</span> <span class="p">}</span>
		<span class="p">:</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ILiteral</span><span class="p">&gt;()</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">Annotation</span><span class="p">(</span><span class="n">identifier</span><span class="p">,</span> <span class="n">arguments</span><span class="p">);</span>
</code></pre></div></div> <p>Novamente, podemos ver um analisador opcional sendo chamado. Para obter a lista real, precisamos fazer alguma ginástica LINQ - retornar uma lista com um único literal ou uma lista vazia. No futuro, provavelmente criaremos um analisador <code class="language-plaintext highlighter-rouge">ArgumentList</code> que deve substituir isso, mas até agora, não há necessidade.</p> <p>Os testes devem ser 🟢.</p> <h2 id="declaração-de-classe">Declaração de classe</h2> <p>A próxima coisa no arquivo é a definição real da classe. Vamos decompô-lo:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FixWhenMinSdkVersion</span> <span class="o">(</span><span class="mi">11</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AuthenticatorActivity</span> <span class="n">estende</span> <span class="nc">TestableActivity</span> <span class="o">{</span>
<span class="c1">// ...</span>
</code></pre></div></div> <p>Este é um bom exemplo porque, de cara, lidaremos com <code class="language-plaintext highlighter-rouge">extends</code>, um caso comum, mas não basal. A anotação já foi cuidada, então vamos analisar a declaração da classe:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>visibility
   │
   │          identifier, class          identifier, base class
   │                   │                          │
┌──┴─┐       ┌─────────┴─────────┐         ┌──────┴───────┐
public class AuthenticatorActivity extends TestableActivity 
       └─┬─┘                       └──┬──┘
         │             interface inheritance keyword
         │
class declaration keyword
</code></pre></div></div> <p>Portanto, precisamos expandir o EBNF:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CLASS_DECLARATION = VISIBILITY, "class", IDENTIFIER, { "extends", IDENTIFIER }, "{", (* ommited *), "}";

VISIBILITY = "public" 
</code></pre></div></div> <blockquote> <p>❗ Não estamos lidando com outras visibilidades apenas no momento, a não ser para refletir nossa abordagem em evolução. À medida que lidamos com mais casos, expandimos a definição.</p> </blockquote> <p>Isso deve ser realmente simples, mas precisamos atualizar a estrutura da classe para refleti-la:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">enum</span> <span class="n">Visibility</span>
<span class="p">{</span>
	<span class="n">Public</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">ClassDefinition</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">ClassDefinition</span><span class="p">(</span><span class="n">Visibility</span> <span class="n">visibility</span><span class="p">,</span> <span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">string</span><span class="p">?</span> <span class="n">baseClass</span> <span class="p">=</span> <span class="k">null</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">?</span> <span class="n">annotation</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Visibility</span> <span class="p">=</span> <span class="n">visibility</span><span class="p">;</span>
		<span class="n">Name</span> <span class="p">=</span> <span class="n">name</span><span class="p">;</span>
		<span class="n">BaseClass</span> <span class="p">=</span> <span class="n">baseClass</span><span class="p">;</span>
		<span class="n">Annotation</span> <span class="p">=</span> <span class="n">annotation</span><span class="p">;</span>
	<span class="p">}</span>

		<span class="k">public</span> <span class="n">Visibility</span> <span class="n">Visibility</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

		<span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

		<span class="k">public</span> <span class="kt">string</span><span class="p">?</span> <span class="n">BaseClass</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

		<span class="k">public</span> <span class="n">Annotation</span><span class="p">?</span> <span class="n">Annotation</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Algumas coisas a serem observadas: estamos seguindo estritamente o trecho de código que está sendo processado, então, embora haja um membro Visibility, o único valor possível é <code class="language-plaintext highlighter-rouge">Public</code>; embora Java permita várias anotações, estamos apenas considerando uma única anotação etc. O motivo pelo qual estou seguindo essa abordagem é que ainda não sabemos se esses casos surgirão dentro do código. Se o fizerem, iremos reescrever o código acima.</p> <p>Agora vamos criar nossos testes:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ClassDefinitionParserTests</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_AnnotatedClassWithExtends_CorrectParameters</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">code</span> <span class="p">=</span> <span class="s">@"
@FixWhenMinSdkVersion(11)
public class AuthenticatorActivity extends TestableActivity
"</span><span class="p">.</span><span class="nf">Trim</span><span class="p">();</span>

		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">ClassDefinition</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">"FixWhenMinSdkVersion"</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Annotation</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="m">11</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Annotation</span><span class="p">.</span><span class="n">Arguments</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">Value</span><span class="p">);</span>
		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">Visibility</span><span class="p">.</span><span class="n">Public</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Visibility</span><span class="p">);</span>
		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">"AuthenticatorActivity"</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">"TestableActivity"</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">BaseClass</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Novamente, os testes lidam apenas com o que vimos até agora. Usei um <code class="language-plaintext highlighter-rouge">Fact</code> em vez de uma <code class="language-plaintext highlighter-rouge">Theory</code> porque estamos lidando apenas com um único caso. Assim que tivermos mais casos para testar, vou convertê-lo em <code class="language-plaintext highlighter-rouge">Theory</code>.</p> <p>Ah! Estou testando o resultado da análise de anotação, que na verdade está repetindo os testes já feitos no <code class="language-plaintext highlighter-rouge">AnnotationParserTests</code>. Poderíamos fazer isso de forma um pouco diferente e apenas ter certeza de que o analisador correto foi chamado, mas por enquanto, vamos manter isso simples e repetir o teste.</p> <p>Agora, a implementação, embora longa, é simples, apenas analise cada fragmento que vimos na análise acima:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">ClassDefinition</span><span class="p">&gt;</span> <span class="n">ClassDefinition</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">annotation</span> <span class="k">in</span> <span class="n">Annotation</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">visibility</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"public"</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">classKeyword</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"class"</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">className</span> <span class="k">in</span> <span class="n">Identifier</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">extendsKeyword</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"extends"</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">baseClassName</span> <span class="k">in</span> <span class="n">Identifier</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">ClassDefinition</span><span class="p">(</span><span class="n">Visibility</span><span class="p">.</span><span class="n">Public</span><span class="p">,</span> <span class="n">className</span><span class="p">,</span> <span class="n">baseClassName</span><span class="p">,</span> <span class="n">annotation</span><span class="p">);</span>
</code></pre></div></div> <p>Eu cortei alguns cantos aqui, como analisar a visibilidade diretamente. Também lidaremos com isso quando for necessário.</p> <p>Faça seus testes e aprecie seu 🟢.</p> <h1 id="resumo">Resumo</h1> <p>Com este artigo, concluímos a primeira etapa: podemos analisar todos os elementos de nível superior de um arquivo de origem Java. Você aprendeu um pouco mais sobre como usar Sprache e combinar analisadores e provavelmente aprendeu algumas técnicas sobre como criar código <em>apto para o propósito</em>, usando uma abordagem orientada a testes e evoluindo o código anterior à medida que avançamos em nosso entendimento do domínio do problema, um processo denominado ** descoberta **.</p> <p>Todo o código produzido até agora foi armazenado em <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser" target="_blank" rel="noopener noreferrer">Github</a>. Você pode fazer um fork e usá-lo da maneira que quiser. Para obter a versão exata deste código, use <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser/releases/tag/SecondArticle" target="_blank" rel="noopener noreferrer">esta tag</a>.</p> <p>No próximo artigo, começaremos a analisar elementos de classe como construtores, campos e métodos. Estaremos ainda mais focados, lidando apenas com as estruturas de código que aparecem no código e, com sorte, poderemos terminar de analisar nossa primeira classe.</p> <p>Vejo você na próxima vez!</p> <div style="text-align: right;"> <!-- TODO: create style --> <a href="/pt/parsing-code-with-sprache-part-2/" style="font-size: 75%; font-style: italic;">Continuar lendo →</a> </div> <br> <div class="tag-list"> <a href="/pt/tags/#dotnet">#dotnet</a>   <a href="/pt/tags/#programa%C3%A7%C3%A3o">#programação</a>   <a href="/pt/tags/#linguagem">#linguagem</a>   <a href="/pt/tags/#sprache">#sprache</a>   <a href="/pt/tags/#tdd">#tdd</a> </div> </article> <article class="post"> <h1 class="post-title"> <a href="/pt/read-my-blog-in-portuguese/">Leia meu blog em português ou inglês!</a> </h1> <time datetime="2021-02-17T00:00:00+00:00" class="post-date"> 17th February 2021 em <a href="/pt/categories/#An%C3%BAncios">Anúncios</a> </time> <!-- <span class="permalink"> </span> --> <!-- using excerpts: https://jekyllrb.com/docs/posts/#post-excerpts --> <p>Depois de algum esforço, consegui permitir que meu blog ficasse multilíngual. Agora todos os posts estão em português ou ingles. Leitores detalhistas já terão notado os ícones que permitem selecionar a língua:</p> <div style="text-align: right;"> <!-- TODO: create style --> <a href="/pt/read-my-blog-in-portuguese/" style="font-size: 75%; font-style: italic;">Continuar lendo →</a> </div> <br> <div class="tag-list"> <a href="/pt/tags/#meta">#meta</a> </div> </article> <article class="post"> <h1 class="post-title"> <a href="/pt/parsing-code-with-sprache/">Analisando código com Sprache - Parte 1</a> </h1> <time datetime="2021-02-13T10:00:00+00:00" class="post-date"> 13th February 2021 em <a href="/pt/categories/#Desenvolvimento">Desenvolvimento</a> </time> <!-- <span class="permalink"> </span> --> <!-- using excerpts: https://jekyllrb.com/docs/posts/#post-excerpts --> <p>Você provavelmente sabe que às vezes (<em>muitas</em> vezes), o trabalho de um desenvolvedor é muito mais pesquisa ou análise do que programação! No passado, houve muitos casos em que eu estava em um projeto em que meu objetivo era migrar ou reescrever software antigo e, durante esses compromissos, acabei criando ferramentas para me ajudar. Muitas dessas ferramentas eram analisadores de código especializados que realizavam automaticamente a análise que eu exigia ou até mesmo geravam códigos mais novos que eu poderia utilizar.</p> <p>Em todos esses casos, precisei analisar algum código estruturado e há uma maneira simples de fazer isso: usando <a href="https://github.com/sprache/Sprache" target="_blank" rel="noopener noreferrer">Sprache</a>, um framework de parsing para dotnet. Neste artigo, vamos ver como fazer isso.</p> <h1 id="analisando-código-java">Analisando código Java</h1> <p>Você pode escrever todos os tipos de analisadores com Sprache. Contanto que a linguagem seja formal, é fácil construir o código necessário, e você faz isso aproveitando todas as maravilhas da sintaxe C#. Vou propor um exemplo: um analisador para uma gramática <strong>parcial</strong> Java ☕.</p> <p>Estou escolhendo Java porque é complexo o suficiente para nos permitir ver como o Sprache pode tornar sua vida mais fácil; tabém por que o Java está próximo do C#, então os leitores entenderão rapidamente a maior parte dele; e porque a gramática formal do Java é estruturada de tal forma que é possível extrapolar sua gramática sem muita pesquisa.</p> <p>Obviamente, escrever um analisador completo demoraria muito; teremos que nos limitar a um analisador parcial. A maneira como fazemos isso é obter o código que queremos analisar e, em seguida, especificar a gramática exatamente para isso (eu chamo essa abordagem de <em>best fit</em>, importante princípio ágil). Então, escolhi uma vítima para este esforço: <a href="https://github.com/google/google-authenticator-android/tree/master/java/com/google/android/apps/authenticator" target="_blank" rel="noopener noreferrer">Google Authenticator</a> é a fonte de um aplicativo Android que gera OTP’s. O aplicativo pode ser encontrado na <a href="https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&amp;hl=en_US&amp;gl=US" target="_blank" rel="noopener noreferrer">Play Store</a>.</p> <blockquote> <p>😎 Eu já ysei este código-fonte como base para reproduzir o algoritmo de OTP, então estou familiarizado com ele.</p> </blockquote> <p>Para ter um objetivo tangível, iremos gerar um gráfico de dependências entre classes do código; Isso deve ajudá-lo a saber como fazer mais do que apenas a análise, mas também como usar o código analisado para obter insights ou produzir outros artefatos.</p> <h1 id="java-bnf">Java BNF</h1> <p>O ponto de partida para nosso código é a gramática formal do Java. O <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form" target="_blank" rel="noopener noreferrer">eBNF</a> - Notação ou Forma Backus-Naur Estendida - é uma descrição de uma gramática formal. Por exemplo, um bloco <code class="language-plaintext highlighter-rouge">for</code> em Java pode ser:</p> <p>Exemplo:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span> <span class="o">}</span>
</code></pre></div></div> <p>Gramática:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FORBLOCK = "for" "(" INITIALIZER ";" CONDITION ";" INCREMENT) BLOCK

INITIALIZER = ASSIGNMENT

ASSIGNMENT = TYPE VARIABLE "=" LITERAL 

CONDITION = BOOLEAN_EXPRESSION

INCREMENT = VARIABLE "++" | "++" VARIABLE

BLOCK = STATEMENT | "{" STATEMENT_LIST "}"
</code></pre></div></div> <blockquote> <p>❗ Esta gramática está incompleta e não necessariamente correta; Este é um guia prático sobre como usar o Sprache, não sobre BNF e linguagens formais.</p> </blockquote> <p>Portanto, começamos observando nosso código-alvo e criando uma pequena gramática. Para manter as coisas simples, iremos escrever analisadores para cada fonte em <code class="language-plaintext highlighter-rouge">java/com/google/android/apps/authenticator/</code> e ignorar os arquivos não-java.</p> <p>Por exemplo, dê uma olhada em <a href="https://github.com/google/google-authenticator-android/blob/master/java/com/google/android/apps/authenticator/AuthenticatorActivity.java" target="_blank" rel="noopener noreferrer">AuthenticatorActivity.java</a>, o primeiro arquivo no escopo. Você verá que as primeiras linhas são comentários e então temos uma instrução <code class="language-plaintext highlighter-rouge">package</code>, seguida por várias instruções <code class="language-plaintext highlighter-rouge">import</code> e, finalmente, uma definição de <code class="language-plaintext highlighter-rouge">class</code>. Excluindo os comentários (abordaremos isso mais tarde), a gramática seria:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>JAVA_FILE = PACKAGE, IMPORT_LIST, CLASS_DECLARATIONS;

PACKAGE = "pacote", PACKAGE_NAME, ";";

PACKAGE_NAME = WORD, {"." PALAVRA };

WORD = CHARACTER, {CHARACTER};

CHARACTER = LETTER | DIGIT;

IMPORT_LIST = IMPORT, {IMPORT};

IMPORT = "importar", PACKAGE_NAME, ";";

CLASS_DECLARATION = "public", "class", WORD, "{" (*omitido*) "}";
</code></pre></div></div> <p>Dê uma olhada nessa linguagem, compare-a com o arquivo, mas cheque-a contra seu conhecimento de Java (ou C#, apenas percebendo que essas duas linguagens são muito semelhantes). Por um lado, você provavelmente verá que a gramática acima pode ser usada para produzir o código-fonte; por outro, você perceberá rapidamente que ele não leva em consideração muitas construções que são legais em Java: por exemplo, uma fonte pode não ter <code class="language-plaintext highlighter-rouge">import</code>s quaisquer. Isso é o que quero dizer com * melhor ajuste * - estamos procurando uma maneira de analisar <strong>apenas</strong> o código no escopo.</p> <h1 id="configurando-o-projeto">Configurando o projeto</h1> <p>Assim que tivermos uma pequena gramática, podemos começar a codificar. Crie um novo projeto de biblioteca dotnet, adicione Sprache a ele via Nuget, crie um projeto de teste adicional com xUnit e baixe o código-fonte do Google Authenticator paraum diretório.</p> <p>Definiremos estruturas de dados para armazenar cada elemento de nossa gramática e um teste para verificar se a análise funcionou conforme o esperado.</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// BNF classes</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">JavaFile</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Package</span> <span class="n">Package</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Import</span><span class="p">&gt;</span> <span class="n">ImportList</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="n">ClassDefinition</span> <span class="n">ClassDefinition</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Package</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">PackageName</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">PackageName</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">PackageName</span><span class="p">()</span> <span class="p">{}</span>

	<span class="k">public</span> <span class="nf">PackageName</span><span class="p">(</span><span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">identifers</span><span class="p">)</span> 
	<span class="p">{</span> 
		<span class="n">Identifiers</span> <span class="p">=</span> <span class="n">identifers</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">Identifiers</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Import</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">PackageName</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">ClassDefinition</span>
<span class="p">{</span>
    <span class="c1">// OMMITED</span>
<span class="p">}</span>
</code></pre></div></div> <p>Algumas coisas importantes a serem observadas na estrutura acima:</p> <ul> <li>Eu não defini ImportList ou qualquer estrutura de lista - eu simplesmente usei o <code class="language-plaintext highlighter-rouge">List</code> genérico do C#.</li> <li>Eu não defini uma construção de WORD ainda - irei armazená-las simplesmente como strings por enquanto, já que não estamos interessados ​​nela.</li> </ul> <p>Agora, como se parece um <em>parser</em>? Precisamos de algo que possa obter os dados da fonte - texto, afinal - e produzir as estruturas acima:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">interface</span> <span class="nc">IParser</span> <span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="nf">Parse</span> <span class="p">(</span><span class="n">c</span><span class="err">ó</span><span class="n">digo</span> <span class="n">de</span> <span class="kt">string</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Este é um analisador básico para uma determinada definição <code class="language-plaintext highlighter-rouge">T</code> - é apenas um único método que lê uma string e retorna a estrutura desejada. Começaremos declarando um dos analisadores básicos, o analisador <code class="language-plaintext highlighter-rouge">Package</code>. <em>Revisitaremos essas estrutura com o tempo.</em></p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageNameParser</span> <span class="p">:</span> <span class="n">IParser</span><span class="p">&lt;</span><span class="n">Package</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Package</span> <span class="nf">Parse</span><span class="p">(</span><span class="kt">string</span> <span class="n">code</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotImplementedException</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Este será o nosso ponto de partida para o analisador.</p> <p>Com essas classes definidas, podemos passar à configuração dos testes.</p> <h1 id="os-primeiros-testes">Os primeiros testes</h1> <blockquote> <p>😎 Sempre escreva os testes primeiro.</p> </blockquote> <p>Usarei o xUnit, que provavelmente é o melhor framework de testes para C#. Você pode adaptar o código abaixo para o que quiser.</p> <p>O primeiro caso de teste deve ser um “aquecimento”, então testamos o que acontece quando o código é <code class="language-plaintext highlighter-rouge">nulo</code>.</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageNameParserTests</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenCodeNull_Throws</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">sut</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">PackageNameParser</span><span class="p">();</span>

        <span class="n">Assert</span><span class="p">.</span><span class="n">Throws</span><span class="p">&lt;</span><span class="n">ArgumentNullException</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="n">sut</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="k">null</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Execute o teste - ele falhará, como de costume, em conformidade com uma abordagem <em>red-green-refactor</em>. A próxima etapa é deixá-lo verde:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageNameParser</span> <span class="p">:</span> <span class="n">IParser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">PackageName</span> <span class="nf">Parse</span><span class="p">(</span><span class="kt">string</span> <span class="n">code</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentNullException</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">code</span><span class="p">));</span>

        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotImplementedException</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Execute-o novamente e o teste será aprovado. O aquecimento está feito, nosso próximo passo é criar um caminho feliz. Queremos testar se podemos capturar corretamente o nome do pacote:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackage_ReturnsName</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">packageExpresison</span> <span class="p">=</span> <span class="s">"package tinyJavaParser;"</span><span class="p">;</span>

    <span class="kt">var</span> <span class="n">sut</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">PackageNameParser</span><span class="p">();</span>
    
    <span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">sut</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">packageExpresison</span><span class="p">);</span>

    <span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">"tinyJavaParser"</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Indentifiers</span><span class="p">[</span><span class="m">0</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Execute-o e o teste falhará. Vamos implementar nosso primeiro analisador Sprache!</p> <h2 id="analisadores-sprache">Analisadores Sprache</h2> <p>Se você der uma olhada no README do Sprache, saberá rapidamente como trabalhar com ele. Tudo começa com o objeto <code class="language-plaintext highlighter-rouge">Parse</code> estático, que pode ser chamado para analisar vários tipos de textos. Você constrói um analisador complexo combinando esses analisadores básicos usando LINQ.</p> <p>Por exemplo, nosso nome de pacote é uma string feita de chars, então podemos usar <code class="language-plaintext highlighter-rouge">Sprache.Parse.Letter</code> para analisá-lo, mas primeiro devemos levar em conta a palavra-chave<code class="language-plaintext highlighter-rouge"> package</code> e espaços que vem antes:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">parser</span> <span class="p">=</span>
    <span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
    <span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
    <span class="k">from</span> <span class="n">packageName</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">Letter</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">()</span>
    <span class="k">from</span> <span class="n">ending</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
    <span class="k">select</span> <span class="k">new</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="n">Indentifiers</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="p">{</span> <span class="n">packageName</span> <span class="p">}</span> <span class="p">};</span>
</code></pre></div></div> <p>Vejamos linha por linha. Em primeiro lugar, consideramos a palavra-chave do pacote, afirmando claramente que ela deve aparecer apenas <strong>uma vez</strong>:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
</code></pre></div></div> <p>Então sabemos que haverá alguns espaços entre a palavra-chave e o identificador:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">from</span> <span class="n">space1</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
</code></pre></div></div> <p>Depois disso, extraímos o nome do pacote, que é uma sequência de letras:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">from</span> <span class="n">packageName</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">Letter</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">()</span>
</code></pre></div></div> <p>E, finalmente, certificamo-nos de que a linha termina com um <code class="language-plaintext highlighter-rouge">;</code>:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">from</span> <span class="n">ending</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
</code></pre></div></div> <p>Depois de fazer tudo isso, podemos produzir a estrutura analisada, <code class="language-plaintext highlighter-rouge">PackageName</code>, usando os dados que coletamos antes:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">select</span> <span class="k">new</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="n">Indentifiers</span> <span class="p">=</span> <span class="k">new</span><span class="p">()</span> <span class="p">{</span> <span class="n">packageName</span> <span class="p">}</span> <span class="p">};</span>
</code></pre></div></div> <p>Vamos usar esse conhecimento e implementar o método:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">PackageName</span> <span class="nf">Parse</span><span class="p">(</span><span class="kt">string</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentNullException</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">code</span><span class="p">));</span>

    <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">parser</span> <span class="p">=</span>
        <span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">packageName</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">Letter</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">ending</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
        <span class="k">select</span> <span class="k">new</span> <span class="nf">PackageName</span><span class="p">(</span><span class="k">new</span><span class="p">()</span> <span class="p">{</span> <span class="n">packageName</span> <span class="p">})</span> <span class="p">};</span>

    <span class="k">return</span> <span class="n">parser</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Execute os testes, você obterá 🟢. Agora, antes de passarmos para <em>refatorar</em>, quero melhorar o teste que acabamos de fazer e torná-lo mais genérico.</p> <p>O teste considera apenas um nome de pacote com uma única palavra. Isso não é suficiente, e talvez você já tenha adivinhado que os identificadores compostos falharão. Adicionaremos alguns outros exemplos, e a melhor fonte para eles é - você adivinhou! - o código-fonte do Autenticador.</p> <blockquote> <p>Você pode perceber que também não consideramos possíveis identificadores que tenham letras ou símbolos como sublinhado. Mas, para manter nosso objetivo, não precisamos de um analisador que leia todos os códigos Java válidos já escritos, em vez disso, apenas algo que analise o fonte com o qual estamos lidando. Isso pode não ser o caso em outros projetos onde você precise de um parser - por exemplo, talvez você não tenha acesso total ao código antes de executar o analisador e, nesse caso, você precisará dar um mergulho profundo no definição de linguagem. Da mesma forma, nosso analisador não está tentando validar o código que está consumindo - seja o que for que encontrarmos nesses arquivos, aceitamos que seja Java válido. Novamente, você pode querer adotar uma abordagem diferente, por exemplo, se este analisador for alimentado com código escrito apenas para ele, já que então você terá pessoas cometendo erros e precisará dizer a elas quais são.</p> </blockquote> <p>Para encontrar os exemplos de pacotes, usei apenas o VSCode para abrir o diretório onde o código está, <code class="language-plaintext highlighter-rouge">java/com/google/android/apps/authenticator/</code>, e abri a ferrament de pesquisa:</p> <p><img src="../../../assets/vscode-search-example.png" alt="Caixa de pesquisa em VSCode"></p> <p>E agora mudamos o teste de <code class="language-plaintext highlighter-rouge">Fact</code> para <code class="language-plaintext highlighter-rouge">Theory</code> usando alguns desses nomes:</p> <blockquote> <p>Eu examinei a lista de pacotes e escolhi aqueles que achei representativos do domínio do nome. Vamos, depois, analisar tudo, mas é importante que antes disso já tenhamos alguns bons testes em funcionamento.</p> </blockquote> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"tinyJavaParser"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"com.google.android.apps.authenticator"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"com.google.android.apps.authenticator.enroll2sv.wizard"</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackage_ReturnsName</span><span class="p">(</span><span class="kt">string</span> <span class="n">packageName</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">packageExpresison</span> <span class="p">=</span> <span class="s">$"package </span><span class="p">{</span><span class="n">packageName</span><span class="p">}</span><span class="s">;"</span><span class="p">;</span>

    <span class="kt">var</span> <span class="n">sut</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">PackageNameParser</span><span class="p">();</span>

    <span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">sut</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">packageExpresison</span><span class="p">);</span>

    <span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">packageName</span><span class="p">,</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Identifiers</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div> <p>Tome seu tempo para entender as mudanças que fizemos no teste. Lembre-se de que a etapa <em>refatorar</em> se aplica também aos testes, portanto, embora possamos <em>poder</em> manter o teste como estava e apenas adicionar uma nova teoria, isso é mais limpo, ou seja, mais fácil de manter.</p> <p>Agora executamos os testes e, claro, 🔴. É hora de corrigir o código.</p> <p>Primeiro, tentamos corrigi-lo para * com.google.android.apps.authenticator *, contabilizando vários identificadores:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">PackageName</span> <span class="nf">Parse</span><span class="p">(</span><span class="kt">string</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentNullException</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">code</span><span class="p">));</span>

    <span class="n">Parser</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">identifierParser</span> <span class="p">=</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">Letter</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">();</span>

    <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">parser</span> <span class="p">=</span>
        <span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">packageHead</span> <span class="k">in</span> <span class="n">identifierParser</span>
        <span class="k">from</span> <span class="n">packageTail</span> <span class="k">in</span> <span class="p">(</span><span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'.'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
                                <span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">identifierParser</span>
                                <span class="k">select</span> <span class="n">identifier</span><span class="p">).</span><span class="nf">Many</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">terminator</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
        <span class="k">select</span> <span class="k">new</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="n">Identifiers</span> <span class="p">=</span> <span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="n">packageHead</span> <span class="p">}).</span><span class="nf">Concat</span><span class="p">(</span><span class="n">packageTail</span><span class="p">).</span><span class="nf">ToList</span><span class="p">()</span> <span class="p">};</span>

    <span class="k">return</span> <span class="n">parser</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Vamos mais uma vez dissecar o código.</p> <p>Começamos criando um “sub parser”, por assim dizer, que lê um identificador. Deve ser muito simples, pois é o mesmo código que tínhamos antes - pegue o máximo de letras em sequência possível e converta em “texto”, ou seja, uma <code class="language-plaintext highlighter-rouge">string</code>.</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">identifierParser</span> <span class="p">=</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">Letter</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">();</span>
</code></pre></div></div> <p>Agora incrementamos as regras de análise antigas para contabilizar as repetições de identificadores. Fazemos isso obtendo pelo menos o primeiro identificador e, opcionalmente, muitos outros. <code class="language-plaintext highlighter-rouge">packageTail</code> também usa um sub-analisador que eu não declarei, então é embutido porque só faz sentido dentro deste analisador.</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span> <span class="n">packageHead</span> <span class="k">in</span> <span class="n">identifierParser</span>
<span class="k">from</span> <span class="n">packageTail</span> <span class="k">in</span> <span class="p">(</span><span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'.'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
                        <span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">identifierParser</span>
                        <span class="k">select</span> <span class="n">identifier</span><span class="p">).</span><span class="nf">Many</span><span class="p">()</span>
</code></pre></div></div> <p>Finalmente, precisamos criar uma lista a partir do identificador único <code class="language-plaintext highlighter-rouge">packageHead</code> e os múltiplos em<code class="language-plaintext highlighter-rouge"> packageTail</code>, então eu trapacei um pouco:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="k">new</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="n">Identifiers</span> <span class="p">=</span> <span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="n">packageHead</span> <span class="p">}).</span><span class="nf">Concat</span><span class="p">(</span><span class="n">packageTail</span><span class="p">).</span><span class="nf">ToList</span><span class="p">()</span> <span class="p">};</span>
</code></pre></div></div> <p>Eu crio um array apenas com o packageHead (<code class="language-plaintext highlighter-rouge">new [] {packageHead}</code>) e concateno-o wcom <code class="language-plaintext highlighter-rouge">packageTail</code>. Depois disso, eu apenas chamo <code class="language-plaintext highlighter-rouge">ToList()</code> para transformar o array resultante em uma lista.</p> <p>Isso testará 🟢 verde para <code class="language-plaintext highlighter-rouge">"com.google.android.apps.authenticator"</code>, mas ainda falhará para <code class="language-plaintext highlighter-rouge">"com.google.android.apps.authenticator.enroll2sv.wizard "</code>. Vamos dar uma olhada no erro:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Message: 
    Sprache.ParseException : Parsing failure: unexpected '2'; expected ; (Line 1, Column 53); recently consumed: tor.enroll
</code></pre></div></div> <p>Sprache está nos dizendo que há um <code class="language-plaintext highlighter-rouge">2</code> que ele não esperava no stream e que acabou de consumir <code class="language-plaintext highlighter-rouge">"tor.enroll"</code>. Se olharmos para a string de entrada, é fácil ver por que ela falha:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                         Apenas leia daqui
                                  ↓
com.google.android.apps.authenticator.enroll2sv.wizard
                                            ↑
                                      Falhou aqui
</code></pre></div></div> <p>Portanto, como esperado, o número 2 não é permitido. Isso é apenas uma questão de expandir a definição de <code class="language-plaintext highlighter-rouge">identifierParser</code> para levar isso em consideração:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">identifierParser</span> <span class="p">=</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">LetterOrDigit</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">();</span>
</code></pre></div></div> <p>Faça testes e aprecie seu 🟢!</p> <h2 id="refatorar">Refatorar!</h2> <p>Agora é a hora de refatorar o código. Veremos como tornar nosso código mais simples de manter e usar.</p> <p>Há duas coisas que devemos observar:</p> <ul> <li> <p>Em <code class="language-plaintext highlighter-rouge">PackageNameParser.Parse</code>, criamos duas instâncias de parser, <code class="language-plaintext highlighter-rouge">identifierParser</code> e <code class="language-plaintext highlighter-rouge">parser</code>. Eles são usados ​​apenas uma vez, logo no retorno. Várias chamadas para este método resultam na recriação dessas instâncias, mas podem ser reutilizadas. Isso também é evidenciado pelos documentos do Sprache.</p> </li> <li> <p>Definimos uma interface <code class="language-plaintext highlighter-rouge">IParser&lt;T&gt;</code>, e Sprache tem um delegate <code class="language-plaintext highlighter-rouge">Parser&lt;out T&gt;</code>, que é muito próximo ao nosso. O Sprache pode definir analisadores usando seu delegate, e podemos combiná-los para produzir analisadores novos e mais complexos.</p> </li> </ul> <p>Com esse conhecimento, devemos refatorar nosso código para definir uma vez e usar os analisadores várias vezes; Devemos também abandonar nossa interface de análise e usar o delegado do Sprache. A maneira de fazer as coisas do Sprache é definir esses delegados como membros estáticos de uma classe, para que possamos criar:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">JavaGrammar</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">Identifier</span> <span class="p">=</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">LetterOrDigit</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">();</span>

	<span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">PackageName</span> <span class="p">=</span>
		<span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
		<span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
		<span class="k">from</span> <span class="n">packageHead</span> <span class="k">in</span> <span class="n">Identifier</span>
		<span class="k">from</span> <span class="n">packageTail</span> <span class="k">in</span> <span class="p">(</span><span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'.'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
								<span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">Identifier</span>
								<span class="k">select</span> <span class="n">identifier</span><span class="p">).</span><span class="nf">Many</span><span class="p">()</span>
		<span class="k">from</span> <span class="n">terminator</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
		<span class="k">select</span> <span class="k">new</span> <span class="nf">PackageName</span><span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="n">packageHead</span> <span class="p">}.</span><span class="nf">Concat</span><span class="p">(</span><span class="n">packageTail</span><span class="p">).</span><span class="nf">ToList</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div> <p>E mudar os testes para refletir isso:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageNameParserTests</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenCodeNull_Throws</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Assert</span><span class="p">.</span><span class="n">Throws</span><span class="p">&lt;</span><span class="n">ArgumentNullException</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">PackageName</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="k">null</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
    <span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"tinyJavaParser"</span><span class="p">)]</span>
    <span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"com.google.android.apps.authenticator"</span><span class="p">)]</span>
    <span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"com.google.android.apps.authenticator.enroll2sv.wizard"</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackage_ReturnsName</span><span class="p">(</span><span class="kt">string</span> <span class="n">packageName</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">packageExpresison</span> <span class="p">=</span> <span class="s">$"package </span><span class="p">{</span><span class="n">packageName</span><span class="p">}</span><span class="s">;"</span><span class="p">;</span>

        <span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">PackageName</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">packageExpresison</span><span class="p">);</span>

        <span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">packageName</span><span class="p">,</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Identifiers</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>❗ Se você estiver recebendo um erro informando que o delegado não tem um método Parse, não se preocupe! Você apenas tem que adicionar uma diretiva <code class="language-plaintext highlighter-rouge">using Sprache;</code> no topo do arquivo.</p> </blockquote> <p>Você pode remover a interface IParser que criamos para nos ajudar a definir como o código deve ser.</p> <h1 id="análise">Análise</h1> <p>Ufs, demorou muito! “Nós vimos muito! Vamos revisar tudo isso por um momento, certo?</p> <ul> <li>Você aprendeu que as sintaxes de linguagem são governadas por * gramáticas * e que podem ser expressas com uma notação conhecida como BNF ou EBNF.</li> <li>Você criou um EBNF simplificado para Java, levando em consideração apenas o que estava no escopo. Você sabe que chamamos isso de * melhor ajuste *, e um princípio ágil semelhante ao YAGNI - construa apenas o que você vai usar.</li> <li>Você criou vários casos de teste, a maioria derivados do próprio domínio do problema - a fonte do Autenticador do Google.</li> <li>Você aprendeu como combinar analisadores Sprache para criar outro analisador mais complexo.</li> </ul> <p>Isso lançou as bases para analisar as estruturas de programa mais complexas. No próximo artigo, terminaremos nossa gramática criando mais analisadores que podem lidar com todo o código-fonte. Também mostrarei como lidar com comentários e como “pular” código no qual você não está interessado. Seguindo esse artigo, como um bônus, terminaremos de construir nossa ferramenta e gerar o gráfico que mostrará aos usuários a relação entre as aulas.</p> <p>Todo o código produzido até agora foi armazenado no <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser" target="_blank" rel="noopener noreferrer">Github</a>. Você pode fazer um fork e usá-lo da maneira que quiser. Para obter a versão exata deste código, use <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser/releases/tag/FirstArticle" target="_blank" rel="noopener noreferrer">esta tag</a>.</p> <div style="text-align: right;"> <!-- TODO: create style --> <a href="/pt/parsing-code-with-sprache/" style="font-size: 75%; font-style: italic;">Continuar lendo →</a> </div> <br> <div class="tag-list"> <a href="/pt/tags/#dotnet">#dotnet</a>   <a href="/pt/tags/#programa%C3%A7%C3%A3o">#programação</a>   <a href="/pt/tags/#linguagem">#linguagem</a> </div> </article> <article class="post"> <h1 class="post-title"> <a href="/pt/happy-halloween-blog-is-back/">Feliz Halloween! Meu blog está de volta!</a> </h1> <time datetime="2020-10-31T18:00:00+00:00" class="post-date"> 31st October 2020 em <a href="/pt/categories/#An%C3%BAncios">Anúncios</a> </time> <!-- <span class="permalink"> </span> --> <!-- using excerpts: https://jekyllrb.com/docs/posts/#post-excerpts --> <p>Esta é minha terceira ou quarta tentativa de criar um blog, e espero ter sucesso em mantê-lo atualizado. Pelo menos agora eu finalmente tenho o tempo de que preciso para criar novos <em>posts</em> e continuar. Além disso, eu <em>adoro</em> GitHub Pages. É muito mais legal estar em uma plataforma que eu (meio que) controlo.</p> <div style="text-align: right;"> <!-- TODO: create style --> <a href="/pt/happy-halloween-blog-is-back/" style="font-size: 75%; font-style: italic;">Continuar lendo →</a> </div> <br> <div class="tag-list"> </div> </article> </div> <div class="PageNavigation"> </div> </main> <footer class="footer"> <div class="wrapper"> <div> © Copyright 2021 Bruno Brant. Tema baseado em <a href="https://github.com/essentialenemy/noir/" target="_blank" rel="noopener noreferrer">Noir</a> de <a href="https://essentialenemy.com/" target="_blank" rel="noopener noreferrer">Victor Johnson</a>. </div> <div class="social-links">
<ul class="social-media-list">
<li><a rel="noopener noreferrer" href="https://github.com/bruno-brant" title="bruno-brant" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li>
<li><a rel="noopener noreferrer" href="https://stackoverflow.com/users/227332%2Fbruno-brant" title="227332/bruno-brant" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#stackoverflow"></use></svg></a></li>
<li><a rel="noopener noreferrer" href="https://www.linkedin.com/in/brunobrant" title="brunobrant" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg></a></li>
<li><a rel="noopener noreferrer" href="https://twitter.com/HeavyStorm" title="HeavyStorm" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li>
</ul> </div> </div> </footer> </div> </body> </html>
