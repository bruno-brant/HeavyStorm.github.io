<!doctype html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <meta property="og:image" content="https://blog.brunobrant.net/assets/technology-matters-logo.png" /> <title> &middot; TECHNOLOGY MATTERS </title> <link rel="stylesheet" href="/pt/styles.css"> <!-- <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/pt/assets/apple-touch-icon-precomposed.png"> --> <link rel="shortcut icon" href="/pt/assets/favicon.ico"> <link rel="alternate" type="application/atom+xml" title="TECHNOLOGY MATTERS" href="/pt/feed.xml"> <!-- Begin Jekyll SEO tag v2.7.1 --> <meta name="generator" content="Jekyll v4.1.1" /> <meta property="og:title" content="Home" /> <meta name="author" content="Bruno Brant" /> <meta property="og:locale" content="pt" /> <link rel="canonical" href="https://blog.brunobrant.net/" /> <meta property="og:url" content="https://blog.brunobrant.net/" /> <meta property="og:site_name" content="TECHNOLOGY MATTERS" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Home" /> <script type="application/ld+json"> {"url":"https://blog.brunobrant.net/","@type":"WebSite","author":{"@type":"Person","name":"Bruno Brant"},"headline":"Home","name":"TECHNOLOGY MATTERS","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <script> /* Toggle between adding and removing the "responsive" class to topnav when the user clicks on the icon */ function openNavigation() { const navigationElems = document.getElementsByClassName("navigation"); if (navigationElems.length != 1) { console.warn("Couldn't find navbar"); return; } const x = navigationElems[0]; if (x.className === "navigation") { x.className += " responsive"; } else { x.className = "navigation"; } } </script> <body> <div class="container content"> <header class="masthead"> <h3 class="masthead-title"> <a href="/pt/" title="Home" class="masthead-title-main">TECHNOLOGY MATTERS</a><br> <small>pensamentos desordenados sobre tecnologia, software, etc.</small> </h3> <!-- Change navigation links here --> <div class="navigation"> <ul id="navigation-list"> <li> <a href="/pt/">HOME</a> </li> <li> <a href="/pt/archive/">POSTS</a> </li> <li> <a href="/pt/tags/">TAGS</a> </li> <li> <a href="/pt/categories/">CATEGORIAS</a> </li> <li> <a href="/pt/about/">SOBRE</a> </li> <li id="subscribe"> <a href="/feed.xml"> <p>ASSINAR</p> <svg class="svg-icon grey" style="fill: #f66a0a;"> <use xlink:href="/assets/minima-social-icons.svg#rss"></use> </svg> </a> </li> </ul> <div style="float:right"> <a href="javascript:void(0);" class="navigation-icon" onclick="openNavigation()">‚ò∞</a> </div> </div> <!-- Language selector --> <div class="language-selector"> <span class="language-selector-label">ler esse site em:</span> <a href="/"><span>üá∫üá∏</span></a> | <a href="/pt/"><span>üáßüá∑</span></a> </div> </header> <main> <!-- Multi language trick --> <div class="posts"> <article class="post"> <h1 class="post-title"> <a href="/pt/parsing-code-with-sprache-part-2/">Parsing Code With Sprache Part 2</a> </h1> <time datetime="2021-03-13T00:00:00+00:00" class="post-date"> 13th March 2021 </time> <!-- <span class="permalink"> </span> --> <!-- using excerpts: https://jekyllrb.com/docs/posts/#post-excerpts --> <blockquote> <p>üòé Este √© o segundo artigo de uma s√©rie de partes m√∫ltiplas sobre <strong>como analisar c√≥digo com Sprache</strong>. Voc√™ pode ler a primeira parte <a href="2021-02-13-parsing-code-with-sprache">aqui</a>.</p> </blockquote> <p>No post anterior, vimos como analisar algum texto (em particular, c√≥digo Java) usando <a href="https://github.com/sprache/Sprache" target="_blank" rel="noopener noreferrer">Sprache</a>, uma poderosa biblioteca para C#. Vimos como usar uma abordagem incremental e como usar testes unit√°rios para conduzir o desenvolvimento com esta ferramenta. At√© agora, escrevemos um analisador para <code class="language-plaintext highlighter-rouge">Identifier</code> e <code class="language-plaintext highlighter-rouge">PackageName</code> (verifique <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser/blob/c5f7f6ce78382ac47e8ab0d03ca43851425d1545/src/TinyJavaParser/JavaGram.cs" target="_blank" rel="noopener noreferrer">aqui</a>).</p> <p>Agora vamos avan√ßar um pouco mais r√°pido. Lembre-se de que temos como alvo o source Java/Android <a href="https://github.com/google/google-authenticator-android/tree/master/java/com/google/android/apps/authenticator" target="_blank" rel="noopener noreferrer">Google Authenticator</a> e que nosso objetivo final √© gerar um gr√°fico de depend√™ncias de classe para este projeto. Neste artigo, vamos tentar analisar todos os elementos de n√≠vel superior do arquivo atual em que estamos trabalhando, <a href="https://github.com/google/google-authenticator-android/blob/master/java/com/google/android/apps/authenticator/AuthenticatorActivity.java" target="_blank" rel="noopener noreferrer">AuthenticatorActivity.java</a>.</p> <blockquote> <p>‚ùó Em todo o c√≥digo do blog, eliminei a documenta√ß√£o interna para maior clareza. Verifique o <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser" target="_blank" rel="noopener noreferrer">repo</a> para ver os coment√°rios.</p> </blockquote> <h1 id="refatorando-nosso-caminho-para-o-sucesso">Refatorando nosso caminho para o sucesso</h1> <p>Antes de incrementar o c√≥digo atual, identifiquei um pequeno ajuste que nos ajudar√° na pr√≥xima etapa. Veja, o analisador <code class="language-plaintext highlighter-rouge">PackageName</code> est√°, na verdade, analisando uma <em>instru√ß√£o package (package statement)</em>. Nomes de pacotes s√£o usados ‚Äã‚Äãem outros lugares, portanto, facilitaremos a reutiliza√ß√£o extraindo um <code class="language-plaintext highlighter-rouge">PackageName</code> do analisador atual.</p> <p>Primeiro, renomeie o analisador <code class="language-plaintext highlighter-rouge">JavaGrammar.PackageName</code> para <code class="language-plaintext highlighter-rouge">JavaGrammar.PackageStament</code>, o nome correto para o que est√° analisando; use suas ferramentas de refatora√ß√£o de IDE para isso. Voc√™ tamb√©m precisa renomear a unidade de teste anterior de <code class="language-plaintext highlighter-rouge">PackageNameParserTests</code> para <code class="language-plaintext highlighter-rouge">PackageStatementParserTests</code> para manter as coisas coerentes.</p> <p>A seguir, vamos extrair a an√°lise de um <code class="language-plaintext highlighter-rouge">PackageName</code> de <code class="language-plaintext highlighter-rouge">JavaGrammar.PackageStament</code>. Veja as linhas abaixo:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">PackageStatement</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
	<span class="c1">// ‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì Parsing of Package Name ‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì</span>
	<span class="k">from</span> <span class="n">packageHead</span> <span class="k">in</span> <span class="n">Identifier</span>
	<span class="k">from</span> <span class="n">packageTail</span> <span class="k">in</span> <span class="p">(</span><span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'.'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
							<span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">Identifier</span>
							<span class="k">select</span> <span class="n">identifier</span><span class="p">).</span><span class="nf">Many</span><span class="p">()</span>
	<span class="c1">// ‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë Parsing of Package Name ‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë</span>
	<span class="k">from</span> <span class="n">terminator</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
	<span class="c1">// ‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì And this is how the result is build ‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">PackageName</span><span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="n">packageHead</span> <span class="p">}.</span><span class="nf">Concat</span><span class="p">(</span><span class="n">packageTail</span><span class="p">).</span><span class="nf">ToList</span><span class="p">());</span>
	<span class="c1">// ‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë And this is how the result is build ‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë</span>
</code></pre></div></div> <p>Vamos extrair isso em um analisador isolado, este na verdade chamado <code class="language-plaintext highlighter-rouge">PackageName</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">PackageName</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">packageHead</span> <span class="k">in</span> <span class="n">Identifier</span>
	<span class="k">from</span> <span class="n">packageTail</span> <span class="k">in</span> <span class="p">(</span><span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'.'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
						 <span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">Identifier</span>
						 <span class="k">select</span> <span class="n">identifier</span><span class="p">).</span><span class="nf">Many</span><span class="p">()</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">PackageName</span><span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="n">packageHead</span> <span class="p">}.</span><span class="nf">Concat</span><span class="p">(</span><span class="n">packageTail</span><span class="p">).</span><span class="nf">ToList</span><span class="p">());</span>
</code></pre></div></div> <p>Precisamos criar uma estrutura para representar a <em>instru√ß√£o package</em>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageStatement</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">PackageStatement</span><span class="p">(</span><span class="n">PackageName</span> <span class="n">packageName</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">PackageName</span> <span class="p">=</span> <span class="n">packageName</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">PackageName</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Vamos atualizar o analisador <code class="language-plaintext highlighter-rouge">PackageStatement</code> para retornar a estrutura, usando o analisador<code class="language-plaintext highlighter-rouge"> PackageName</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">PackageStatement</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">packageName</span> <span class="k">in</span> <span class="n">PackageName</span>
	<span class="k">from</span> <span class="n">terminator</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
	<span class="k">select</span> <span class="n">packageName</span><span class="p">;</span>
</code></pre></div></div> <p>Execute todos os testes e voc√™ descobrir√° que tudo est√° funcionando como deveria. Esta refatora√ß√£o foi confirmada sob a tag <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser/tree/Refactor_PackageName" target="_blank" rel="noopener noreferrer">Refactor_PackageName</a>.</p> <h1 id="analisando-mais-estruturas">Analisando mais estruturas</h1> <p>Vamos voltar √† cria√ß√£o de novos analisadores. A pr√≥xima estrutura natural √© uma declara√ß√£o de importa√ß√£o que tem o seguinte BNF:</p> <h2 id="declara√ß√£o-de-importa√ß√£o">Declara√ß√£o de importa√ß√£o</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IMPORT = "import", PACKAGE_NAME, ";";
</code></pre></div></div> <p>Vamos come√ßar atualizando nossa classe <code class="language-plaintext highlighter-rouge">Import</code> anterior. Mude seu nome de <code class="language-plaintext highlighter-rouge">Import</code> para <code class="language-plaintext highlighter-rouge">ImportStatement</code>, que √© mais exato. <strong>Use sua ferramenta de refatora√ß√£o IDE para renomear a classe.</strong> Eu tamb√©m criei um construtor para ela que inicializa o <code class="language-plaintext highlighter-rouge">PackageName</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ImportStatement</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">ImportStatement</span><span class="p">(</span><span class="n">PackageName</span> <span class="n">packageName</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">PackageName</span> <span class="p">=</span> <span class="n">packageName</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">PackageName</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Agora, vamos criar um teste para isso:</p> <blockquote> <p>üòé Estou criando um arquivo de teste para cada analisador, embora eles (atualmente) sejam todos parte da mesma classe. Isso n√£o √© <em>padr√£o</em>; √© a melhor pr√°tica ter uma classe de teste de unidade <em>por classe</em>. Entretanto, fazer dessa forma torna mais f√°cil localizar os testes e nos permite mant√™-los mais organizados.</p> </blockquote> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ImportStatementParserTests</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
	<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"import android.annotation.TargetApi;"</span><span class="p">)]</span>
	<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"import android.app.Activity;"</span><span class="p">)]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackageName_ReturnsStructureWithCorrectName</span><span class="p">(</span><span class="kt">string</span> <span class="n">importStatement</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">ImportStatement</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">importStatement</span><span class="p">);</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">packageName</span><span class="p">,</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">PackageName</span><span class="p">.</span><span class="n">Identifiers</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Usamos as primeiras instru√ß√µes de <code class="language-plaintext highlighter-rouge">import</code> de <code class="language-plaintext highlighter-rouge">AuthenticatorActivity</code>, como voc√™ pode ver. Tamb√©m estamos fazendo um <code class="language-plaintext highlighter-rouge">join</code> dos identificadores assim como fizemos da √∫ltima vez, o que √© um pouco tedioso; vamos melhorar isso na etapa de <em>refatorar</em>.</p> <p>A execu√ß√£o desse teste levar√° a üî¥, pois o c√≥digo n√£o foi implementado. Vamos escrever o analisador agora:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">ImportStatement</span><span class="p">&gt;</span> <span class="n">ImportStatement</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">importKeyword</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"import"</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">packageName</span> <span class="k">in</span> <span class="n">PackageName</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">ImportStatement</span><span class="p">(</span><span class="n">packageName</span><span class="p">);</span>
</code></pre></div></div> <p>Leitores √°vidos notar√£o o m√©todo anteriormente n√£o visto <code class="language-plaintext highlighter-rouge">Token()</code> na segunda linha. Este √© um dos m√©todos mais √∫teis no Sprache - remover√° os espa√ßos em branco ao redor do caractere, mas * exigir√° * que ele esteja l√°. Isso significa que, por exemplo, <code class="language-plaintext highlighter-rouge">Parse.String("import").Token().Parse(" import ")</code> funcionar√°, mas <code class="language-plaintext highlighter-rouge">Parse.String("import").Token().Parse(" importasd ")</code> n√£o.</p> <p>O resto deve ser muito leg√≠vel - procure a palavra-chave <code class="language-plaintext highlighter-rouge">import</code>, depois uma estrutura PackageName e retorne uma instru√ß√£o import. <strong>Execute todos os testes.</strong> Voc√™ deve obter um üü¢.</p> <p>Continuando, vamos refatorar um pouco. Lembra que eu disse que far√≠amos algo sobre <code class="language-plaintext highlighter-rouge">string.Join('.', actual.PackageName.Identifiers)</code>? Agora √© a hora!</p> <p>A representa√ß√£o de string de um nome de pacote, digamos, ‚Äúandroid.content.ActivityNotFoundException‚Äù n√£o √© outro sen√£o ‚Äúandroid.content.ActivityNotFoundException‚Äù. Ent√£o, o que voc√™ acha de substituir <code class="language-plaintext highlighter-rouge">PackageName.ToString</code> para cumprir esse comportamento?</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageName</span>
<span class="p">{</span>
	<span class="c1">// ...</span>

	<span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span> <span class="n">Identifiers</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>üòé <strong>DICA:</strong> Ao realizer um <code class="language-plaintext highlighter-rouge">override</code> em m√©todos e propriedades, use o xml doc <code class="language-plaintext highlighter-rouge">/// &lt;inheritdoc /&gt;</code> como documenta√ß√£o.</p> </blockquote> <p>Agora, seguindo a mesma ideia, podemos adicionar uma substitui√ß√£o de <code class="language-plaintext highlighter-rouge">ToString</code> em <code class="language-plaintext highlighter-rouge">ImportStatement</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ImportStatement</span>
<span class="p">{</span>
	<span class="c1">// ...</span>

	<span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="s">$"import </span><span class="p">{</span><span class="n">PackageName</span><span class="p">}</span><span class="s">;"</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Agora podemos atualizar nosso teste de unidade para refletir este refator:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"import android.annotation.TargetApi;"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"import android.app.Activity;"</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackageName_ReturnsStructureWithCorrectName</span><span class="p">(</span><span class="kt">string</span> <span class="n">importStatement</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">ImportStatement</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">importStatement</span><span class="p">);</span>

	<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">importStatement</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="nf">ToString</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>‚ö† <strong>Aviso</strong>: neste caso, a entrada √© formatada exatamente como a sa√≠da de <code class="language-plaintext highlighter-rouge">ImportStatement.ToString</code>. No entanto, se voc√™ analisar algo como <code class="language-plaintext highlighter-rouge">" import name.surname"</code>, enquanto a an√°lise funcionar√°, o <code class="language-plaintext highlighter-rouge">ToString</code> retornar√° <code class="language-plaintext highlighter-rouge">"import name.surname"</code>, sem espa√ßos. Isso significa que a regra <code class="language-plaintext highlighter-rouge">Token ()</code> n√£o est√° sendo testada em nossa su√≠te - a raz√£o para isso √© que ela n√£o aparece em nosso escopo - portanto, os testes s√£o um pouco fr√°geis e devem ser melhorados na maioria das circunst√¢ncias. N√£o vou fazer isso durante esses exerc√≠cios, mas os leitores devem definitivamente faz√™-lo.</p> </blockquote> <p>Agora, precisamos ler um bloco de importa√ß√µes em nosso arquivo. Chamamos isso de IMPORT_LIST no eBNF. A estrutura de dados para isso n√£o precisa ser mais do que <code class="language-plaintext highlighter-rouge">List &lt;ImportStatement&gt;</code>, mas precisamos de um analisador para isso. Comece com um teste:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ImportListParserTests</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">[</span><span class="k">]&gt;</span> <span class="nf">ImportLists</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">string</span><span class="p">[]</span>
		<span class="p">{</span>
			<span class="s">@"
import com.google.android.apps.authenticator.util.EmptySpaceClickableDragSortListView;
import com.google.android.apps.authenticator.util.annotations.FixWhenMinSdkVersion;
import com.google.android.apps.authenticator2.R;
import com.google.common.annotations.VisibleForTesting;
			"</span><span class="p">.</span><span class="nf">Trim</span><span class="p">(),</span>
		<span class="p">};</span>

		<span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">string</span><span class="p">[]</span>
		<span class="p">{</span>
			<span class="s">@"
import android.support.v7.widget.Toolbar;
import android.text.Html;
import android.util.Log;
import android.view.ActionMode;
import android.view.ContextMenu;
			"</span><span class="p">.</span><span class="nf">Trim</span><span class="p">(),</span>
		<span class="p">};</span>
	<span class="p">}</span>

	<span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
	<span class="p">[</span><span class="nf">MemberData</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">ImportLists</span><span class="p">))]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackageName_ReturnsStructureWithCorrectName</span><span class="p">(</span><span class="kt">string</span> <span class="n">importList</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">expected</span> <span class="p">=</span> <span class="n">importList</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">).</span><span class="nf">ToList</span><span class="p">();</span>
		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">ImportList</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">importList</span><span class="p">);</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span> <span class="n">_</span><span class="p">.</span><span class="nf">ToString</span><span class="p">()));</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>A implementa√ß√£o da lista √© simples:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">ImportStatement</span><span class="p">&gt;&gt;</span> <span class="n">ImportList</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">statements</span> <span class="k">in</span> <span class="n">ImportStatement</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">select</span> <span class="n">statements</span><span class="p">.</span><span class="nf">ToList</span><span class="p">();</span>
</code></pre></div></div> <p>Agora que as importa√ß√µes foram tratadas, vamos passar para a pr√≥xima estrutura de c√≥digo em <code class="language-plaintext highlighter-rouge">AuthenticatorActivity.java</code>, uma <em>anota√ß√£o</em>.</p> <h2 id="anota√ß√µes">Anota√ß√µes</h2> <p>A pr√≥xima estrutura de c√≥digo em <code class="language-plaintext highlighter-rouge">AuthenticatorActivity</code> √© a declara√ß√£o da classe. Ele cont√©m um trecho de c√≥digo sobre o qual n√£o falamos antes, uma anota√ß√£o.</p> <p>As anota√ß√µes Java s√£o an√°logas aos atributos C# e t√™m a seguinte apar√™ncia:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FixWhenMinSdkVersion</span><span class="o">(</span><span class="mi">11</span><span class="o">)</span>
</code></pre></div></div> <p>Assim como no C#, essas estruturas s√≥ podem aparecer antes das declara√ß√µes e, neste caso, √© uma declara√ß√£o de classe. Precisamos criar a estrutura de dados para acomodar isso e o analisador para produzi-la.</p> <p>Conforme mencionado anteriormente, estamos construindo interativamente o eBNF. Isso √© para tornar nosso analisador mais simples - apenas escrever o c√≥digo necess√°rio para as estruturas que est√£o presentes no c√≥digo-fonte. √â por isso que a anota√ß√£o n√£o foi mencionada antes. Vamos atualiz√°-lo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ANNOTATION = "@", IDENTIFIER, "(", ARGUMENT_LIST, ")"

ARGUMENT_LIST = ARGUMENT, { "," ARGUMENT }

ARGUMENT = LITERAL

LITERAL = INTEGER_LITERAL
</code></pre></div></div> <p><strong>O eBNF acima √© parcial</strong>; Por exemplo, a lista de argumentos para a anota√ß√£o √© mais complexa, permitindo outros tipos. Mas at√© agora s√≥ temos o par√¢metro inteiro, ent√£o vamos nos ater a ele.</p> <p>A primeira coisa √© definir a estrutura de dados de uma anota√ß√£o. Olhando para ele, voc√™ pode imaginar que tem um identificador como nome e, em seguida, a lista de argumentos.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">interface</span> <span class="nc">ILiteral</span>
<span class="p">{</span>
	<span class="kt">object</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">IntegerLiteral</span>  <span class="p">:</span> <span class="n">ILiteral</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">IntegerLiteral</span><span class="p">(</span><span class="kt">int</span> <span class="k">value</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="n">Value</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> 

	<span class="kt">object</span> <span class="n">ILiteral</span><span class="p">.</span><span class="n">Value</span> <span class="p">=&gt;</span> <span class="n">Value</span><span class="p">;</span>

	<span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">Value</span><span class="p">.</span><span class="nf">ToString</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Annotation</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">Annotation</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ILiteral</span><span class="p">&gt;</span> <span class="n">arguments</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Name</span> <span class="p">=</span> <span class="n">name</span><span class="p">;</span>
		<span class="n">Arguments</span> <span class="p">=</span> <span class="n">arguments</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

	<span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Argument</span><span class="p">&gt;</span> <span class="n">Arguments</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

	<span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="s">$"@</span><span class="p">{</span><span class="n">Name</span><span class="p">}</span><span class="s">(</span><span class="p">{</span><span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="s">", "</span><span class="p">,</span> <span class="n">Arguments</span><span class="p">)}</span><span class="s">)"</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Introduzimos um pouco de abstra√ß√£o que pode nos poupar algum trabalho mais tarde - deixamos claro que literal pode ser muitas coisas, n√£o apenas inteiros. A convers√£o para a estrutura correta permitir√° que os usu√°rios obtenham o valor digitado - caso contr√°rio, por enquanto, encaixaremos o int e o retornamos como um objeto.</p> <p>Precisamos criar um analisador para essa nova estrutura - um literal inteiro.</p> <p>Testes:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">IntergerLiteralParserTests</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
	<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="m">11</span><span class="p">)]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">MyTheory</span><span class="p">(</span><span class="kt">int</span> <span class="k">value</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">IntegerLiteral</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="k">value</span><span class="p">.</span><span class="nf">ToString</span><span class="p">());</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="k">value</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>E o analisador:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">IntegerLiteral</span><span class="p">&gt;</span> <span class="n">IntegerLiteral</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">digits</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="n">Digit</span><span class="p">.</span><span class="nf">AtLeastOnce</span><span class="p">()</span>
	<span class="k">let</span> <span class="n">number</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Concat</span><span class="p">(</span><span class="n">digits</span><span class="p">)</span>
	<span class="k">let</span> <span class="k">value</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">IntegerLiteral</span><span class="p">(</span><span class="k">value</span><span class="p">);</span>
</code></pre></div></div> <p>Uma coisa no c√≥digo acima que pode fazer voc√™ se perguntar √© o <code class="language-plaintext highlighter-rouge">AtLeastOnce()</code>. Isso √© muito pr√≥ximo de <code class="language-plaintext highlighter-rouge">Many()</code>, com a diferen√ßa de que ir√° falhar na an√°lise quando n√£o houver pelo menos um √∫nico d√≠gito. Se n√£o aplicarmos isso aqui, o analisador aceitar√° uma lista de argumentos vazia.</p> <p>Agora vamos para a anota√ß√£o real.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">AnnotationParserTests</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
	<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"@Number(11)"</span><span class="p">,</span> <span class="k">new</span> <span class="kt">object</span><span class="p">[]</span> <span class="p">{</span> <span class="m">11</span> <span class="p">})]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenAnnotationHasParameters_CorrectParameters</span><span class="p">(</span><span class="kt">string</span> <span class="n">annotation</span><span class="p">,</span> <span class="kt">object</span><span class="p">[]</span> <span class="n">parameters</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">Annotation</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">annotation</span><span class="p">);</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Arguments</span><span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;().</span><span class="nf">ToArray</span><span class="p">());</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>‚ùó Esses testes s√£o muito b√°sicos; na maioria dos cen√°rios de produ√ß√£o, sugiro escrever testes que tenham mais condi√ß√µes; por exemplo, poder√≠amos testar casos como <code class="language-plaintext highlighter-rouge">@ SomeAnnotation</code>, dividindo o c√≥digo em duas linhas, etc. Observe o c√≥digo que est√° sendo testado para encontrar lacunas ou riscos e crie os testes correspondentes. Finalmente, com TDD devemos escrever um teste por vez e evoluir iterativamente.</p> <p>A raz√£o pela qual podemos nos safar com testes t√£o simples √© que sabemos com anteced√™ncia todo o c√≥digo que precisa ser analisado, ent√£o podemos testar novamente um caso real e verificar se surgem bugs, mas mesmo assim, eu teria cuidado onde isso n√£o apenas uma postagem no blog.</p> </blockquote> <p>A implementa√ß√£o ir√° alavancar o analisador <code class="language-plaintext highlighter-rouge">IntegerLiteral</code> que acabamos de codificar:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">Annotation</span><span class="p">&gt;</span> <span class="n">Annotation</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">at</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'@'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">Identifier</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">startList</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'('</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">literal</span> <span class="k">in</span> <span class="n">IntegerLiteral</span><span class="p">.</span><span class="nf">Token</span><span class="p">().</span><span class="nf">Optional</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">endList</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">')'</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">let</span> <span class="n">arguments</span> <span class="p">=</span> <span class="n">literal</span><span class="p">.</span><span class="n">IsDefined</span>
		<span class="p">?</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ILiteral</span><span class="p">&gt;</span> <span class="p">{</span> <span class="n">literal</span><span class="p">.</span><span class="nf">Get</span><span class="p">()</span> <span class="p">}</span>
		<span class="p">:</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ILiteral</span><span class="p">&gt;()</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">Annotation</span><span class="p">(</span><span class="n">identifier</span><span class="p">,</span> <span class="n">arguments</span><span class="p">);</span>
</code></pre></div></div> <p>Novamente, podemos ver um analisador opcional sendo chamado. Para obter a lista real, precisamos fazer alguma gin√°stica LINQ - retornar uma lista com um √∫nico literal ou uma lista vazia. No futuro, provavelmente criaremos um analisador <code class="language-plaintext highlighter-rouge">ArgumentList</code> que deve substituir isso, mas at√© agora, n√£o h√° necessidade.</p> <p>Os testes devem ser üü¢.</p> <h2 id="declara√ß√£o-de-classe">Declara√ß√£o de classe</h2> <p>A pr√≥xima coisa no arquivo √© a defini√ß√£o real da classe. Vamos decomp√¥-lo:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FixWhenMinSdkVersion</span> <span class="o">(</span><span class="mi">11</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AuthenticatorActivity</span> <span class="n">estende</span> <span class="nc">TestableActivity</span> <span class="o">{</span>
<span class="c1">// ...</span>
</code></pre></div></div> <p>Este √© um bom exemplo porque, de cara, lidaremos com <code class="language-plaintext highlighter-rouge">extends</code>, um caso comum, mas n√£o basal. A anota√ß√£o j√° foi cuidada, ent√£o vamos analisar a declara√ß√£o da classe:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>visibility
   ‚îÇ
   ‚îÇ          identifier, class          identifier, base class
   ‚îÇ                   ‚îÇ                          ‚îÇ
‚îå‚îÄ‚îÄ‚î¥‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
public class AuthenticatorActivity extends TestableActivity 
       ‚îî‚îÄ‚î¨‚îÄ‚îò                       ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò
         ‚îÇ             interface inheritance keyword
         ‚îÇ
class declaration keyword
</code></pre></div></div> <p>Portanto, precisamos expandir o EBNF:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CLASS_DECLARATION = VISIBILITY, "class", IDENTIFIER, { "extends", IDENTIFIER }, "{", (* ommited *), "}";

VISIBILITY = "public" 
</code></pre></div></div> <blockquote> <p>‚ùó N√£o estamos lidando com outras visibilidades apenas no momento, a n√£o ser para refletir nossa abordagem em evolu√ß√£o. √Ä medida que lidamos com mais casos, expandimos a defini√ß√£o.</p> </blockquote> <p>Isso deve ser realmente simples, mas precisamos atualizar a estrutura da classe para refleti-la:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">enum</span> <span class="n">Visibility</span>
<span class="p">{</span>
	<span class="n">Public</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">ClassDefinition</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">ClassDefinition</span><span class="p">(</span><span class="n">Visibility</span> <span class="n">visibility</span><span class="p">,</span> <span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">string</span><span class="p">?</span> <span class="n">baseClass</span> <span class="p">=</span> <span class="k">null</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">?</span> <span class="n">annotation</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Visibility</span> <span class="p">=</span> <span class="n">visibility</span><span class="p">;</span>
		<span class="n">Name</span> <span class="p">=</span> <span class="n">name</span><span class="p">;</span>
		<span class="n">BaseClass</span> <span class="p">=</span> <span class="n">baseClass</span><span class="p">;</span>
		<span class="n">Annotation</span> <span class="p">=</span> <span class="n">annotation</span><span class="p">;</span>
	<span class="p">}</span>

		<span class="k">public</span> <span class="n">Visibility</span> <span class="n">Visibility</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

		<span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

		<span class="k">public</span> <span class="kt">string</span><span class="p">?</span> <span class="n">BaseClass</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

		<span class="k">public</span> <span class="n">Annotation</span><span class="p">?</span> <span class="n">Annotation</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Algumas coisas a serem observadas: estamos seguindo estritamente o trecho de c√≥digo que est√° sendo processado, ent√£o, embora haja um membro Visibility, o √∫nico valor poss√≠vel √© <code class="language-plaintext highlighter-rouge">Public</code>; embora Java permita v√°rias anota√ß√µes, estamos apenas considerando uma √∫nica anota√ß√£o etc. O motivo pelo qual estou seguindo essa abordagem √© que ainda n√£o sabemos se esses casos surgir√£o dentro do c√≥digo. Se o fizerem, iremos reescrever o c√≥digo acima.</p> <p>Agora vamos criar nossos testes:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ClassDefinitionParserTests</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_AnnotatedClassWithExtends_CorrectParameters</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">code</span> <span class="p">=</span> <span class="s">@"
@FixWhenMinSdkVersion(11)
public class AuthenticatorActivity extends TestableActivity
"</span><span class="p">.</span><span class="nf">Trim</span><span class="p">();</span>

		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">ClassDefinition</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">"FixWhenMinSdkVersion"</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Annotation</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="m">11</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Annotation</span><span class="p">.</span><span class="n">Arguments</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">Value</span><span class="p">);</span>
		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">Visibility</span><span class="p">.</span><span class="n">Public</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Visibility</span><span class="p">);</span>
		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">"AuthenticatorActivity"</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">"TestableActivity"</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">BaseClass</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Novamente, os testes lidam apenas com o que vimos at√© agora. Usei um <code class="language-plaintext highlighter-rouge">Fact</code> em vez de uma <code class="language-plaintext highlighter-rouge">Theory</code> porque estamos lidando apenas com um √∫nico caso. Assim que tivermos mais casos para testar, vou convert√™-lo em <code class="language-plaintext highlighter-rouge">Theory</code>.</p> <p>Ah! Estou testando o resultado da an√°lise de anota√ß√£o, que na verdade est√° repetindo os testes j√° feitos no <code class="language-plaintext highlighter-rouge">AnnotationParserTests</code>. Poder√≠amos fazer isso de forma um pouco diferente e apenas ter certeza de que o analisador correto foi chamado, mas por enquanto, vamos manter isso simples e repetir o teste.</p> <p>Agora, a implementa√ß√£o, embora longa, √© simples, apenas analise cada fragmento que vimos na an√°lise acima:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">ClassDefinition</span><span class="p">&gt;</span> <span class="n">ClassDefinition</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">annotation</span> <span class="k">in</span> <span class="n">Annotation</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">visibility</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"public"</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">classKeyword</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"class"</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">className</span> <span class="k">in</span> <span class="n">Identifier</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">extendsKeyword</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"extends"</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">baseClassName</span> <span class="k">in</span> <span class="n">Identifier</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">ClassDefinition</span><span class="p">(</span><span class="n">Visibility</span><span class="p">.</span><span class="n">Public</span><span class="p">,</span> <span class="n">className</span><span class="p">,</span> <span class="n">baseClassName</span><span class="p">,</span> <span class="n">annotation</span><span class="p">);</span>
</code></pre></div></div> <p>Eu cortei alguns cantos aqui, como analisar a visibilidade diretamente. Tamb√©m lidaremos com isso quando for necess√°rio.</p> <p>Fa√ßa seus testes e aprecie seu üü¢.</p> <h1 id="resumo">Resumo</h1> <p>Com este artigo, conclu√≠mos a primeira etapa: podemos analisar todos os elementos de n√≠vel superior de um arquivo de origem Java. Voc√™ aprendeu um pouco mais sobre como usar Sprache e combinar analisadores e provavelmente aprendeu algumas t√©cnicas sobre como criar c√≥digo <em>apto para o prop√≥sito</em>, usando uma abordagem orientada a testes e evoluindo o c√≥digo anterior √† medida que avan√ßamos em nosso entendimento do dom√≠nio do problema, um processo denominado ** descoberta **.</p> <p>Todo o c√≥digo produzido at√© agora foi armazenado em <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser" target="_blank" rel="noopener noreferrer">Github</a>. Voc√™ pode fazer um fork e us√°-lo da maneira que quiser. Para obter a vers√£o exata deste c√≥digo, use <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser/releases/tag/SecondArticle" target="_blank" rel="noopener noreferrer">esta tag</a>.</p> <p>No pr√≥ximo artigo, come√ßaremos a analisar elementos de classe como construtores, campos e m√©todos. Estaremos ainda mais focados, lidando apenas com as estruturas de c√≥digo que aparecem no c√≥digo e, com sorte, poderemos terminar de analisar nossa primeira classe.</p> <p>Vejo voc√™ na pr√≥xima vez!</p> <div style="text-align: right;"> <!-- TODO: create style --> <a href="/pt/parsing-code-with-sprache-part-2/" style="font-size: 75%; font-style: italic;">Continuar lendo ‚Üí</a> </div> <br> <div class="tag-list"> <a href="/pt/tags/#dotnet">#dotnet</a> ¬† <a href="/pt/tags/#programa%C3%A7%C3%A3o">#programa√ß√£o</a> ¬† <a href="/pt/tags/#linguagem">#linguagem</a> ¬† <a href="/pt/tags/#sprache">#sprache</a> ¬† <a href="/pt/tags/#tdd">#tdd</a> </div> </article> <article class="post"> <h1 class="post-title"> <a href="/pt/read-my-blog-in-portuguese/">Leia meu blog em portugu√™s ou ingl√™s!</a> </h1> <time datetime="2021-02-17T00:00:00+00:00" class="post-date"> 17th February 2021 em <a href="/pt/categories/#An%C3%BAncios">An√∫ncios</a> </time> <!-- <span class="permalink"> </span> --> <!-- using excerpts: https://jekyllrb.com/docs/posts/#post-excerpts --> <p>Depois de algum esfor√ßo, consegui permitir que meu blog ficasse multil√≠ngual. Agora todos os posts est√£o em portugu√™s ou ingles. Leitores detalhistas j√° ter√£o notado os √≠cones que permitem selecionar a l√≠ngua:</p> <div style="text-align: right;"> <!-- TODO: create style --> <a href="/pt/read-my-blog-in-portuguese/" style="font-size: 75%; font-style: italic;">Continuar lendo ‚Üí</a> </div> <br> <div class="tag-list"> <a href="/pt/tags/#meta">#meta</a> </div> </article> <article class="post"> <h1 class="post-title"> <a href="/pt/parsing-code-with-sprache/">Analisando c√≥digo com Sprache - Parte 1</a> </h1> <time datetime="2021-02-13T10:00:00+00:00" class="post-date"> 13th February 2021 em <a href="/pt/categories/#Desenvolvimento">Desenvolvimento</a> </time> <!-- <span class="permalink"> </span> --> <!-- using excerpts: https://jekyllrb.com/docs/posts/#post-excerpts --> <p>Voc√™ provavelmente sabe que √†s vezes (<em>muitas</em> vezes), o trabalho de um desenvolvedor √© muito mais pesquisa ou an√°lise do que programa√ß√£o! No passado, houve muitos casos em que eu estava em um projeto em que meu objetivo era migrar ou reescrever software antigo e, durante esses compromissos, acabei criando ferramentas para me ajudar. Muitas dessas ferramentas eram analisadores de c√≥digo especializados que realizavam automaticamente a an√°lise que eu exigia ou at√© mesmo geravam c√≥digos mais novos que eu poderia utilizar.</p> <p>Em todos esses casos, precisei analisar algum c√≥digo estruturado e h√° uma maneira simples de fazer isso: usando <a href="https://github.com/sprache/Sprache" target="_blank" rel="noopener noreferrer">Sprache</a>, um framework de parsing para dotnet. Neste artigo, vamos ver como fazer isso.</p> <h1 id="analisando-c√≥digo-java">Analisando c√≥digo Java</h1> <p>Voc√™ pode escrever todos os tipos de analisadores com Sprache. Contanto que a linguagem seja formal, √© f√°cil construir o c√≥digo necess√°rio, e voc√™ faz isso aproveitando todas as maravilhas da sintaxe C#. Vou propor um exemplo: um analisador para uma gram√°tica <strong>parcial</strong> Java ‚òï.</p> <p>Estou escolhendo Java porque √© complexo o suficiente para nos permitir ver como o Sprache pode tornar sua vida mais f√°cil; tab√©m por que o Java est√° pr√≥ximo do C#, ent√£o os leitores entender√£o rapidamente a maior parte dele; e porque a gram√°tica formal do Java √© estruturada de tal forma que √© poss√≠vel extrapolar sua gram√°tica sem muita pesquisa.</p> <p>Obviamente, escrever um analisador completo demoraria muito; teremos que nos limitar a um analisador parcial. A maneira como fazemos isso √© obter o c√≥digo que queremos analisar e, em seguida, especificar a gram√°tica exatamente para isso (eu chamo essa abordagem de <em>best fit</em>, importante princ√≠pio √°gil). Ent√£o, escolhi uma v√≠tima para este esfor√ßo: <a href="https://github.com/google/google-authenticator-android/tree/master/java/com/google/android/apps/authenticator" target="_blank" rel="noopener noreferrer">Google Authenticator</a> √© a fonte de um aplicativo Android que gera OTP‚Äôs. O aplicativo pode ser encontrado na <a href="https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&amp;hl=en_US&amp;gl=US" target="_blank" rel="noopener noreferrer">Play Store</a>.</p> <blockquote> <p>üòé Eu j√° ysei este c√≥digo-fonte como base para reproduzir o algoritmo de OTP, ent√£o estou familiarizado com ele.</p> </blockquote> <p>Para ter um objetivo tang√≠vel, iremos gerar um gr√°fico de depend√™ncias entre classes do c√≥digo; Isso deve ajud√°-lo a saber como fazer mais do que apenas a an√°lise, mas tamb√©m como usar o c√≥digo analisado para obter insights ou produzir outros artefatos.</p> <h1 id="java-bnf">Java BNF</h1> <p>O ponto de partida para nosso c√≥digo √© a gram√°tica formal do Java. O <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form" target="_blank" rel="noopener noreferrer">eBNF</a> - Nota√ß√£o ou Forma Backus-Naur Estendida - √© uma descri√ß√£o de uma gram√°tica formal. Por exemplo, um bloco <code class="language-plaintext highlighter-rouge">for</code> em Java pode ser:</p> <p>Exemplo:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span> <span class="o">}</span>
</code></pre></div></div> <p>Gram√°tica:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FORBLOCK = "for" "(" INITIALIZER ";" CONDITION ";" INCREMENT) BLOCK

INITIALIZER = ASSIGNMENT

ASSIGNMENT = TYPE VARIABLE "=" LITERAL 

CONDITION = BOOLEAN_EXPRESSION

INCREMENT = VARIABLE "++" | "++" VARIABLE

BLOCK = STATEMENT | "{" STATEMENT_LIST "}"
</code></pre></div></div> <blockquote> <p>‚ùó Esta gram√°tica est√° incompleta e n√£o necessariamente correta; Este √© um guia pr√°tico sobre como usar o Sprache, n√£o sobre BNF e linguagens formais.</p> </blockquote> <p>Portanto, come√ßamos observando nosso c√≥digo-alvo e criando uma pequena gram√°tica. Para manter as coisas simples, iremos escrever analisadores para cada fonte em <code class="language-plaintext highlighter-rouge">java/com/google/android/apps/authenticator/</code> e ignorar os arquivos n√£o-java.</p> <p>Por exemplo, d√™ uma olhada em <a href="https://github.com/google/google-authenticator-android/blob/master/java/com/google/android/apps/authenticator/AuthenticatorActivity.java" target="_blank" rel="noopener noreferrer">AuthenticatorActivity.java</a>, o primeiro arquivo no escopo. Voc√™ ver√° que as primeiras linhas s√£o coment√°rios e ent√£o temos uma instru√ß√£o <code class="language-plaintext highlighter-rouge">package</code>, seguida por v√°rias instru√ß√µes <code class="language-plaintext highlighter-rouge">import</code> e, finalmente, uma defini√ß√£o de <code class="language-plaintext highlighter-rouge">class</code>. Excluindo os coment√°rios (abordaremos isso mais tarde), a gram√°tica seria:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>JAVA_FILE = PACKAGE, IMPORT_LIST, CLASS_DECLARATIONS;

PACKAGE = "pacote", PACKAGE_NAME, ";";

PACKAGE_NAME = WORD, {"." PALAVRA };

WORD = CHARACTER, {CHARACTER};

CHARACTER = LETTER | DIGIT;

IMPORT_LIST = IMPORT, {IMPORT};

IMPORT = "importar", PACKAGE_NAME, ";";

CLASS_DECLARATION = "public", "class", WORD, "{" (*omitido*) "}";
</code></pre></div></div> <p>D√™ uma olhada nessa linguagem, compare-a com o arquivo, mas cheque-a contra seu conhecimento de Java (ou C#, apenas percebendo que essas duas linguagens s√£o muito semelhantes). Por um lado, voc√™ provavelmente ver√° que a gram√°tica acima pode ser usada para produzir o c√≥digo-fonte; por outro, voc√™ perceber√° rapidamente que ele n√£o leva em considera√ß√£o muitas constru√ß√µes que s√£o legais em Java: por exemplo, uma fonte pode n√£o ter <code class="language-plaintext highlighter-rouge">import</code>s quaisquer. Isso √© o que quero dizer com * melhor ajuste * - estamos procurando uma maneira de analisar <strong>apenas</strong> o c√≥digo no escopo.</p> <h1 id="configurando-o-projeto">Configurando o projeto</h1> <p>Assim que tivermos uma pequena gram√°tica, podemos come√ßar a codificar. Crie um novo projeto de biblioteca dotnet, adicione Sprache a ele via Nuget, crie um projeto de teste adicional com xUnit e baixe o c√≥digo-fonte do Google Authenticator paraum diret√≥rio.</p> <p>Definiremos estruturas de dados para armazenar cada elemento de nossa gram√°tica e um teste para verificar se a an√°lise funcionou conforme o esperado.</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// BNF classes</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">JavaFile</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Package</span> <span class="n">Package</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Import</span><span class="p">&gt;</span> <span class="n">ImportList</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="n">ClassDefinition</span> <span class="n">ClassDefinition</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Package</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">PackageName</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">PackageName</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">PackageName</span><span class="p">()</span> <span class="p">{}</span>

	<span class="k">public</span> <span class="nf">PackageName</span><span class="p">(</span><span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">identifers</span><span class="p">)</span> 
	<span class="p">{</span> 
		<span class="n">Identifiers</span> <span class="p">=</span> <span class="n">identifers</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">Identifiers</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Import</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">PackageName</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">ClassDefinition</span>
<span class="p">{</span>
    <span class="c1">// OMMITED</span>
<span class="p">}</span>
</code></pre></div></div> <p>Algumas coisas importantes a serem observadas na estrutura acima:</p> <ul> <li>Eu n√£o defini ImportList ou qualquer estrutura de lista - eu simplesmente usei o <code class="language-plaintext highlighter-rouge">List</code> gen√©rico do C#.</li> <li>Eu n√£o defini uma constru√ß√£o de WORD ainda - irei armazen√°-las simplesmente como strings por enquanto, j√° que n√£o estamos interessados ‚Äã‚Äãnela.</li> </ul> <p>Agora, como se parece um <em>parser</em>? Precisamos de algo que possa obter os dados da fonte - texto, afinal - e produzir as estruturas acima:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">interface</span> <span class="nc">IParser</span> <span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="nf">Parse</span> <span class="p">(</span><span class="n">c</span><span class="err">√≥</span><span class="n">digo</span> <span class="n">de</span> <span class="kt">string</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Este √© um analisador b√°sico para uma determinada defini√ß√£o <code class="language-plaintext highlighter-rouge">T</code> - √© apenas um √∫nico m√©todo que l√™ uma string e retorna a estrutura desejada. Come√ßaremos declarando um dos analisadores b√°sicos, o analisador <code class="language-plaintext highlighter-rouge">Package</code>. <em>Revisitaremos essas estrutura com o tempo.</em></p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageNameParser</span> <span class="p">:</span> <span class="n">IParser</span><span class="p">&lt;</span><span class="n">Package</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Package</span> <span class="nf">Parse</span><span class="p">(</span><span class="kt">string</span> <span class="n">code</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotImplementedException</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Este ser√° o nosso ponto de partida para o analisador.</p> <p>Com essas classes definidas, podemos passar √† configura√ß√£o dos testes.</p> <h1 id="os-primeiros-testes">Os primeiros testes</h1> <blockquote> <p>üòé Sempre escreva os testes primeiro.</p> </blockquote> <p>Usarei o xUnit, que provavelmente √© o melhor framework de testes para C#. Voc√™ pode adaptar o c√≥digo abaixo para o que quiser.</p> <p>O primeiro caso de teste deve ser um ‚Äúaquecimento‚Äù, ent√£o testamos o que acontece quando o c√≥digo √© <code class="language-plaintext highlighter-rouge">nulo</code>.</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageNameParserTests</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenCodeNull_Throws</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">sut</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">PackageNameParser</span><span class="p">();</span>

        <span class="n">Assert</span><span class="p">.</span><span class="n">Throws</span><span class="p">&lt;</span><span class="n">ArgumentNullException</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="n">sut</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="k">null</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Execute o teste - ele falhar√°, como de costume, em conformidade com uma abordagem <em>red-green-refactor</em>. A pr√≥xima etapa √© deix√°-lo verde:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageNameParser</span> <span class="p">:</span> <span class="n">IParser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">PackageName</span> <span class="nf">Parse</span><span class="p">(</span><span class="kt">string</span> <span class="n">code</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentNullException</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">code</span><span class="p">));</span>

        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotImplementedException</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Execute-o novamente e o teste ser√° aprovado. O aquecimento est√° feito, nosso pr√≥ximo passo √© criar um caminho feliz. Queremos testar se podemos capturar corretamente o nome do pacote:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackage_ReturnsName</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">packageExpresison</span> <span class="p">=</span> <span class="s">"package tinyJavaParser;"</span><span class="p">;</span>

    <span class="kt">var</span> <span class="n">sut</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">PackageNameParser</span><span class="p">();</span>
    
    <span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">sut</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">packageExpresison</span><span class="p">);</span>

    <span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">"tinyJavaParser"</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Indentifiers</span><span class="p">[</span><span class="m">0</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Execute-o e o teste falhar√°. Vamos implementar nosso primeiro analisador Sprache!</p> <h2 id="analisadores-sprache">Analisadores Sprache</h2> <p>Se voc√™ der uma olhada no README do Sprache, saber√° rapidamente como trabalhar com ele. Tudo come√ßa com o objeto <code class="language-plaintext highlighter-rouge">Parse</code> est√°tico, que pode ser chamado para analisar v√°rios tipos de textos. Voc√™ constr√≥i um analisador complexo combinando esses analisadores b√°sicos usando LINQ.</p> <p>Por exemplo, nosso nome de pacote √© uma string feita de chars, ent√£o podemos usar <code class="language-plaintext highlighter-rouge">Sprache.Parse.Letter</code> para analis√°-lo, mas primeiro devemos levar em conta a palavra-chave<code class="language-plaintext highlighter-rouge"> package</code> e espa√ßos que vem antes:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">parser</span> <span class="p">=</span>
    <span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
    <span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
    <span class="k">from</span> <span class="n">packageName</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">Letter</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">()</span>
    <span class="k">from</span> <span class="n">ending</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
    <span class="k">select</span> <span class="k">new</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="n">Indentifiers</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="p">{</span> <span class="n">packageName</span> <span class="p">}</span> <span class="p">};</span>
</code></pre></div></div> <p>Vejamos linha por linha. Em primeiro lugar, consideramos a palavra-chave do pacote, afirmando claramente que ela deve aparecer apenas <strong>uma vez</strong>:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
</code></pre></div></div> <p>Ent√£o sabemos que haver√° alguns espa√ßos entre a palavra-chave e o identificador:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">from</span> <span class="n">space1</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
</code></pre></div></div> <p>Depois disso, extra√≠mos o nome do pacote, que √© uma sequ√™ncia de letras:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">from</span> <span class="n">packageName</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">Letter</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">()</span>
</code></pre></div></div> <p>E, finalmente, certificamo-nos de que a linha termina com um <code class="language-plaintext highlighter-rouge">;</code>:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">from</span> <span class="n">ending</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
</code></pre></div></div> <p>Depois de fazer tudo isso, podemos produzir a estrutura analisada, <code class="language-plaintext highlighter-rouge">PackageName</code>, usando os dados que coletamos antes:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">select</span> <span class="k">new</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="n">Indentifiers</span> <span class="p">=</span> <span class="k">new</span><span class="p">()</span> <span class="p">{</span> <span class="n">packageName</span> <span class="p">}</span> <span class="p">};</span>
</code></pre></div></div> <p>Vamos usar esse conhecimento e implementar o m√©todo:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">PackageName</span> <span class="nf">Parse</span><span class="p">(</span><span class="kt">string</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentNullException</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">code</span><span class="p">));</span>

    <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">parser</span> <span class="p">=</span>
        <span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">packageName</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">Letter</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">ending</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
        <span class="k">select</span> <span class="k">new</span> <span class="nf">PackageName</span><span class="p">(</span><span class="k">new</span><span class="p">()</span> <span class="p">{</span> <span class="n">packageName</span> <span class="p">})</span> <span class="p">};</span>

    <span class="k">return</span> <span class="n">parser</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Execute os testes, voc√™ obter√° üü¢. Agora, antes de passarmos para <em>refatorar</em>, quero melhorar o teste que acabamos de fazer e torn√°-lo mais gen√©rico.</p> <p>O teste considera apenas um nome de pacote com uma √∫nica palavra. Isso n√£o √© suficiente, e talvez voc√™ j√° tenha adivinhado que os identificadores compostos falhar√£o. Adicionaremos alguns outros exemplos, e a melhor fonte para eles √© - voc√™ adivinhou! - o c√≥digo-fonte do Autenticador.</p> <blockquote> <p>Voc√™ pode perceber que tamb√©m n√£o consideramos poss√≠veis identificadores que tenham letras ou s√≠mbolos como sublinhado. Mas, para manter nosso objetivo, n√£o precisamos de um analisador que leia todos os c√≥digos Java v√°lidos j√° escritos, em vez disso, apenas algo que analise o fonte com o qual estamos lidando. Isso pode n√£o ser o caso em outros projetos onde voc√™ precise de um parser - por exemplo, talvez voc√™ n√£o tenha acesso total ao c√≥digo antes de executar o analisador e, nesse caso, voc√™ precisar√° dar um mergulho profundo no defini√ß√£o de linguagem. Da mesma forma, nosso analisador n√£o est√° tentando validar o c√≥digo que est√° consumindo - seja o que for que encontrarmos nesses arquivos, aceitamos que seja Java v√°lido. Novamente, voc√™ pode querer adotar uma abordagem diferente, por exemplo, se este analisador for alimentado com c√≥digo escrito apenas para ele, j√° que ent√£o voc√™ ter√° pessoas cometendo erros e precisar√° dizer a elas quais s√£o.</p> </blockquote> <p>Para encontrar os exemplos de pacotes, usei apenas o VSCode para abrir o diret√≥rio onde o c√≥digo est√°, <code class="language-plaintext highlighter-rouge">java/com/google/android/apps/authenticator/</code>, e abri a ferrament de pesquisa:</p> <p><img src="../../../assets/vscode-search-example.png" alt="Caixa de pesquisa em VSCode"></p> <p>E agora mudamos o teste de <code class="language-plaintext highlighter-rouge">Fact</code> para <code class="language-plaintext highlighter-rouge">Theory</code> usando alguns desses nomes:</p> <blockquote> <p>Eu examinei a lista de pacotes e escolhi aqueles que achei representativos do dom√≠nio do nome. Vamos, depois, analisar tudo, mas √© importante que antes disso j√° tenhamos alguns bons testes em funcionamento.</p> </blockquote> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"tinyJavaParser"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"com.google.android.apps.authenticator"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"com.google.android.apps.authenticator.enroll2sv.wizard"</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackage_ReturnsName</span><span class="p">(</span><span class="kt">string</span> <span class="n">packageName</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">packageExpresison</span> <span class="p">=</span> <span class="s">$"package </span><span class="p">{</span><span class="n">packageName</span><span class="p">}</span><span class="s">;"</span><span class="p">;</span>

    <span class="kt">var</span> <span class="n">sut</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">PackageNameParser</span><span class="p">();</span>

    <span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">sut</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">packageExpresison</span><span class="p">);</span>

    <span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">packageName</span><span class="p">,</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Identifiers</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div> <p>Tome seu tempo para entender as mudan√ßas que fizemos no teste. Lembre-se de que a etapa <em>refatorar</em> se aplica tamb√©m aos testes, portanto, embora possamos <em>poder</em> manter o teste como estava e apenas adicionar uma nova teoria, isso √© mais limpo, ou seja, mais f√°cil de manter.</p> <p>Agora executamos os testes e, claro, üî¥. √â hora de corrigir o c√≥digo.</p> <p>Primeiro, tentamos corrigi-lo para * com.google.android.apps.authenticator *, contabilizando v√°rios identificadores:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">PackageName</span> <span class="nf">Parse</span><span class="p">(</span><span class="kt">string</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentNullException</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">code</span><span class="p">));</span>

    <span class="n">Parser</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">identifierParser</span> <span class="p">=</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">Letter</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">();</span>

    <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">parser</span> <span class="p">=</span>
        <span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">packageHead</span> <span class="k">in</span> <span class="n">identifierParser</span>
        <span class="k">from</span> <span class="n">packageTail</span> <span class="k">in</span> <span class="p">(</span><span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'.'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
                                <span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">identifierParser</span>
                                <span class="k">select</span> <span class="n">identifier</span><span class="p">).</span><span class="nf">Many</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">terminator</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
        <span class="k">select</span> <span class="k">new</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="n">Identifiers</span> <span class="p">=</span> <span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="n">packageHead</span> <span class="p">}).</span><span class="nf">Concat</span><span class="p">(</span><span class="n">packageTail</span><span class="p">).</span><span class="nf">ToList</span><span class="p">()</span> <span class="p">};</span>

    <span class="k">return</span> <span class="n">parser</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Vamos mais uma vez dissecar o c√≥digo.</p> <p>Come√ßamos criando um ‚Äúsub parser‚Äù, por assim dizer, que l√™ um identificador. Deve ser muito simples, pois √© o mesmo c√≥digo que t√≠nhamos antes - pegue o m√°ximo de letras em sequ√™ncia poss√≠vel e converta em ‚Äútexto‚Äù, ou seja, uma <code class="language-plaintext highlighter-rouge">string</code>.</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">identifierParser</span> <span class="p">=</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">Letter</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">();</span>
</code></pre></div></div> <p>Agora incrementamos as regras de an√°lise antigas para contabilizar as repeti√ß√µes de identificadores. Fazemos isso obtendo pelo menos o primeiro identificador e, opcionalmente, muitos outros. <code class="language-plaintext highlighter-rouge">packageTail</code> tamb√©m usa um sub-analisador que eu n√£o declarei, ent√£o √© embutido porque s√≥ faz sentido dentro deste analisador.</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span> <span class="n">packageHead</span> <span class="k">in</span> <span class="n">identifierParser</span>
<span class="k">from</span> <span class="n">packageTail</span> <span class="k">in</span> <span class="p">(</span><span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'.'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
                        <span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">identifierParser</span>
                        <span class="k">select</span> <span class="n">identifier</span><span class="p">).</span><span class="nf">Many</span><span class="p">()</span>
</code></pre></div></div> <p>Finalmente, precisamos criar uma lista a partir do identificador √∫nico <code class="language-plaintext highlighter-rouge">packageHead</code> e os m√∫ltiplos em<code class="language-plaintext highlighter-rouge"> packageTail</code>, ent√£o eu trapacei um pouco:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="k">new</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="n">Identifiers</span> <span class="p">=</span> <span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="n">packageHead</span> <span class="p">}).</span><span class="nf">Concat</span><span class="p">(</span><span class="n">packageTail</span><span class="p">).</span><span class="nf">ToList</span><span class="p">()</span> <span class="p">};</span>
</code></pre></div></div> <p>Eu crio um array apenas com o packageHead (<code class="language-plaintext highlighter-rouge">new [] {packageHead}</code>) e concateno-o wcom <code class="language-plaintext highlighter-rouge">packageTail</code>. Depois disso, eu apenas chamo <code class="language-plaintext highlighter-rouge">ToList()</code> para transformar o array resultante em uma lista.</p> <p>Isso testar√° üü¢ verde para <code class="language-plaintext highlighter-rouge">"com.google.android.apps.authenticator"</code>, mas ainda falhar√° para <code class="language-plaintext highlighter-rouge">"com.google.android.apps.authenticator.enroll2sv.wizard "</code>. Vamos dar uma olhada no erro:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Message: 
    Sprache.ParseException : Parsing failure: unexpected '2'; expected ; (Line 1, Column 53); recently consumed: tor.enroll
</code></pre></div></div> <p>Sprache est√° nos dizendo que h√° um <code class="language-plaintext highlighter-rouge">2</code> que ele n√£o esperava no stream e que acabou de consumir <code class="language-plaintext highlighter-rouge">"tor.enroll"</code>. Se olharmos para a string de entrada, √© f√°cil ver por que ela falha:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                         Apenas leia daqui
                                  ‚Üì
com.google.android.apps.authenticator.enroll2sv.wizard
                                            ‚Üë
                                      Falhou aqui
</code></pre></div></div> <p>Portanto, como esperado, o n√∫mero 2 n√£o √© permitido. Isso √© apenas uma quest√£o de expandir a defini√ß√£o de <code class="language-plaintext highlighter-rouge">identifierParser</code> para levar isso em considera√ß√£o:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">identifierParser</span> <span class="p">=</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">LetterOrDigit</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">();</span>
</code></pre></div></div> <p>Fa√ßa testes e aprecie seu üü¢!</p> <h2 id="refatorar">Refatorar!</h2> <p>Agora √© a hora de refatorar o c√≥digo. Veremos como tornar nosso c√≥digo mais simples de manter e usar.</p> <p>H√° duas coisas que devemos observar:</p> <ul> <li> <p>Em <code class="language-plaintext highlighter-rouge">PackageNameParser.Parse</code>, criamos duas inst√¢ncias de parser, <code class="language-plaintext highlighter-rouge">identifierParser</code> e <code class="language-plaintext highlighter-rouge">parser</code>. Eles s√£o usados ‚Äã‚Äãapenas uma vez, logo no retorno. V√°rias chamadas para este m√©todo resultam na recria√ß√£o dessas inst√¢ncias, mas podem ser reutilizadas. Isso tamb√©m √© evidenciado pelos documentos do Sprache.</p> </li> <li> <p>Definimos uma interface <code class="language-plaintext highlighter-rouge">IParser&lt;T&gt;</code>, e Sprache tem um delegate <code class="language-plaintext highlighter-rouge">Parser&lt;out T&gt;</code>, que √© muito pr√≥ximo ao nosso. O Sprache pode definir analisadores usando seu delegate, e podemos combin√°-los para produzir analisadores novos e mais complexos.</p> </li> </ul> <p>Com esse conhecimento, devemos refatorar nosso c√≥digo para definir uma vez e usar os analisadores v√°rias vezes; Devemos tamb√©m abandonar nossa interface de an√°lise e usar o delegado do Sprache. A maneira de fazer as coisas do Sprache √© definir esses delegados como membros est√°ticos de uma classe, para que possamos criar:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">JavaGrammar</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">Identifier</span> <span class="p">=</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">LetterOrDigit</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">();</span>

	<span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">PackageName</span> <span class="p">=</span>
		<span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
		<span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
		<span class="k">from</span> <span class="n">packageHead</span> <span class="k">in</span> <span class="n">Identifier</span>
		<span class="k">from</span> <span class="n">packageTail</span> <span class="k">in</span> <span class="p">(</span><span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'.'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
								<span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">Identifier</span>
								<span class="k">select</span> <span class="n">identifier</span><span class="p">).</span><span class="nf">Many</span><span class="p">()</span>
		<span class="k">from</span> <span class="n">terminator</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
		<span class="k">select</span> <span class="k">new</span> <span class="nf">PackageName</span><span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="n">packageHead</span> <span class="p">}.</span><span class="nf">Concat</span><span class="p">(</span><span class="n">packageTail</span><span class="p">).</span><span class="nf">ToList</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div> <p>E mudar os testes para refletir isso:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageNameParserTests</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenCodeNull_Throws</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Assert</span><span class="p">.</span><span class="n">Throws</span><span class="p">&lt;</span><span class="n">ArgumentNullException</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">PackageName</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="k">null</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
    <span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"tinyJavaParser"</span><span class="p">)]</span>
    <span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"com.google.android.apps.authenticator"</span><span class="p">)]</span>
    <span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"com.google.android.apps.authenticator.enroll2sv.wizard"</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackage_ReturnsName</span><span class="p">(</span><span class="kt">string</span> <span class="n">packageName</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">packageExpresison</span> <span class="p">=</span> <span class="s">$"package </span><span class="p">{</span><span class="n">packageName</span><span class="p">}</span><span class="s">;"</span><span class="p">;</span>

        <span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">PackageName</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">packageExpresison</span><span class="p">);</span>

        <span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">packageName</span><span class="p">,</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Identifiers</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>‚ùó Se voc√™ estiver recebendo um erro informando que o delegado n√£o tem um m√©todo Parse, n√£o se preocupe! Voc√™ apenas tem que adicionar uma diretiva <code class="language-plaintext highlighter-rouge">using Sprache;</code> no topo do arquivo.</p> </blockquote> <p>Voc√™ pode remover a interface IParser que criamos para nos ajudar a definir como o c√≥digo deve ser.</p> <h1 id="an√°lise">An√°lise</h1> <p>Ufs, demorou muito! ‚ÄúN√≥s vimos muito! Vamos revisar tudo isso por um momento, certo?</p> <ul> <li>Voc√™ aprendeu que as sintaxes de linguagem s√£o governadas por * gram√°ticas * e que podem ser expressas com uma nota√ß√£o conhecida como BNF ou EBNF.</li> <li>Voc√™ criou um EBNF simplificado para Java, levando em considera√ß√£o apenas o que estava no escopo. Voc√™ sabe que chamamos isso de * melhor ajuste *, e um princ√≠pio √°gil semelhante ao YAGNI - construa apenas o que voc√™ vai usar.</li> <li>Voc√™ criou v√°rios casos de teste, a maioria derivados do pr√≥prio dom√≠nio do problema - a fonte do Autenticador do Google.</li> <li>Voc√™ aprendeu como combinar analisadores Sprache para criar outro analisador mais complexo.</li> </ul> <p>Isso lan√ßou as bases para analisar as estruturas de programa mais complexas. No pr√≥ximo artigo, terminaremos nossa gram√°tica criando mais analisadores que podem lidar com todo o c√≥digo-fonte. Tamb√©m mostrarei como lidar com coment√°rios e como ‚Äúpular‚Äù c√≥digo no qual voc√™ n√£o est√° interessado. Seguindo esse artigo, como um b√¥nus, terminaremos de construir nossa ferramenta e gerar o gr√°fico que mostrar√° aos usu√°rios a rela√ß√£o entre as aulas.</p> <p>Todo o c√≥digo produzido at√© agora foi armazenado no <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser" target="_blank" rel="noopener noreferrer">Github</a>. Voc√™ pode fazer um fork e us√°-lo da maneira que quiser. Para obter a vers√£o exata deste c√≥digo, use <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser/releases/tag/FirstArticle" target="_blank" rel="noopener noreferrer">esta tag</a>.</p> <div style="text-align: right;"> <!-- TODO: create style --> <a href="/pt/parsing-code-with-sprache/" style="font-size: 75%; font-style: italic;">Continuar lendo ‚Üí</a> </div> <br> <div class="tag-list"> <a href="/pt/tags/#dotnet">#dotnet</a> ¬† <a href="/pt/tags/#programa%C3%A7%C3%A3o">#programa√ß√£o</a> ¬† <a href="/pt/tags/#linguagem">#linguagem</a> </div> </article> <article class="post"> <h1 class="post-title"> <a href="/pt/happy-halloween-blog-is-back/">Feliz Halloween! Meu blog est√° de volta!</a> </h1> <time datetime="2020-10-31T18:00:00+00:00" class="post-date"> 31st October 2020 em <a href="/pt/categories/#An%C3%BAncios">An√∫ncios</a> </time> <!-- <span class="permalink"> </span> --> <!-- using excerpts: https://jekyllrb.com/docs/posts/#post-excerpts --> <p>Esta √© minha terceira ou quarta tentativa de criar um blog, e espero ter sucesso em mant√™-lo atualizado. Pelo menos agora eu finalmente tenho o tempo de que preciso para criar novos <em>posts</em> e continuar. Al√©m disso, eu <em>adoro</em> GitHub Pages. √â muito mais legal estar em uma plataforma que eu (meio que) controlo.</p> <div style="text-align: right;"> <!-- TODO: create style --> <a href="/pt/happy-halloween-blog-is-back/" style="font-size: 75%; font-style: italic;">Continuar lendo ‚Üí</a> </div> <br> <div class="tag-list"> </div> </article> </div> <div class="PageNavigation"> </div> </main> <footer class="footer"> <div class="wrapper"> <div> ¬© Copyright 2021 Bruno Brant. Tema baseado em <a href="https://github.com/essentialenemy/noir/" target="_blank" rel="noopener noreferrer">Noir</a> de <a href="https://essentialenemy.com/" target="_blank" rel="noopener noreferrer">Victor Johnson</a>. </div> <div class="social-links">
<ul class="social-media-list">
<li><a rel="noopener noreferrer" href="https://github.com/bruno-brant" title="bruno-brant" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li>
<li><a rel="noopener noreferrer" href="https://stackoverflow.com/users/227332%2Fbruno-brant" title="227332/bruno-brant" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#stackoverflow"></use></svg></a></li>
<li><a rel="noopener noreferrer" href="https://www.linkedin.com/in/brunobrant" title="brunobrant" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg></a></li>
<li><a rel="noopener noreferrer" href="https://twitter.com/HeavyStorm" title="HeavyStorm" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li>
</ul> </div> </div> </footer> </div> </body> </html>
