<!doctype html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <meta property="og:image" content="https://blog.brunobrant.net/assets/technology-matters-logo.png" /> <title> &middot; TECHNOLOGY MATTERS </title> <link rel="stylesheet" href="/pt/styles.css"> <!-- <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/pt/assets/apple-touch-icon-precomposed.png"> --> <link rel="shortcut icon" href="/pt/assets/favicon.ico"> <link rel="alternate" type="application/atom+xml" title="TECHNOLOGY MATTERS" href="/pt/feed.xml"> <!-- Begin Jekyll SEO tag v2.7.1 --> <meta name="generator" content="Jekyll v4.1.1" /> <meta property="og:title" content="Parsing Code With Sprache Part 2" /> <meta name="author" content="Bruno Brant" /> <meta property="og:locale" content="pt" /> <meta name="description" content="ğŸ˜ Este Ã© o segundo artigo de uma sÃ©rie de partes mÃºltiplas sobre como analisar cÃ³digo com Sprache. VocÃª pode ler a primeira parte aqui. No post anterior, vimos como analisar algum texto (em particular, cÃ³digo Java) usando Sprache, uma poderosa biblioteca para C#. Vimos como usar uma abordagem incremental e como usar testes unitÃ¡rios para conduzir o desenvolvimento com esta ferramenta. AtÃ© agora, escrevemos um analisador para Identifier e PackageName (verifique aqui). Agora vamos avanÃ§ar um pouco mais rÃ¡pido. Lembre-se de que temos como alvo o source Java/Android Google Authenticator e que nosso objetivo final Ã© gerar um grÃ¡fico de dependÃªncias de classe para este projeto. Neste artigo, vamos tentar analisar todos os elementos de nÃ­vel superior do arquivo atual em que estamos trabalhando, AuthenticatorActivity.java. â— Em todo o cÃ³digo do blog, eliminei a documentaÃ§Ã£o interna para maior clareza. Verifique o repo para ver os comentÃ¡rios. Refatorando nosso caminho para o sucesso Antes de incrementar o cÃ³digo atual, identifiquei um pequeno ajuste que nos ajudarÃ¡ na prÃ³xima etapa. Veja, o analisador PackageName estÃ¡, na verdade, analisando uma instruÃ§Ã£o package (package statement). Nomes de pacotes sÃ£o usados â€‹â€‹em outros lugares, portanto, facilitaremos a reutilizaÃ§Ã£o extraindo um PackageName do analisador atual. Primeiro, renomeie o analisador JavaGrammar.PackageName para JavaGrammar.PackageStament, o nome correto para o que estÃ¡ analisando; use suas ferramentas de refatoraÃ§Ã£o de IDE para isso. VocÃª tambÃ©m precisa renomear a unidade de teste anterior de PackageNameParserTests para PackageStatementParserTests para manter as coisas coerentes. A seguir, vamos extrair a anÃ¡lise de um PackageName de JavaGrammar.PackageStament. Veja as linhas abaixo: public static readonly Parser&lt;PackageName&gt; PackageStatement = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() // â†“â†“â†“â†“â†“â†“â†“ Parsing of Package Name â†“â†“â†“â†“â†“â†“â†“ from packageHead in Identifier from packageTail in (from delimiter in Sprache.Parse.Char(&#39;.&#39;).Once() from identifier in Identifier select identifier).Many() // â†‘â†‘â†‘â†‘â†‘â†‘â†‘ Parsing of Package Name â†‘â†‘â†‘â†‘â†‘â†‘â†‘ from terminator in Sprache.Parse.Char(&#39;;&#39;) // â†“â†“â†“â†“â†“â†“â†“ And this is how the result is build â†“â†“â†“â†“â†“â†“â†“ select new PackageName(new[] { packageHead }.Concat(packageTail).ToList()); // â†‘â†‘â†‘â†‘â†‘â†‘â†‘ And this is how the result is build â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘ Vamos extrair isso em um analisador isolado, este na verdade chamado PackageName: public static readonly Parser&lt;PackageName&gt; PackageName = from packageHead in Identifier from packageTail in (from delimiter in Sprache.Parse.Char(&#39;.&#39;).Once() from identifier in Identifier select identifier).Many() select new PackageName(new[] { packageHead }.Concat(packageTail).ToList()); Precisamos criar uma estrutura para representar a instruÃ§Ã£o package: public class PackageStatement { public PackageStatement(PackageName packageName) { PackageName = packageName; } public PackageName PackageName { get; } } Vamos atualizar o analisador PackageStatement para retornar a estrutura, usando o analisador PackageName: public static readonly Parser&lt;PackageName&gt; PackageStatement = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() from packageName in PackageName from terminator in Sprache.Parse.Char(&#39;;&#39;) select packageName; Execute todos os testes e vocÃª descobrirÃ¡ que tudo estÃ¡ funcionando como deveria. Esta refatoraÃ§Ã£o foi confirmada sob a tag Refactor_PackageName. Analisando mais estruturas Vamos voltar Ã  criaÃ§Ã£o de novos analisadores. A prÃ³xima estrutura natural Ã© uma declaraÃ§Ã£o de importaÃ§Ã£o que tem o seguinte BNF: DeclaraÃ§Ã£o de importaÃ§Ã£o IMPORT = &quot;import&quot;, PACKAGE_NAME, &quot;;&quot;; Vamos comeÃ§ar atualizando nossa classe Import anterior. Mude seu nome de Import para ImportStatement, que Ã© mais exato. Use sua ferramenta de refatoraÃ§Ã£o IDE para renomear a classe. Eu tambÃ©m criei um construtor para ela que inicializa o PackageName: public class ImportStatement { public ImportStatement(PackageName packageName) { PackageName = packageName; } public PackageName PackageName { get; } } Agora, vamos criar um teste para isso: ğŸ˜ Estou criando um arquivo de teste para cada analisador, embora eles (atualmente) sejam todos parte da mesma classe. Isso nÃ£o Ã© padrÃ£o; Ã© a melhor prÃ¡tica ter uma classe de teste de unidade por classe. Entretanto, fazer dessa forma torna mais fÃ¡cil localizar os testes e nos permite mantÃª-los mais organizados. public class ImportStatementParserTests { [Theory] [InlineData(&quot;import android.annotation.TargetApi;&quot;)] [InlineData(&quot;import android.app.Activity;&quot;)] public void Parse_WhenValidPackageName_ReturnsStructureWithCorrectName(string importStatement) { var actual = JavaGrammar.ImportStatement.Parse(importStatement); Assert.Equal(packageName, string.Join(&#39;.&#39;, actual.PackageName.Identifiers)); } } Usamos as primeiras instruÃ§Ãµes de import de AuthenticatorActivity, como vocÃª pode ver. TambÃ©m estamos fazendo um join dos identificadores assim como fizemos da Ãºltima vez, o que Ã© um pouco tedioso; vamos melhorar isso na etapa de refatorar. A execuÃ§Ã£o desse teste levarÃ¡ a ğŸ”´, pois o cÃ³digo nÃ£o foi implementado. Vamos escrever o analisador agora: public static readonly Parser&lt;ImportStatement&gt; ImportStatement = from importKeyword in Parse.String(&quot;import&quot;).Token() from packageName in PackageName.Token() from delimiter in Parse.Char(&#39;;&#39;).Token() select new ImportStatement(packageName); Leitores Ã¡vidos notarÃ£o o mÃ©todo anteriormente nÃ£o visto Token() na segunda linha. Este Ã© um dos mÃ©todos mais Ãºteis no Sprache - removerÃ¡ os espaÃ§os em branco ao redor do caractere, mas * exigirÃ¡ * que ele esteja lÃ¡. Isso significa que, por exemplo, Parse.String(&quot;import&quot;).Token().Parse(&quot; import &quot;) funcionarÃ¡, mas Parse.String(&quot;import&quot;).Token().Parse(&quot; importasd &quot;) nÃ£o. O resto deve ser muito legÃ­vel - procure a palavra-chave import, depois uma estrutura PackageName e retorne uma instruÃ§Ã£o import. Execute todos os testes. VocÃª deve obter um ğŸŸ¢. Continuando, vamos refatorar um pouco. Lembra que eu disse que farÃ­amos algo sobre string.Join(&#39;.&#39;, actual.PackageName.Identifiers)? Agora Ã© a hora! A representaÃ§Ã£o de string de um nome de pacote, digamos, â€œandroid.content.ActivityNotFoundExceptionâ€ nÃ£o Ã© outro senÃ£o â€œandroid.content.ActivityNotFoundExceptionâ€. EntÃ£o, o que vocÃª acha de substituir PackageName.ToString para cumprir esse comportamento? public class PackageName { // ... public override string ToString() { return string.Join(&#39;.&#39;, Identifiers); } } ğŸ˜ DICA: Ao realizer um override em mÃ©todos e propriedades, use o xml doc /// &lt;inheritdoc /&gt; como documentaÃ§Ã£o. Agora, seguindo a mesma ideia, podemos adicionar uma substituiÃ§Ã£o de ToString em ImportStatement: public class ImportStatement { // ... public override string ToString() { return $&quot;import {PackageName};&quot;; } } Agora podemos atualizar nosso teste de unidade para refletir este refator: [Theory] [InlineData(&quot;import android.annotation.TargetApi;&quot;)] [InlineData(&quot;import android.app.Activity;&quot;)] public void Parse_WhenValidPackageName_ReturnsStructureWithCorrectName(string importStatement) { var actual = JavaGrammar.ImportStatement.Parse(importStatement); Assert.Equal(importStatement, actual.ToString()); } âš  Aviso: neste caso, a entrada Ã© formatada exatamente como a saÃ­da de ImportStatement.ToString. No entanto, se vocÃª analisar algo como &quot; import name.surname&quot;, enquanto a anÃ¡lise funcionarÃ¡, o ToString retornarÃ¡ &quot;import name.surname&quot;, sem espaÃ§os. Isso significa que a regra Token () nÃ£o estÃ¡ sendo testada em nossa suÃ­te - a razÃ£o para isso Ã© que ela nÃ£o aparece em nosso escopo - portanto, os testes sÃ£o um pouco frÃ¡geis e devem ser melhorados na maioria das circunstÃ¢ncias. NÃ£o vou fazer isso durante esses exercÃ­cios, mas os leitores devem definitivamente fazÃª-lo. Agora, precisamos ler um bloco de importaÃ§Ãµes em nosso arquivo. Chamamos isso de IMPORT_LIST no eBNF. A estrutura de dados para isso nÃ£o precisa ser mais do que List &lt;ImportStatement&gt;, mas precisamos de um analisador para isso. Comece com um teste: public class ImportListParserTests { public static IEnumerable&lt;object[]&gt; ImportLists() { yield return new string[] { @&quot; import com.google.android.apps.authenticator.util.EmptySpaceClickableDragSortListView; import com.google.android.apps.authenticator.util.annotations.FixWhenMinSdkVersion; import com.google.android.apps.authenticator2.R; import com.google.common.annotations.VisibleForTesting; &quot;.Trim(), }; yield return new string[] { @&quot; import android.support.v7.widget.Toolbar; import android.text.Html; import android.util.Log; import android.view.ActionMode; import android.view.ContextMenu; &quot;.Trim(), }; } [Theory] [MemberData(nameof(ImportLists))] public void Parse_WhenValidPackageName_ReturnsStructureWithCorrectName(string importList) { var expected = importList.Split(Environment.NewLine).ToList(); var actual = JavaGrammar.ImportList.Parse(importList); Assert.Equal(expected, actual.Select(_ =&gt; _.ToString())); } } A implementaÃ§Ã£o da lista Ã© simples: public static readonly Parser&lt;List&lt;ImportStatement&gt;&gt; ImportList = from statements in ImportStatement.Many().Token() select statements.ToList(); Agora que as importaÃ§Ãµes foram tratadas, vamos passar para a prÃ³xima estrutura de cÃ³digo em AuthenticatorActivity.java, uma anotaÃ§Ã£o. AnotaÃ§Ãµes A prÃ³xima estrutura de cÃ³digo em AuthenticatorActivity Ã© a declaraÃ§Ã£o da classe. Ele contÃ©m um trecho de cÃ³digo sobre o qual nÃ£o falamos antes, uma anotaÃ§Ã£o. As anotaÃ§Ãµes Java sÃ£o anÃ¡logas aos atributos C# e tÃªm a seguinte aparÃªncia: @FixWhenMinSdkVersion(11) Assim como no C#, essas estruturas sÃ³ podem aparecer antes das declaraÃ§Ãµes e, neste caso, Ã© uma declaraÃ§Ã£o de classe. Precisamos criar a estrutura de dados para acomodar isso e o analisador para produzi-la. Conforme mencionado anteriormente, estamos construindo interativamente o eBNF. Isso Ã© para tornar nosso analisador mais simples - apenas escrever o cÃ³digo necessÃ¡rio para as estruturas que estÃ£o presentes no cÃ³digo-fonte. Ã‰ por isso que a anotaÃ§Ã£o nÃ£o foi mencionada antes. Vamos atualizÃ¡-lo: ANNOTATION = &quot;@&quot;, IDENTIFIER, &quot;(&quot;, ARGUMENT_LIST, &quot;)&quot; ARGUMENT_LIST = ARGUMENT, { &quot;,&quot; ARGUMENT } ARGUMENT = LITERAL LITERAL = INTEGER_LITERAL O eBNF acima Ã© parcial; Por exemplo, a lista de argumentos para a anotaÃ§Ã£o Ã© mais complexa, permitindo outros tipos. Mas atÃ© agora sÃ³ temos o parÃ¢metro inteiro, entÃ£o vamos nos ater a ele. A primeira coisa Ã© definir a estrutura de dados de uma anotaÃ§Ã£o. Olhando para ele, vocÃª pode imaginar que tem um identificador como nome e, em seguida, a lista de argumentos. public interface ILiteral { object Value { get; } } public class IntegerLiteral : ILiteral { public IntegerLiteral(int value) { Value = value; } public int Value { get; } object ILiteral.Value =&gt; Value; public override string ToString() { return Value.ToString(); } } public class Annotation { public Annotation(string name, List&lt;ILiteral&gt; arguments) { Name = name; Arguments = arguments; } public string Name { get; } public List&lt;Argument&gt; Arguments { get; } public override string ToString() { return $&quot;@{Name}({string.Join(&quot;, &quot;, Arguments)})&quot;; } } Introduzimos um pouco de abstraÃ§Ã£o que pode nos poupar algum trabalho mais tarde - deixamos claro que literal pode ser muitas coisas, nÃ£o apenas inteiros. A conversÃ£o para a estrutura correta permitirÃ¡ que os usuÃ¡rios obtenham o valor digitado - caso contrÃ¡rio, por enquanto, encaixaremos o int e o retornamos como um objeto. Precisamos criar um analisador para essa nova estrutura - um literal inteiro. Testes: public class IntergerLiteralParserTests { [Theory] [InlineData(11)] public void MyTheory(int value) { var actual = JavaGrammar.IntegerLiteral.Parse(value.ToString()); Assert.Equal(value, actual.Value); } } E o analisador: public static readonly Parser&lt;IntegerLiteral&gt; IntegerLiteral = from digits in Parse.Digit.AtLeastOnce() let number = string.Concat(digits) let value = int.Parse(number) select new IntegerLiteral(value); Uma coisa no cÃ³digo acima que pode fazer vocÃª se perguntar Ã© o AtLeastOnce(). Isso Ã© muito prÃ³ximo de Many(), com a diferenÃ§a de que irÃ¡ falhar na anÃ¡lise quando nÃ£o houver pelo menos um Ãºnico dÃ­gito. Se nÃ£o aplicarmos isso aqui, o analisador aceitarÃ¡ uma lista de argumentos vazia. Agora vamos para a anotaÃ§Ã£o real. public class AnnotationParserTests { [Theory] [InlineData(&quot;@Number(11)&quot;, new object[] { 11 })] public void Parse_WhenAnnotationHasParameters_CorrectParameters(string annotation, object[] parameters) { var actual = JavaGrammar.Annotation.Parse(annotation); Assert.Equal(parameters, actual.Arguments.Cast&lt;object&gt;().ToArray()); } } â— Esses testes sÃ£o muito bÃ¡sicos; na maioria dos cenÃ¡rios de produÃ§Ã£o, sugiro escrever testes que tenham mais condiÃ§Ãµes; por exemplo, poderÃ­amos testar casos como @ SomeAnnotation, dividindo o cÃ³digo em duas linhas, etc. Observe o cÃ³digo que estÃ¡ sendo testado para encontrar lacunas ou riscos e crie os testes correspondentes. Finalmente, com TDD devemos escrever um teste por vez e evoluir iterativamente. A razÃ£o pela qual podemos nos safar com testes tÃ£o simples Ã© que sabemos com antecedÃªncia todo o cÃ³digo que precisa ser analisado, entÃ£o podemos testar novamente um caso real e verificar se surgem bugs, mas mesmo assim, eu teria cuidado onde isso nÃ£o apenas uma postagem no blog. A implementaÃ§Ã£o irÃ¡ alavancar o analisador IntegerLiteral que acabamos de codificar: public static readonly Parser&lt;Annotation&gt; Annotation = from at in Parse.Char(&#39;@&#39;).Once() from identifier in Identifier.Token() from startList in Parse.Char(&#39;(&#39;).Token() from literal in IntegerLiteral.Token().Optional() from endList in Parse.Char(&#39;)&#39;).Token() let arguments = literal.IsDefined ? new List&lt;ILiteral&gt; { literal.Get() } : new List&lt;ILiteral&gt;() select new Annotation(identifier, arguments); Novamente, podemos ver um analisador opcional sendo chamado. Para obter a lista real, precisamos fazer alguma ginÃ¡stica LINQ - retornar uma lista com um Ãºnico literal ou uma lista vazia. No futuro, provavelmente criaremos um analisador ArgumentList que deve substituir isso, mas atÃ© agora, nÃ£o hÃ¡ necessidade. Os testes devem ser ğŸŸ¢. DeclaraÃ§Ã£o de classe A prÃ³xima coisa no arquivo Ã© a definiÃ§Ã£o real da classe. Vamos decompÃ´-lo: @FixWhenMinSdkVersion (11) public class AuthenticatorActivity estende TestableActivity { // ... Este Ã© um bom exemplo porque, de cara, lidaremos com extends, um caso comum, mas nÃ£o basal. A anotaÃ§Ã£o jÃ¡ foi cuidada, entÃ£o vamos analisar a declaraÃ§Ã£o da classe: visibility â”‚ â”‚ identifier, class identifier, base class â”‚ â”‚ â”‚ â”Œâ”€â”€â”´â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â” public class AuthenticatorActivity extends TestableActivity â””â”€â”¬â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜ â”‚ interface inheritance keyword â”‚ class declaration keyword Portanto, precisamos expandir o EBNF: CLASS_DECLARATION = VISIBILITY, &quot;class&quot;, IDENTIFIER, { &quot;extends&quot;, IDENTIFIER }, &quot;{&quot;, (* ommited *), &quot;}&quot;; VISIBILITY = &quot;public&quot; â— NÃ£o estamos lidando com outras visibilidades apenas no momento, a nÃ£o ser para refletir nossa abordagem em evoluÃ§Ã£o. Ã€ medida que lidamos com mais casos, expandimos a definiÃ§Ã£o. Isso deve ser realmente simples, mas precisamos atualizar a estrutura da classe para refleti-la: public enum Visibility { Public, } public class ClassDefinition { public ClassDefinition(Visibility visibility, string name, string? baseClass = null, Annotation? annotation = null) { Visibility = visibility; Name = name; BaseClass = baseClass; Annotation = annotation; } public Visibility Visibility { get; } public string Name { get; } public string? BaseClass { get; } public Annotation? Annotation { get; } } Algumas coisas a serem observadas: estamos seguindo estritamente o trecho de cÃ³digo que estÃ¡ sendo processado, entÃ£o, embora haja um membro Visibility, o Ãºnico valor possÃ­vel Ã© Public; embora Java permita vÃ¡rias anotaÃ§Ãµes, estamos apenas considerando uma Ãºnica anotaÃ§Ã£o etc. O motivo pelo qual estou seguindo essa abordagem Ã© que ainda nÃ£o sabemos se esses casos surgirÃ£o dentro do cÃ³digo. Se o fizerem, iremos reescrever o cÃ³digo acima. Agora vamos criar nossos testes: public class ClassDefinitionParserTests { [Fact] public void Parse_AnnotatedClassWithExtends_CorrectParameters() { var code = @&quot; @FixWhenMinSdkVersion(11) public class AuthenticatorActivity extends TestableActivity &quot;.Trim(); var actual = JavaGrammar.ClassDefinition.Parse(code); Assert.Equal(&quot;FixWhenMinSdkVersion&quot;, actual.Annotation.Name); Assert.Equal(11, actual.Annotation.Arguments[0].Value); Assert.Equal(Visibility.Public, actual.Visibility); Assert.Equal(&quot;AuthenticatorActivity&quot;, actual.Name); Assert.Equal(&quot;TestableActivity&quot;, actual.BaseClass); } } Novamente, os testes lidam apenas com o que vimos atÃ© agora. Usei um Fact em vez de uma Theory porque estamos lidando apenas com um Ãºnico caso. Assim que tivermos mais casos para testar, vou convertÃª-lo em Theory. Ah! Estou testando o resultado da anÃ¡lise de anotaÃ§Ã£o, que na verdade estÃ¡ repetindo os testes jÃ¡ feitos no AnnotationParserTests. PoderÃ­amos fazer isso de forma um pouco diferente e apenas ter certeza de que o analisador correto foi chamado, mas por enquanto, vamos manter isso simples e repetir o teste. Agora, a implementaÃ§Ã£o, embora longa, Ã© simples, apenas analise cada fragmento que vimos na anÃ¡lise acima: public static readonly Parser&lt;ClassDefinition&gt; ClassDefinition = from annotation in Annotation.Token() from visibility in Parse.String(&quot;public&quot;).Token() from classKeyword in Parse.String(&quot;class&quot;).Token() from className in Identifier.Token() from extendsKeyword in Parse.String(&quot;extends&quot;).Token() from baseClassName in Identifier.Token() select new ClassDefinition(Visibility.Public, className, baseClassName, annotation); Eu cortei alguns cantos aqui, como analisar a visibilidade diretamente. TambÃ©m lidaremos com isso quando for necessÃ¡rio. FaÃ§a seus testes e aprecie seu ğŸŸ¢. Resumo Com este artigo, concluÃ­mos a primeira etapa: podemos analisar todos os elementos de nÃ­vel superior de um arquivo de origem Java. VocÃª aprendeu um pouco mais sobre como usar Sprache e combinar analisadores e provavelmente aprendeu algumas tÃ©cnicas sobre como criar cÃ³digo apto para o propÃ³sito, usando uma abordagem orientada a testes e evoluindo o cÃ³digo anterior Ã  medida que avanÃ§amos em nosso entendimento do domÃ­nio do problema, um processo denominado ** descoberta **. Todo o cÃ³digo produzido atÃ© agora foi armazenado em Github. VocÃª pode fazer um fork e usÃ¡-lo da maneira que quiser. Para obter a versÃ£o exata deste cÃ³digo, use esta tag. No prÃ³ximo artigo, comeÃ§aremos a analisar elementos de classe como construtores, campos e mÃ©todos. Estaremos ainda mais focados, lidando apenas com as estruturas de cÃ³digo que aparecem no cÃ³digo e, com sorte, poderemos terminar de analisar nossa primeira classe. Vejo vocÃª na prÃ³xima vez!" /> <meta property="og:description" content="ğŸ˜ Este Ã© o segundo artigo de uma sÃ©rie de partes mÃºltiplas sobre como analisar cÃ³digo com Sprache. VocÃª pode ler a primeira parte aqui. No post anterior, vimos como analisar algum texto (em particular, cÃ³digo Java) usando Sprache, uma poderosa biblioteca para C#. Vimos como usar uma abordagem incremental e como usar testes unitÃ¡rios para conduzir o desenvolvimento com esta ferramenta. AtÃ© agora, escrevemos um analisador para Identifier e PackageName (verifique aqui). Agora vamos avanÃ§ar um pouco mais rÃ¡pido. Lembre-se de que temos como alvo o source Java/Android Google Authenticator e que nosso objetivo final Ã© gerar um grÃ¡fico de dependÃªncias de classe para este projeto. Neste artigo, vamos tentar analisar todos os elementos de nÃ­vel superior do arquivo atual em que estamos trabalhando, AuthenticatorActivity.java. â— Em todo o cÃ³digo do blog, eliminei a documentaÃ§Ã£o interna para maior clareza. Verifique o repo para ver os comentÃ¡rios. Refatorando nosso caminho para o sucesso Antes de incrementar o cÃ³digo atual, identifiquei um pequeno ajuste que nos ajudarÃ¡ na prÃ³xima etapa. Veja, o analisador PackageName estÃ¡, na verdade, analisando uma instruÃ§Ã£o package (package statement). Nomes de pacotes sÃ£o usados â€‹â€‹em outros lugares, portanto, facilitaremos a reutilizaÃ§Ã£o extraindo um PackageName do analisador atual. Primeiro, renomeie o analisador JavaGrammar.PackageName para JavaGrammar.PackageStament, o nome correto para o que estÃ¡ analisando; use suas ferramentas de refatoraÃ§Ã£o de IDE para isso. VocÃª tambÃ©m precisa renomear a unidade de teste anterior de PackageNameParserTests para PackageStatementParserTests para manter as coisas coerentes. A seguir, vamos extrair a anÃ¡lise de um PackageName de JavaGrammar.PackageStament. Veja as linhas abaixo: public static readonly Parser&lt;PackageName&gt; PackageStatement = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() // â†“â†“â†“â†“â†“â†“â†“ Parsing of Package Name â†“â†“â†“â†“â†“â†“â†“ from packageHead in Identifier from packageTail in (from delimiter in Sprache.Parse.Char(&#39;.&#39;).Once() from identifier in Identifier select identifier).Many() // â†‘â†‘â†‘â†‘â†‘â†‘â†‘ Parsing of Package Name â†‘â†‘â†‘â†‘â†‘â†‘â†‘ from terminator in Sprache.Parse.Char(&#39;;&#39;) // â†“â†“â†“â†“â†“â†“â†“ And this is how the result is build â†“â†“â†“â†“â†“â†“â†“ select new PackageName(new[] { packageHead }.Concat(packageTail).ToList()); // â†‘â†‘â†‘â†‘â†‘â†‘â†‘ And this is how the result is build â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘ Vamos extrair isso em um analisador isolado, este na verdade chamado PackageName: public static readonly Parser&lt;PackageName&gt; PackageName = from packageHead in Identifier from packageTail in (from delimiter in Sprache.Parse.Char(&#39;.&#39;).Once() from identifier in Identifier select identifier).Many() select new PackageName(new[] { packageHead }.Concat(packageTail).ToList()); Precisamos criar uma estrutura para representar a instruÃ§Ã£o package: public class PackageStatement { public PackageStatement(PackageName packageName) { PackageName = packageName; } public PackageName PackageName { get; } } Vamos atualizar o analisador PackageStatement para retornar a estrutura, usando o analisador PackageName: public static readonly Parser&lt;PackageName&gt; PackageStatement = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() from packageName in PackageName from terminator in Sprache.Parse.Char(&#39;;&#39;) select packageName; Execute todos os testes e vocÃª descobrirÃ¡ que tudo estÃ¡ funcionando como deveria. Esta refatoraÃ§Ã£o foi confirmada sob a tag Refactor_PackageName. Analisando mais estruturas Vamos voltar Ã  criaÃ§Ã£o de novos analisadores. A prÃ³xima estrutura natural Ã© uma declaraÃ§Ã£o de importaÃ§Ã£o que tem o seguinte BNF: DeclaraÃ§Ã£o de importaÃ§Ã£o IMPORT = &quot;import&quot;, PACKAGE_NAME, &quot;;&quot;; Vamos comeÃ§ar atualizando nossa classe Import anterior. Mude seu nome de Import para ImportStatement, que Ã© mais exato. Use sua ferramenta de refatoraÃ§Ã£o IDE para renomear a classe. Eu tambÃ©m criei um construtor para ela que inicializa o PackageName: public class ImportStatement { public ImportStatement(PackageName packageName) { PackageName = packageName; } public PackageName PackageName { get; } } Agora, vamos criar um teste para isso: ğŸ˜ Estou criando um arquivo de teste para cada analisador, embora eles (atualmente) sejam todos parte da mesma classe. Isso nÃ£o Ã© padrÃ£o; Ã© a melhor prÃ¡tica ter uma classe de teste de unidade por classe. Entretanto, fazer dessa forma torna mais fÃ¡cil localizar os testes e nos permite mantÃª-los mais organizados. public class ImportStatementParserTests { [Theory] [InlineData(&quot;import android.annotation.TargetApi;&quot;)] [InlineData(&quot;import android.app.Activity;&quot;)] public void Parse_WhenValidPackageName_ReturnsStructureWithCorrectName(string importStatement) { var actual = JavaGrammar.ImportStatement.Parse(importStatement); Assert.Equal(packageName, string.Join(&#39;.&#39;, actual.PackageName.Identifiers)); } } Usamos as primeiras instruÃ§Ãµes de import de AuthenticatorActivity, como vocÃª pode ver. TambÃ©m estamos fazendo um join dos identificadores assim como fizemos da Ãºltima vez, o que Ã© um pouco tedioso; vamos melhorar isso na etapa de refatorar. A execuÃ§Ã£o desse teste levarÃ¡ a ğŸ”´, pois o cÃ³digo nÃ£o foi implementado. Vamos escrever o analisador agora: public static readonly Parser&lt;ImportStatement&gt; ImportStatement = from importKeyword in Parse.String(&quot;import&quot;).Token() from packageName in PackageName.Token() from delimiter in Parse.Char(&#39;;&#39;).Token() select new ImportStatement(packageName); Leitores Ã¡vidos notarÃ£o o mÃ©todo anteriormente nÃ£o visto Token() na segunda linha. Este Ã© um dos mÃ©todos mais Ãºteis no Sprache - removerÃ¡ os espaÃ§os em branco ao redor do caractere, mas * exigirÃ¡ * que ele esteja lÃ¡. Isso significa que, por exemplo, Parse.String(&quot;import&quot;).Token().Parse(&quot; import &quot;) funcionarÃ¡, mas Parse.String(&quot;import&quot;).Token().Parse(&quot; importasd &quot;) nÃ£o. O resto deve ser muito legÃ­vel - procure a palavra-chave import, depois uma estrutura PackageName e retorne uma instruÃ§Ã£o import. Execute todos os testes. VocÃª deve obter um ğŸŸ¢. Continuando, vamos refatorar um pouco. Lembra que eu disse que farÃ­amos algo sobre string.Join(&#39;.&#39;, actual.PackageName.Identifiers)? Agora Ã© a hora! A representaÃ§Ã£o de string de um nome de pacote, digamos, â€œandroid.content.ActivityNotFoundExceptionâ€ nÃ£o Ã© outro senÃ£o â€œandroid.content.ActivityNotFoundExceptionâ€. EntÃ£o, o que vocÃª acha de substituir PackageName.ToString para cumprir esse comportamento? public class PackageName { // ... public override string ToString() { return string.Join(&#39;.&#39;, Identifiers); } } ğŸ˜ DICA: Ao realizer um override em mÃ©todos e propriedades, use o xml doc /// &lt;inheritdoc /&gt; como documentaÃ§Ã£o. Agora, seguindo a mesma ideia, podemos adicionar uma substituiÃ§Ã£o de ToString em ImportStatement: public class ImportStatement { // ... public override string ToString() { return $&quot;import {PackageName};&quot;; } } Agora podemos atualizar nosso teste de unidade para refletir este refator: [Theory] [InlineData(&quot;import android.annotation.TargetApi;&quot;)] [InlineData(&quot;import android.app.Activity;&quot;)] public void Parse_WhenValidPackageName_ReturnsStructureWithCorrectName(string importStatement) { var actual = JavaGrammar.ImportStatement.Parse(importStatement); Assert.Equal(importStatement, actual.ToString()); } âš  Aviso: neste caso, a entrada Ã© formatada exatamente como a saÃ­da de ImportStatement.ToString. No entanto, se vocÃª analisar algo como &quot; import name.surname&quot;, enquanto a anÃ¡lise funcionarÃ¡, o ToString retornarÃ¡ &quot;import name.surname&quot;, sem espaÃ§os. Isso significa que a regra Token () nÃ£o estÃ¡ sendo testada em nossa suÃ­te - a razÃ£o para isso Ã© que ela nÃ£o aparece em nosso escopo - portanto, os testes sÃ£o um pouco frÃ¡geis e devem ser melhorados na maioria das circunstÃ¢ncias. NÃ£o vou fazer isso durante esses exercÃ­cios, mas os leitores devem definitivamente fazÃª-lo. Agora, precisamos ler um bloco de importaÃ§Ãµes em nosso arquivo. Chamamos isso de IMPORT_LIST no eBNF. A estrutura de dados para isso nÃ£o precisa ser mais do que List &lt;ImportStatement&gt;, mas precisamos de um analisador para isso. Comece com um teste: public class ImportListParserTests { public static IEnumerable&lt;object[]&gt; ImportLists() { yield return new string[] { @&quot; import com.google.android.apps.authenticator.util.EmptySpaceClickableDragSortListView; import com.google.android.apps.authenticator.util.annotations.FixWhenMinSdkVersion; import com.google.android.apps.authenticator2.R; import com.google.common.annotations.VisibleForTesting; &quot;.Trim(), }; yield return new string[] { @&quot; import android.support.v7.widget.Toolbar; import android.text.Html; import android.util.Log; import android.view.ActionMode; import android.view.ContextMenu; &quot;.Trim(), }; } [Theory] [MemberData(nameof(ImportLists))] public void Parse_WhenValidPackageName_ReturnsStructureWithCorrectName(string importList) { var expected = importList.Split(Environment.NewLine).ToList(); var actual = JavaGrammar.ImportList.Parse(importList); Assert.Equal(expected, actual.Select(_ =&gt; _.ToString())); } } A implementaÃ§Ã£o da lista Ã© simples: public static readonly Parser&lt;List&lt;ImportStatement&gt;&gt; ImportList = from statements in ImportStatement.Many().Token() select statements.ToList(); Agora que as importaÃ§Ãµes foram tratadas, vamos passar para a prÃ³xima estrutura de cÃ³digo em AuthenticatorActivity.java, uma anotaÃ§Ã£o. AnotaÃ§Ãµes A prÃ³xima estrutura de cÃ³digo em AuthenticatorActivity Ã© a declaraÃ§Ã£o da classe. Ele contÃ©m um trecho de cÃ³digo sobre o qual nÃ£o falamos antes, uma anotaÃ§Ã£o. As anotaÃ§Ãµes Java sÃ£o anÃ¡logas aos atributos C# e tÃªm a seguinte aparÃªncia: @FixWhenMinSdkVersion(11) Assim como no C#, essas estruturas sÃ³ podem aparecer antes das declaraÃ§Ãµes e, neste caso, Ã© uma declaraÃ§Ã£o de classe. Precisamos criar a estrutura de dados para acomodar isso e o analisador para produzi-la. Conforme mencionado anteriormente, estamos construindo interativamente o eBNF. Isso Ã© para tornar nosso analisador mais simples - apenas escrever o cÃ³digo necessÃ¡rio para as estruturas que estÃ£o presentes no cÃ³digo-fonte. Ã‰ por isso que a anotaÃ§Ã£o nÃ£o foi mencionada antes. Vamos atualizÃ¡-lo: ANNOTATION = &quot;@&quot;, IDENTIFIER, &quot;(&quot;, ARGUMENT_LIST, &quot;)&quot; ARGUMENT_LIST = ARGUMENT, { &quot;,&quot; ARGUMENT } ARGUMENT = LITERAL LITERAL = INTEGER_LITERAL O eBNF acima Ã© parcial; Por exemplo, a lista de argumentos para a anotaÃ§Ã£o Ã© mais complexa, permitindo outros tipos. Mas atÃ© agora sÃ³ temos o parÃ¢metro inteiro, entÃ£o vamos nos ater a ele. A primeira coisa Ã© definir a estrutura de dados de uma anotaÃ§Ã£o. Olhando para ele, vocÃª pode imaginar que tem um identificador como nome e, em seguida, a lista de argumentos. public interface ILiteral { object Value { get; } } public class IntegerLiteral : ILiteral { public IntegerLiteral(int value) { Value = value; } public int Value { get; } object ILiteral.Value =&gt; Value; public override string ToString() { return Value.ToString(); } } public class Annotation { public Annotation(string name, List&lt;ILiteral&gt; arguments) { Name = name; Arguments = arguments; } public string Name { get; } public List&lt;Argument&gt; Arguments { get; } public override string ToString() { return $&quot;@{Name}({string.Join(&quot;, &quot;, Arguments)})&quot;; } } Introduzimos um pouco de abstraÃ§Ã£o que pode nos poupar algum trabalho mais tarde - deixamos claro que literal pode ser muitas coisas, nÃ£o apenas inteiros. A conversÃ£o para a estrutura correta permitirÃ¡ que os usuÃ¡rios obtenham o valor digitado - caso contrÃ¡rio, por enquanto, encaixaremos o int e o retornamos como um objeto. Precisamos criar um analisador para essa nova estrutura - um literal inteiro. Testes: public class IntergerLiteralParserTests { [Theory] [InlineData(11)] public void MyTheory(int value) { var actual = JavaGrammar.IntegerLiteral.Parse(value.ToString()); Assert.Equal(value, actual.Value); } } E o analisador: public static readonly Parser&lt;IntegerLiteral&gt; IntegerLiteral = from digits in Parse.Digit.AtLeastOnce() let number = string.Concat(digits) let value = int.Parse(number) select new IntegerLiteral(value); Uma coisa no cÃ³digo acima que pode fazer vocÃª se perguntar Ã© o AtLeastOnce(). Isso Ã© muito prÃ³ximo de Many(), com a diferenÃ§a de que irÃ¡ falhar na anÃ¡lise quando nÃ£o houver pelo menos um Ãºnico dÃ­gito. Se nÃ£o aplicarmos isso aqui, o analisador aceitarÃ¡ uma lista de argumentos vazia. Agora vamos para a anotaÃ§Ã£o real. public class AnnotationParserTests { [Theory] [InlineData(&quot;@Number(11)&quot;, new object[] { 11 })] public void Parse_WhenAnnotationHasParameters_CorrectParameters(string annotation, object[] parameters) { var actual = JavaGrammar.Annotation.Parse(annotation); Assert.Equal(parameters, actual.Arguments.Cast&lt;object&gt;().ToArray()); } } â— Esses testes sÃ£o muito bÃ¡sicos; na maioria dos cenÃ¡rios de produÃ§Ã£o, sugiro escrever testes que tenham mais condiÃ§Ãµes; por exemplo, poderÃ­amos testar casos como @ SomeAnnotation, dividindo o cÃ³digo em duas linhas, etc. Observe o cÃ³digo que estÃ¡ sendo testado para encontrar lacunas ou riscos e crie os testes correspondentes. Finalmente, com TDD devemos escrever um teste por vez e evoluir iterativamente. A razÃ£o pela qual podemos nos safar com testes tÃ£o simples Ã© que sabemos com antecedÃªncia todo o cÃ³digo que precisa ser analisado, entÃ£o podemos testar novamente um caso real e verificar se surgem bugs, mas mesmo assim, eu teria cuidado onde isso nÃ£o apenas uma postagem no blog. A implementaÃ§Ã£o irÃ¡ alavancar o analisador IntegerLiteral que acabamos de codificar: public static readonly Parser&lt;Annotation&gt; Annotation = from at in Parse.Char(&#39;@&#39;).Once() from identifier in Identifier.Token() from startList in Parse.Char(&#39;(&#39;).Token() from literal in IntegerLiteral.Token().Optional() from endList in Parse.Char(&#39;)&#39;).Token() let arguments = literal.IsDefined ? new List&lt;ILiteral&gt; { literal.Get() } : new List&lt;ILiteral&gt;() select new Annotation(identifier, arguments); Novamente, podemos ver um analisador opcional sendo chamado. Para obter a lista real, precisamos fazer alguma ginÃ¡stica LINQ - retornar uma lista com um Ãºnico literal ou uma lista vazia. No futuro, provavelmente criaremos um analisador ArgumentList que deve substituir isso, mas atÃ© agora, nÃ£o hÃ¡ necessidade. Os testes devem ser ğŸŸ¢. DeclaraÃ§Ã£o de classe A prÃ³xima coisa no arquivo Ã© a definiÃ§Ã£o real da classe. Vamos decompÃ´-lo: @FixWhenMinSdkVersion (11) public class AuthenticatorActivity estende TestableActivity { // ... Este Ã© um bom exemplo porque, de cara, lidaremos com extends, um caso comum, mas nÃ£o basal. A anotaÃ§Ã£o jÃ¡ foi cuidada, entÃ£o vamos analisar a declaraÃ§Ã£o da classe: visibility â”‚ â”‚ identifier, class identifier, base class â”‚ â”‚ â”‚ â”Œâ”€â”€â”´â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â” public class AuthenticatorActivity extends TestableActivity â””â”€â”¬â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜ â”‚ interface inheritance keyword â”‚ class declaration keyword Portanto, precisamos expandir o EBNF: CLASS_DECLARATION = VISIBILITY, &quot;class&quot;, IDENTIFIER, { &quot;extends&quot;, IDENTIFIER }, &quot;{&quot;, (* ommited *), &quot;}&quot;; VISIBILITY = &quot;public&quot; â— NÃ£o estamos lidando com outras visibilidades apenas no momento, a nÃ£o ser para refletir nossa abordagem em evoluÃ§Ã£o. Ã€ medida que lidamos com mais casos, expandimos a definiÃ§Ã£o. Isso deve ser realmente simples, mas precisamos atualizar a estrutura da classe para refleti-la: public enum Visibility { Public, } public class ClassDefinition { public ClassDefinition(Visibility visibility, string name, string? baseClass = null, Annotation? annotation = null) { Visibility = visibility; Name = name; BaseClass = baseClass; Annotation = annotation; } public Visibility Visibility { get; } public string Name { get; } public string? BaseClass { get; } public Annotation? Annotation { get; } } Algumas coisas a serem observadas: estamos seguindo estritamente o trecho de cÃ³digo que estÃ¡ sendo processado, entÃ£o, embora haja um membro Visibility, o Ãºnico valor possÃ­vel Ã© Public; embora Java permita vÃ¡rias anotaÃ§Ãµes, estamos apenas considerando uma Ãºnica anotaÃ§Ã£o etc. O motivo pelo qual estou seguindo essa abordagem Ã© que ainda nÃ£o sabemos se esses casos surgirÃ£o dentro do cÃ³digo. Se o fizerem, iremos reescrever o cÃ³digo acima. Agora vamos criar nossos testes: public class ClassDefinitionParserTests { [Fact] public void Parse_AnnotatedClassWithExtends_CorrectParameters() { var code = @&quot; @FixWhenMinSdkVersion(11) public class AuthenticatorActivity extends TestableActivity &quot;.Trim(); var actual = JavaGrammar.ClassDefinition.Parse(code); Assert.Equal(&quot;FixWhenMinSdkVersion&quot;, actual.Annotation.Name); Assert.Equal(11, actual.Annotation.Arguments[0].Value); Assert.Equal(Visibility.Public, actual.Visibility); Assert.Equal(&quot;AuthenticatorActivity&quot;, actual.Name); Assert.Equal(&quot;TestableActivity&quot;, actual.BaseClass); } } Novamente, os testes lidam apenas com o que vimos atÃ© agora. Usei um Fact em vez de uma Theory porque estamos lidando apenas com um Ãºnico caso. Assim que tivermos mais casos para testar, vou convertÃª-lo em Theory. Ah! Estou testando o resultado da anÃ¡lise de anotaÃ§Ã£o, que na verdade estÃ¡ repetindo os testes jÃ¡ feitos no AnnotationParserTests. PoderÃ­amos fazer isso de forma um pouco diferente e apenas ter certeza de que o analisador correto foi chamado, mas por enquanto, vamos manter isso simples e repetir o teste. Agora, a implementaÃ§Ã£o, embora longa, Ã© simples, apenas analise cada fragmento que vimos na anÃ¡lise acima: public static readonly Parser&lt;ClassDefinition&gt; ClassDefinition = from annotation in Annotation.Token() from visibility in Parse.String(&quot;public&quot;).Token() from classKeyword in Parse.String(&quot;class&quot;).Token() from className in Identifier.Token() from extendsKeyword in Parse.String(&quot;extends&quot;).Token() from baseClassName in Identifier.Token() select new ClassDefinition(Visibility.Public, className, baseClassName, annotation); Eu cortei alguns cantos aqui, como analisar a visibilidade diretamente. TambÃ©m lidaremos com isso quando for necessÃ¡rio. FaÃ§a seus testes e aprecie seu ğŸŸ¢. Resumo Com este artigo, concluÃ­mos a primeira etapa: podemos analisar todos os elementos de nÃ­vel superior de um arquivo de origem Java. VocÃª aprendeu um pouco mais sobre como usar Sprache e combinar analisadores e provavelmente aprendeu algumas tÃ©cnicas sobre como criar cÃ³digo apto para o propÃ³sito, usando uma abordagem orientada a testes e evoluindo o cÃ³digo anterior Ã  medida que avanÃ§amos em nosso entendimento do domÃ­nio do problema, um processo denominado ** descoberta **. Todo o cÃ³digo produzido atÃ© agora foi armazenado em Github. VocÃª pode fazer um fork e usÃ¡-lo da maneira que quiser. Para obter a versÃ£o exata deste cÃ³digo, use esta tag. No prÃ³ximo artigo, comeÃ§aremos a analisar elementos de classe como construtores, campos e mÃ©todos. Estaremos ainda mais focados, lidando apenas com as estruturas de cÃ³digo que aparecem no cÃ³digo e, com sorte, poderemos terminar de analisar nossa primeira classe. Vejo vocÃª na prÃ³xima vez!" /> <link rel="canonical" href="https://blog.brunobrant.net/parsing-code-with-sprache-part-2/" /> <meta property="og:url" content="https://blog.brunobrant.net/parsing-code-with-sprache-part-2/" /> <meta property="og:site_name" content="TECHNOLOGY MATTERS" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2021-03-13T00:00:00+00:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Parsing Code With Sprache Part 2" /> <script type="application/ld+json"> {"datePublished":"2021-03-13T00:00:00+00:00","description":"ğŸ˜ Este Ã© o segundo artigo de uma sÃ©rie de partes mÃºltiplas sobre como analisar cÃ³digo com Sprache. VocÃª pode ler a primeira parte aqui. No post anterior, vimos como analisar algum texto (em particular, cÃ³digo Java) usando Sprache, uma poderosa biblioteca para C#. Vimos como usar uma abordagem incremental e como usar testes unitÃ¡rios para conduzir o desenvolvimento com esta ferramenta. AtÃ© agora, escrevemos um analisador para Identifier e PackageName (verifique aqui). Agora vamos avanÃ§ar um pouco mais rÃ¡pido. Lembre-se de que temos como alvo o source Java/Android Google Authenticator e que nosso objetivo final Ã© gerar um grÃ¡fico de dependÃªncias de classe para este projeto. Neste artigo, vamos tentar analisar todos os elementos de nÃ­vel superior do arquivo atual em que estamos trabalhando, AuthenticatorActivity.java. â— Em todo o cÃ³digo do blog, eliminei a documentaÃ§Ã£o interna para maior clareza. Verifique o repo para ver os comentÃ¡rios. Refatorando nosso caminho para o sucesso Antes de incrementar o cÃ³digo atual, identifiquei um pequeno ajuste que nos ajudarÃ¡ na prÃ³xima etapa. Veja, o analisador PackageName estÃ¡, na verdade, analisando uma instruÃ§Ã£o package (package statement). Nomes de pacotes sÃ£o usados â€‹â€‹em outros lugares, portanto, facilitaremos a reutilizaÃ§Ã£o extraindo um PackageName do analisador atual. Primeiro, renomeie o analisador JavaGrammar.PackageName para JavaGrammar.PackageStament, o nome correto para o que estÃ¡ analisando; use suas ferramentas de refatoraÃ§Ã£o de IDE para isso. VocÃª tambÃ©m precisa renomear a unidade de teste anterior de PackageNameParserTests para PackageStatementParserTests para manter as coisas coerentes. A seguir, vamos extrair a anÃ¡lise de um PackageName de JavaGrammar.PackageStament. Veja as linhas abaixo: public static readonly Parser&lt;PackageName&gt; PackageStatement = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() // â†“â†“â†“â†“â†“â†“â†“ Parsing of Package Name â†“â†“â†“â†“â†“â†“â†“ from packageHead in Identifier from packageTail in (from delimiter in Sprache.Parse.Char(&#39;.&#39;).Once() from identifier in Identifier select identifier).Many() // â†‘â†‘â†‘â†‘â†‘â†‘â†‘ Parsing of Package Name â†‘â†‘â†‘â†‘â†‘â†‘â†‘ from terminator in Sprache.Parse.Char(&#39;;&#39;) // â†“â†“â†“â†“â†“â†“â†“ And this is how the result is build â†“â†“â†“â†“â†“â†“â†“ select new PackageName(new[] { packageHead }.Concat(packageTail).ToList()); // â†‘â†‘â†‘â†‘â†‘â†‘â†‘ And this is how the result is build â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘ Vamos extrair isso em um analisador isolado, este na verdade chamado PackageName: public static readonly Parser&lt;PackageName&gt; PackageName = from packageHead in Identifier from packageTail in (from delimiter in Sprache.Parse.Char(&#39;.&#39;).Once() from identifier in Identifier select identifier).Many() select new PackageName(new[] { packageHead }.Concat(packageTail).ToList()); Precisamos criar uma estrutura para representar a instruÃ§Ã£o package: public class PackageStatement { public PackageStatement(PackageName packageName) { PackageName = packageName; } public PackageName PackageName { get; } } Vamos atualizar o analisador PackageStatement para retornar a estrutura, usando o analisador PackageName: public static readonly Parser&lt;PackageName&gt; PackageStatement = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() from packageName in PackageName from terminator in Sprache.Parse.Char(&#39;;&#39;) select packageName; Execute todos os testes e vocÃª descobrirÃ¡ que tudo estÃ¡ funcionando como deveria. Esta refatoraÃ§Ã£o foi confirmada sob a tag Refactor_PackageName. Analisando mais estruturas Vamos voltar Ã  criaÃ§Ã£o de novos analisadores. A prÃ³xima estrutura natural Ã© uma declaraÃ§Ã£o de importaÃ§Ã£o que tem o seguinte BNF: DeclaraÃ§Ã£o de importaÃ§Ã£o IMPORT = &quot;import&quot;, PACKAGE_NAME, &quot;;&quot;; Vamos comeÃ§ar atualizando nossa classe Import anterior. Mude seu nome de Import para ImportStatement, que Ã© mais exato. Use sua ferramenta de refatoraÃ§Ã£o IDE para renomear a classe. Eu tambÃ©m criei um construtor para ela que inicializa o PackageName: public class ImportStatement { public ImportStatement(PackageName packageName) { PackageName = packageName; } public PackageName PackageName { get; } } Agora, vamos criar um teste para isso: ğŸ˜ Estou criando um arquivo de teste para cada analisador, embora eles (atualmente) sejam todos parte da mesma classe. Isso nÃ£o Ã© padrÃ£o; Ã© a melhor prÃ¡tica ter uma classe de teste de unidade por classe. Entretanto, fazer dessa forma torna mais fÃ¡cil localizar os testes e nos permite mantÃª-los mais organizados. public class ImportStatementParserTests { [Theory] [InlineData(&quot;import android.annotation.TargetApi;&quot;)] [InlineData(&quot;import android.app.Activity;&quot;)] public void Parse_WhenValidPackageName_ReturnsStructureWithCorrectName(string importStatement) { var actual = JavaGrammar.ImportStatement.Parse(importStatement); Assert.Equal(packageName, string.Join(&#39;.&#39;, actual.PackageName.Identifiers)); } } Usamos as primeiras instruÃ§Ãµes de import de AuthenticatorActivity, como vocÃª pode ver. TambÃ©m estamos fazendo um join dos identificadores assim como fizemos da Ãºltima vez, o que Ã© um pouco tedioso; vamos melhorar isso na etapa de refatorar. A execuÃ§Ã£o desse teste levarÃ¡ a ğŸ”´, pois o cÃ³digo nÃ£o foi implementado. Vamos escrever o analisador agora: public static readonly Parser&lt;ImportStatement&gt; ImportStatement = from importKeyword in Parse.String(&quot;import&quot;).Token() from packageName in PackageName.Token() from delimiter in Parse.Char(&#39;;&#39;).Token() select new ImportStatement(packageName); Leitores Ã¡vidos notarÃ£o o mÃ©todo anteriormente nÃ£o visto Token() na segunda linha. Este Ã© um dos mÃ©todos mais Ãºteis no Sprache - removerÃ¡ os espaÃ§os em branco ao redor do caractere, mas * exigirÃ¡ * que ele esteja lÃ¡. Isso significa que, por exemplo, Parse.String(&quot;import&quot;).Token().Parse(&quot; import &quot;) funcionarÃ¡, mas Parse.String(&quot;import&quot;).Token().Parse(&quot; importasd &quot;) nÃ£o. O resto deve ser muito legÃ­vel - procure a palavra-chave import, depois uma estrutura PackageName e retorne uma instruÃ§Ã£o import. Execute todos os testes. VocÃª deve obter um ğŸŸ¢. Continuando, vamos refatorar um pouco. Lembra que eu disse que farÃ­amos algo sobre string.Join(&#39;.&#39;, actual.PackageName.Identifiers)? Agora Ã© a hora! A representaÃ§Ã£o de string de um nome de pacote, digamos, â€œandroid.content.ActivityNotFoundExceptionâ€ nÃ£o Ã© outro senÃ£o â€œandroid.content.ActivityNotFoundExceptionâ€. EntÃ£o, o que vocÃª acha de substituir PackageName.ToString para cumprir esse comportamento? public class PackageName { // ... public override string ToString() { return string.Join(&#39;.&#39;, Identifiers); } } ğŸ˜ DICA: Ao realizer um override em mÃ©todos e propriedades, use o xml doc /// &lt;inheritdoc /&gt; como documentaÃ§Ã£o. Agora, seguindo a mesma ideia, podemos adicionar uma substituiÃ§Ã£o de ToString em ImportStatement: public class ImportStatement { // ... public override string ToString() { return $&quot;import {PackageName};&quot;; } } Agora podemos atualizar nosso teste de unidade para refletir este refator: [Theory] [InlineData(&quot;import android.annotation.TargetApi;&quot;)] [InlineData(&quot;import android.app.Activity;&quot;)] public void Parse_WhenValidPackageName_ReturnsStructureWithCorrectName(string importStatement) { var actual = JavaGrammar.ImportStatement.Parse(importStatement); Assert.Equal(importStatement, actual.ToString()); } âš  Aviso: neste caso, a entrada Ã© formatada exatamente como a saÃ­da de ImportStatement.ToString. No entanto, se vocÃª analisar algo como &quot; import name.surname&quot;, enquanto a anÃ¡lise funcionarÃ¡, o ToString retornarÃ¡ &quot;import name.surname&quot;, sem espaÃ§os. Isso significa que a regra Token () nÃ£o estÃ¡ sendo testada em nossa suÃ­te - a razÃ£o para isso Ã© que ela nÃ£o aparece em nosso escopo - portanto, os testes sÃ£o um pouco frÃ¡geis e devem ser melhorados na maioria das circunstÃ¢ncias. NÃ£o vou fazer isso durante esses exercÃ­cios, mas os leitores devem definitivamente fazÃª-lo. Agora, precisamos ler um bloco de importaÃ§Ãµes em nosso arquivo. Chamamos isso de IMPORT_LIST no eBNF. A estrutura de dados para isso nÃ£o precisa ser mais do que List &lt;ImportStatement&gt;, mas precisamos de um analisador para isso. Comece com um teste: public class ImportListParserTests { public static IEnumerable&lt;object[]&gt; ImportLists() { yield return new string[] { @&quot; import com.google.android.apps.authenticator.util.EmptySpaceClickableDragSortListView; import com.google.android.apps.authenticator.util.annotations.FixWhenMinSdkVersion; import com.google.android.apps.authenticator2.R; import com.google.common.annotations.VisibleForTesting; &quot;.Trim(), }; yield return new string[] { @&quot; import android.support.v7.widget.Toolbar; import android.text.Html; import android.util.Log; import android.view.ActionMode; import android.view.ContextMenu; &quot;.Trim(), }; } [Theory] [MemberData(nameof(ImportLists))] public void Parse_WhenValidPackageName_ReturnsStructureWithCorrectName(string importList) { var expected = importList.Split(Environment.NewLine).ToList(); var actual = JavaGrammar.ImportList.Parse(importList); Assert.Equal(expected, actual.Select(_ =&gt; _.ToString())); } } A implementaÃ§Ã£o da lista Ã© simples: public static readonly Parser&lt;List&lt;ImportStatement&gt;&gt; ImportList = from statements in ImportStatement.Many().Token() select statements.ToList(); Agora que as importaÃ§Ãµes foram tratadas, vamos passar para a prÃ³xima estrutura de cÃ³digo em AuthenticatorActivity.java, uma anotaÃ§Ã£o. AnotaÃ§Ãµes A prÃ³xima estrutura de cÃ³digo em AuthenticatorActivity Ã© a declaraÃ§Ã£o da classe. Ele contÃ©m um trecho de cÃ³digo sobre o qual nÃ£o falamos antes, uma anotaÃ§Ã£o. As anotaÃ§Ãµes Java sÃ£o anÃ¡logas aos atributos C# e tÃªm a seguinte aparÃªncia: @FixWhenMinSdkVersion(11) Assim como no C#, essas estruturas sÃ³ podem aparecer antes das declaraÃ§Ãµes e, neste caso, Ã© uma declaraÃ§Ã£o de classe. Precisamos criar a estrutura de dados para acomodar isso e o analisador para produzi-la. Conforme mencionado anteriormente, estamos construindo interativamente o eBNF. Isso Ã© para tornar nosso analisador mais simples - apenas escrever o cÃ³digo necessÃ¡rio para as estruturas que estÃ£o presentes no cÃ³digo-fonte. Ã‰ por isso que a anotaÃ§Ã£o nÃ£o foi mencionada antes. Vamos atualizÃ¡-lo: ANNOTATION = &quot;@&quot;, IDENTIFIER, &quot;(&quot;, ARGUMENT_LIST, &quot;)&quot; ARGUMENT_LIST = ARGUMENT, { &quot;,&quot; ARGUMENT } ARGUMENT = LITERAL LITERAL = INTEGER_LITERAL O eBNF acima Ã© parcial; Por exemplo, a lista de argumentos para a anotaÃ§Ã£o Ã© mais complexa, permitindo outros tipos. Mas atÃ© agora sÃ³ temos o parÃ¢metro inteiro, entÃ£o vamos nos ater a ele. A primeira coisa Ã© definir a estrutura de dados de uma anotaÃ§Ã£o. Olhando para ele, vocÃª pode imaginar que tem um identificador como nome e, em seguida, a lista de argumentos. public interface ILiteral { object Value { get; } } public class IntegerLiteral : ILiteral { public IntegerLiteral(int value) { Value = value; } public int Value { get; } object ILiteral.Value =&gt; Value; public override string ToString() { return Value.ToString(); } } public class Annotation { public Annotation(string name, List&lt;ILiteral&gt; arguments) { Name = name; Arguments = arguments; } public string Name { get; } public List&lt;Argument&gt; Arguments { get; } public override string ToString() { return $&quot;@{Name}({string.Join(&quot;, &quot;, Arguments)})&quot;; } } Introduzimos um pouco de abstraÃ§Ã£o que pode nos poupar algum trabalho mais tarde - deixamos claro que literal pode ser muitas coisas, nÃ£o apenas inteiros. A conversÃ£o para a estrutura correta permitirÃ¡ que os usuÃ¡rios obtenham o valor digitado - caso contrÃ¡rio, por enquanto, encaixaremos o int e o retornamos como um objeto. Precisamos criar um analisador para essa nova estrutura - um literal inteiro. Testes: public class IntergerLiteralParserTests { [Theory] [InlineData(11)] public void MyTheory(int value) { var actual = JavaGrammar.IntegerLiteral.Parse(value.ToString()); Assert.Equal(value, actual.Value); } } E o analisador: public static readonly Parser&lt;IntegerLiteral&gt; IntegerLiteral = from digits in Parse.Digit.AtLeastOnce() let number = string.Concat(digits) let value = int.Parse(number) select new IntegerLiteral(value); Uma coisa no cÃ³digo acima que pode fazer vocÃª se perguntar Ã© o AtLeastOnce(). Isso Ã© muito prÃ³ximo de Many(), com a diferenÃ§a de que irÃ¡ falhar na anÃ¡lise quando nÃ£o houver pelo menos um Ãºnico dÃ­gito. Se nÃ£o aplicarmos isso aqui, o analisador aceitarÃ¡ uma lista de argumentos vazia. Agora vamos para a anotaÃ§Ã£o real. public class AnnotationParserTests { [Theory] [InlineData(&quot;@Number(11)&quot;, new object[] { 11 })] public void Parse_WhenAnnotationHasParameters_CorrectParameters(string annotation, object[] parameters) { var actual = JavaGrammar.Annotation.Parse(annotation); Assert.Equal(parameters, actual.Arguments.Cast&lt;object&gt;().ToArray()); } } â— Esses testes sÃ£o muito bÃ¡sicos; na maioria dos cenÃ¡rios de produÃ§Ã£o, sugiro escrever testes que tenham mais condiÃ§Ãµes; por exemplo, poderÃ­amos testar casos como @ SomeAnnotation, dividindo o cÃ³digo em duas linhas, etc. Observe o cÃ³digo que estÃ¡ sendo testado para encontrar lacunas ou riscos e crie os testes correspondentes. Finalmente, com TDD devemos escrever um teste por vez e evoluir iterativamente. A razÃ£o pela qual podemos nos safar com testes tÃ£o simples Ã© que sabemos com antecedÃªncia todo o cÃ³digo que precisa ser analisado, entÃ£o podemos testar novamente um caso real e verificar se surgem bugs, mas mesmo assim, eu teria cuidado onde isso nÃ£o apenas uma postagem no blog. A implementaÃ§Ã£o irÃ¡ alavancar o analisador IntegerLiteral que acabamos de codificar: public static readonly Parser&lt;Annotation&gt; Annotation = from at in Parse.Char(&#39;@&#39;).Once() from identifier in Identifier.Token() from startList in Parse.Char(&#39;(&#39;).Token() from literal in IntegerLiteral.Token().Optional() from endList in Parse.Char(&#39;)&#39;).Token() let arguments = literal.IsDefined ? new List&lt;ILiteral&gt; { literal.Get() } : new List&lt;ILiteral&gt;() select new Annotation(identifier, arguments); Novamente, podemos ver um analisador opcional sendo chamado. Para obter a lista real, precisamos fazer alguma ginÃ¡stica LINQ - retornar uma lista com um Ãºnico literal ou uma lista vazia. No futuro, provavelmente criaremos um analisador ArgumentList que deve substituir isso, mas atÃ© agora, nÃ£o hÃ¡ necessidade. Os testes devem ser ğŸŸ¢. DeclaraÃ§Ã£o de classe A prÃ³xima coisa no arquivo Ã© a definiÃ§Ã£o real da classe. Vamos decompÃ´-lo: @FixWhenMinSdkVersion (11) public class AuthenticatorActivity estende TestableActivity { // ... Este Ã© um bom exemplo porque, de cara, lidaremos com extends, um caso comum, mas nÃ£o basal. A anotaÃ§Ã£o jÃ¡ foi cuidada, entÃ£o vamos analisar a declaraÃ§Ã£o da classe: visibility â”‚ â”‚ identifier, class identifier, base class â”‚ â”‚ â”‚ â”Œâ”€â”€â”´â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â” public class AuthenticatorActivity extends TestableActivity â””â”€â”¬â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜ â”‚ interface inheritance keyword â”‚ class declaration keyword Portanto, precisamos expandir o EBNF: CLASS_DECLARATION = VISIBILITY, &quot;class&quot;, IDENTIFIER, { &quot;extends&quot;, IDENTIFIER }, &quot;{&quot;, (* ommited *), &quot;}&quot;; VISIBILITY = &quot;public&quot; â— NÃ£o estamos lidando com outras visibilidades apenas no momento, a nÃ£o ser para refletir nossa abordagem em evoluÃ§Ã£o. Ã€ medida que lidamos com mais casos, expandimos a definiÃ§Ã£o. Isso deve ser realmente simples, mas precisamos atualizar a estrutura da classe para refleti-la: public enum Visibility { Public, } public class ClassDefinition { public ClassDefinition(Visibility visibility, string name, string? baseClass = null, Annotation? annotation = null) { Visibility = visibility; Name = name; BaseClass = baseClass; Annotation = annotation; } public Visibility Visibility { get; } public string Name { get; } public string? BaseClass { get; } public Annotation? Annotation { get; } } Algumas coisas a serem observadas: estamos seguindo estritamente o trecho de cÃ³digo que estÃ¡ sendo processado, entÃ£o, embora haja um membro Visibility, o Ãºnico valor possÃ­vel Ã© Public; embora Java permita vÃ¡rias anotaÃ§Ãµes, estamos apenas considerando uma Ãºnica anotaÃ§Ã£o etc. O motivo pelo qual estou seguindo essa abordagem Ã© que ainda nÃ£o sabemos se esses casos surgirÃ£o dentro do cÃ³digo. Se o fizerem, iremos reescrever o cÃ³digo acima. Agora vamos criar nossos testes: public class ClassDefinitionParserTests { [Fact] public void Parse_AnnotatedClassWithExtends_CorrectParameters() { var code = @&quot; @FixWhenMinSdkVersion(11) public class AuthenticatorActivity extends TestableActivity &quot;.Trim(); var actual = JavaGrammar.ClassDefinition.Parse(code); Assert.Equal(&quot;FixWhenMinSdkVersion&quot;, actual.Annotation.Name); Assert.Equal(11, actual.Annotation.Arguments[0].Value); Assert.Equal(Visibility.Public, actual.Visibility); Assert.Equal(&quot;AuthenticatorActivity&quot;, actual.Name); Assert.Equal(&quot;TestableActivity&quot;, actual.BaseClass); } } Novamente, os testes lidam apenas com o que vimos atÃ© agora. Usei um Fact em vez de uma Theory porque estamos lidando apenas com um Ãºnico caso. Assim que tivermos mais casos para testar, vou convertÃª-lo em Theory. Ah! Estou testando o resultado da anÃ¡lise de anotaÃ§Ã£o, que na verdade estÃ¡ repetindo os testes jÃ¡ feitos no AnnotationParserTests. PoderÃ­amos fazer isso de forma um pouco diferente e apenas ter certeza de que o analisador correto foi chamado, mas por enquanto, vamos manter isso simples e repetir o teste. Agora, a implementaÃ§Ã£o, embora longa, Ã© simples, apenas analise cada fragmento que vimos na anÃ¡lise acima: public static readonly Parser&lt;ClassDefinition&gt; ClassDefinition = from annotation in Annotation.Token() from visibility in Parse.String(&quot;public&quot;).Token() from classKeyword in Parse.String(&quot;class&quot;).Token() from className in Identifier.Token() from extendsKeyword in Parse.String(&quot;extends&quot;).Token() from baseClassName in Identifier.Token() select new ClassDefinition(Visibility.Public, className, baseClassName, annotation); Eu cortei alguns cantos aqui, como analisar a visibilidade diretamente. TambÃ©m lidaremos com isso quando for necessÃ¡rio. FaÃ§a seus testes e aprecie seu ğŸŸ¢. Resumo Com este artigo, concluÃ­mos a primeira etapa: podemos analisar todos os elementos de nÃ­vel superior de um arquivo de origem Java. VocÃª aprendeu um pouco mais sobre como usar Sprache e combinar analisadores e provavelmente aprendeu algumas tÃ©cnicas sobre como criar cÃ³digo apto para o propÃ³sito, usando uma abordagem orientada a testes e evoluindo o cÃ³digo anterior Ã  medida que avanÃ§amos em nosso entendimento do domÃ­nio do problema, um processo denominado ** descoberta **. Todo o cÃ³digo produzido atÃ© agora foi armazenado em Github. VocÃª pode fazer um fork e usÃ¡-lo da maneira que quiser. Para obter a versÃ£o exata deste cÃ³digo, use esta tag. No prÃ³ximo artigo, comeÃ§aremos a analisar elementos de classe como construtores, campos e mÃ©todos. Estaremos ainda mais focados, lidando apenas com as estruturas de cÃ³digo que aparecem no cÃ³digo e, com sorte, poderemos terminar de analisar nossa primeira classe. Vejo vocÃª na prÃ³xima vez!","url":"https://blog.brunobrant.net/parsing-code-with-sprache-part-2/","@type":"BlogPosting","dateModified":"2021-03-13T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.brunobrant.net/parsing-code-with-sprache-part-2/"},"author":{"@type":"Person","name":"Bruno Brant"},"headline":"Parsing Code With Sprache Part 2","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <script> /* Toggle between adding and removing the "responsive" class to topnav when the user clicks on the icon */ function openNavigation() { const navigationElems = document.getElementsByClassName("navigation"); if (navigationElems.length != 1) { console.warn("Couldn't find navbar"); return; } const x = navigationElems[0]; if (x.className === "navigation") { x.className += " responsive"; } else { x.className = "navigation"; } } </script> <body> <div class="container content"> <header class="masthead"> <h3 class="masthead-title"> <a href="/pt/" title="Home" class="masthead-title-main">TECHNOLOGY MATTERS</a><br> <small>pensamentos desordenados sobre tecnologia, software, etc.</small> </h3> <!-- Change navigation links here --> <div class="navigation"> <ul id="navigation-list"> <li> <a href="/pt/">HOME</a> </li> <li> <a href="/pt/archive/">POSTS</a> </li> <li> <a href="/pt/tags/">TAGS</a> </li> <li> <a href="/pt/categories/">CATEGORIAS</a> </li> <li> <a href="/pt/about/">SOBRE</a> </li> <li id="subscribe"> <a href="/feed.xml"> <p>ASSINAR</p> <svg class="svg-icon grey" style="fill: #f66a0a;"> <use xlink:href="/assets/minima-social-icons.svg#rss"></use> </svg> </a> </li> </ul> <div style="float:right"> <a href="javascript:void(0);" class="navigation-icon" onclick="openNavigation()">â˜°</a> </div> </div> <!-- Language selector --> <div class="language-selector"> <span class="language-selector-label">ler esse site em:</span> <a href="/parsing-code-with-sprache-part-2/"><span>ğŸ‡ºğŸ‡¸</span></a> | <a href="/pt/parsing-code-with-sprache-part-2/"><span>ğŸ‡§ğŸ‡·</span></a> </div> </header> <main> <!-- Change navigation links here --> <article class="post"> <h1 class="post-title">Parsing Code With Sprache Part 2</h1> <time datetime="2021-03-13T00:00:00+00:00" class="post-date">March 13th, 2021 </time> <blockquote> <p>ğŸ˜ Este Ã© o segundo artigo de uma sÃ©rie de partes mÃºltiplas sobre <strong>como analisar cÃ³digo com Sprache</strong>. VocÃª pode ler a primeira parte <a href="2021-02-13-parsing-code-with-sprache">aqui</a>.</p> </blockquote> <p>No post anterior, vimos como analisar algum texto (em particular, cÃ³digo Java) usando <a href="https://github.com/sprache/Sprache" target="_blank" rel="noopener noreferrer">Sprache</a>, uma poderosa biblioteca para C#. Vimos como usar uma abordagem incremental e como usar testes unitÃ¡rios para conduzir o desenvolvimento com esta ferramenta. AtÃ© agora, escrevemos um analisador para <code class="language-plaintext highlighter-rouge">Identifier</code> e <code class="language-plaintext highlighter-rouge">PackageName</code> (verifique <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser/blob/c5f7f6ce78382ac47e8ab0d03ca43851425d1545/src/TinyJavaParser/JavaGram.cs" target="_blank" rel="noopener noreferrer">aqui</a>).</p> <p>Agora vamos avanÃ§ar um pouco mais rÃ¡pido. Lembre-se de que temos como alvo o source Java/Android <a href="https://github.com/google/google-authenticator-android/tree/master/java/com/google/android/apps/authenticator" target="_blank" rel="noopener noreferrer">Google Authenticator</a> e que nosso objetivo final Ã© gerar um grÃ¡fico de dependÃªncias de classe para este projeto. Neste artigo, vamos tentar analisar todos os elementos de nÃ­vel superior do arquivo atual em que estamos trabalhando, <a href="https://github.com/google/google-authenticator-android/blob/master/java/com/google/android/apps/authenticator/AuthenticatorActivity.java" target="_blank" rel="noopener noreferrer">AuthenticatorActivity.java</a>.</p> <blockquote> <p>â— Em todo o cÃ³digo do blog, eliminei a documentaÃ§Ã£o interna para maior clareza. Verifique o <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser" target="_blank" rel="noopener noreferrer">repo</a> para ver os comentÃ¡rios.</p> </blockquote> <h1 id="refatorando-nosso-caminho-para-o-sucesso">Refatorando nosso caminho para o sucesso</h1> <p>Antes de incrementar o cÃ³digo atual, identifiquei um pequeno ajuste que nos ajudarÃ¡ na prÃ³xima etapa. Veja, o analisador <code class="language-plaintext highlighter-rouge">PackageName</code> estÃ¡, na verdade, analisando uma <em>instruÃ§Ã£o package (package statement)</em>. Nomes de pacotes sÃ£o usados â€‹â€‹em outros lugares, portanto, facilitaremos a reutilizaÃ§Ã£o extraindo um <code class="language-plaintext highlighter-rouge">PackageName</code> do analisador atual.</p> <p>Primeiro, renomeie o analisador <code class="language-plaintext highlighter-rouge">JavaGrammar.PackageName</code> para <code class="language-plaintext highlighter-rouge">JavaGrammar.PackageStament</code>, o nome correto para o que estÃ¡ analisando; use suas ferramentas de refatoraÃ§Ã£o de IDE para isso. VocÃª tambÃ©m precisa renomear a unidade de teste anterior de <code class="language-plaintext highlighter-rouge">PackageNameParserTests</code> para <code class="language-plaintext highlighter-rouge">PackageStatementParserTests</code> para manter as coisas coerentes.</p> <p>A seguir, vamos extrair a anÃ¡lise de um <code class="language-plaintext highlighter-rouge">PackageName</code> de <code class="language-plaintext highlighter-rouge">JavaGrammar.PackageStament</code>. Veja as linhas abaixo:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">PackageStatement</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
	<span class="c1">// â†“â†“â†“â†“â†“â†“â†“ Parsing of Package Name â†“â†“â†“â†“â†“â†“â†“</span>
	<span class="k">from</span> <span class="n">packageHead</span> <span class="k">in</span> <span class="n">Identifier</span>
	<span class="k">from</span> <span class="n">packageTail</span> <span class="k">in</span> <span class="p">(</span><span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'.'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
							<span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">Identifier</span>
							<span class="k">select</span> <span class="n">identifier</span><span class="p">).</span><span class="nf">Many</span><span class="p">()</span>
	<span class="c1">// â†‘â†‘â†‘â†‘â†‘â†‘â†‘ Parsing of Package Name â†‘â†‘â†‘â†‘â†‘â†‘â†‘</span>
	<span class="k">from</span> <span class="n">terminator</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
	<span class="c1">// â†“â†“â†“â†“â†“â†“â†“ And this is how the result is build â†“â†“â†“â†“â†“â†“â†“</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">PackageName</span><span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="n">packageHead</span> <span class="p">}.</span><span class="nf">Concat</span><span class="p">(</span><span class="n">packageTail</span><span class="p">).</span><span class="nf">ToList</span><span class="p">());</span>
	<span class="c1">// â†‘â†‘â†‘â†‘â†‘â†‘â†‘ And this is how the result is build â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘</span>
</code></pre></div></div> <p>Vamos extrair isso em um analisador isolado, este na verdade chamado <code class="language-plaintext highlighter-rouge">PackageName</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">PackageName</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">packageHead</span> <span class="k">in</span> <span class="n">Identifier</span>
	<span class="k">from</span> <span class="n">packageTail</span> <span class="k">in</span> <span class="p">(</span><span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'.'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
						 <span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">Identifier</span>
						 <span class="k">select</span> <span class="n">identifier</span><span class="p">).</span><span class="nf">Many</span><span class="p">()</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">PackageName</span><span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="n">packageHead</span> <span class="p">}.</span><span class="nf">Concat</span><span class="p">(</span><span class="n">packageTail</span><span class="p">).</span><span class="nf">ToList</span><span class="p">());</span>
</code></pre></div></div> <p>Precisamos criar uma estrutura para representar a <em>instruÃ§Ã£o package</em>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageStatement</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">PackageStatement</span><span class="p">(</span><span class="n">PackageName</span> <span class="n">packageName</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">PackageName</span> <span class="p">=</span> <span class="n">packageName</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">PackageName</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Vamos atualizar o analisador <code class="language-plaintext highlighter-rouge">PackageStatement</code> para retornar a estrutura, usando o analisador<code class="language-plaintext highlighter-rouge"> PackageName</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">PackageStatement</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">packageName</span> <span class="k">in</span> <span class="n">PackageName</span>
	<span class="k">from</span> <span class="n">terminator</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
	<span class="k">select</span> <span class="n">packageName</span><span class="p">;</span>
</code></pre></div></div> <p>Execute todos os testes e vocÃª descobrirÃ¡ que tudo estÃ¡ funcionando como deveria. Esta refatoraÃ§Ã£o foi confirmada sob a tag <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser/tree/Refactor_PackageName" target="_blank" rel="noopener noreferrer">Refactor_PackageName</a>.</p> <h1 id="analisando-mais-estruturas">Analisando mais estruturas</h1> <p>Vamos voltar Ã  criaÃ§Ã£o de novos analisadores. A prÃ³xima estrutura natural Ã© uma declaraÃ§Ã£o de importaÃ§Ã£o que tem o seguinte BNF:</p> <h2 id="declaraÃ§Ã£o-de-importaÃ§Ã£o">DeclaraÃ§Ã£o de importaÃ§Ã£o</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IMPORT = "import", PACKAGE_NAME, ";";
</code></pre></div></div> <p>Vamos comeÃ§ar atualizando nossa classe <code class="language-plaintext highlighter-rouge">Import</code> anterior. Mude seu nome de <code class="language-plaintext highlighter-rouge">Import</code> para <code class="language-plaintext highlighter-rouge">ImportStatement</code>, que Ã© mais exato. <strong>Use sua ferramenta de refatoraÃ§Ã£o IDE para renomear a classe.</strong> Eu tambÃ©m criei um construtor para ela que inicializa o <code class="language-plaintext highlighter-rouge">PackageName</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ImportStatement</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">ImportStatement</span><span class="p">(</span><span class="n">PackageName</span> <span class="n">packageName</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">PackageName</span> <span class="p">=</span> <span class="n">packageName</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">PackageName</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Agora, vamos criar um teste para isso:</p> <blockquote> <p>ğŸ˜ Estou criando um arquivo de teste para cada analisador, embora eles (atualmente) sejam todos parte da mesma classe. Isso nÃ£o Ã© <em>padrÃ£o</em>; Ã© a melhor prÃ¡tica ter uma classe de teste de unidade <em>por classe</em>. Entretanto, fazer dessa forma torna mais fÃ¡cil localizar os testes e nos permite mantÃª-los mais organizados.</p> </blockquote> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ImportStatementParserTests</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
	<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"import android.annotation.TargetApi;"</span><span class="p">)]</span>
	<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"import android.app.Activity;"</span><span class="p">)]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackageName_ReturnsStructureWithCorrectName</span><span class="p">(</span><span class="kt">string</span> <span class="n">importStatement</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">ImportStatement</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">importStatement</span><span class="p">);</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">packageName</span><span class="p">,</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">PackageName</span><span class="p">.</span><span class="n">Identifiers</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Usamos as primeiras instruÃ§Ãµes de <code class="language-plaintext highlighter-rouge">import</code> de <code class="language-plaintext highlighter-rouge">AuthenticatorActivity</code>, como vocÃª pode ver. TambÃ©m estamos fazendo um <code class="language-plaintext highlighter-rouge">join</code> dos identificadores assim como fizemos da Ãºltima vez, o que Ã© um pouco tedioso; vamos melhorar isso na etapa de <em>refatorar</em>.</p> <p>A execuÃ§Ã£o desse teste levarÃ¡ a ğŸ”´, pois o cÃ³digo nÃ£o foi implementado. Vamos escrever o analisador agora:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">ImportStatement</span><span class="p">&gt;</span> <span class="n">ImportStatement</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">importKeyword</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"import"</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">packageName</span> <span class="k">in</span> <span class="n">PackageName</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">ImportStatement</span><span class="p">(</span><span class="n">packageName</span><span class="p">);</span>
</code></pre></div></div> <p>Leitores Ã¡vidos notarÃ£o o mÃ©todo anteriormente nÃ£o visto <code class="language-plaintext highlighter-rouge">Token()</code> na segunda linha. Este Ã© um dos mÃ©todos mais Ãºteis no Sprache - removerÃ¡ os espaÃ§os em branco ao redor do caractere, mas * exigirÃ¡ * que ele esteja lÃ¡. Isso significa que, por exemplo, <code class="language-plaintext highlighter-rouge">Parse.String("import").Token().Parse(" import ")</code> funcionarÃ¡, mas <code class="language-plaintext highlighter-rouge">Parse.String("import").Token().Parse(" importasd ")</code> nÃ£o.</p> <p>O resto deve ser muito legÃ­vel - procure a palavra-chave <code class="language-plaintext highlighter-rouge">import</code>, depois uma estrutura PackageName e retorne uma instruÃ§Ã£o import. <strong>Execute todos os testes.</strong> VocÃª deve obter um ğŸŸ¢.</p> <p>Continuando, vamos refatorar um pouco. Lembra que eu disse que farÃ­amos algo sobre <code class="language-plaintext highlighter-rouge">string.Join('.', actual.PackageName.Identifiers)</code>? Agora Ã© a hora!</p> <p>A representaÃ§Ã£o de string de um nome de pacote, digamos, â€œandroid.content.ActivityNotFoundExceptionâ€ nÃ£o Ã© outro senÃ£o â€œandroid.content.ActivityNotFoundExceptionâ€. EntÃ£o, o que vocÃª acha de substituir <code class="language-plaintext highlighter-rouge">PackageName.ToString</code> para cumprir esse comportamento?</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageName</span>
<span class="p">{</span>
	<span class="c1">// ...</span>

	<span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span> <span class="n">Identifiers</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>ğŸ˜ <strong>DICA:</strong> Ao realizer um <code class="language-plaintext highlighter-rouge">override</code> em mÃ©todos e propriedades, use o xml doc <code class="language-plaintext highlighter-rouge">/// &lt;inheritdoc /&gt;</code> como documentaÃ§Ã£o.</p> </blockquote> <p>Agora, seguindo a mesma ideia, podemos adicionar uma substituiÃ§Ã£o de <code class="language-plaintext highlighter-rouge">ToString</code> em <code class="language-plaintext highlighter-rouge">ImportStatement</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ImportStatement</span>
<span class="p">{</span>
	<span class="c1">// ...</span>

	<span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="s">$"import </span><span class="p">{</span><span class="n">PackageName</span><span class="p">}</span><span class="s">;"</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Agora podemos atualizar nosso teste de unidade para refletir este refator:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"import android.annotation.TargetApi;"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"import android.app.Activity;"</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackageName_ReturnsStructureWithCorrectName</span><span class="p">(</span><span class="kt">string</span> <span class="n">importStatement</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">ImportStatement</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">importStatement</span><span class="p">);</span>

	<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">importStatement</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="nf">ToString</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>âš  <strong>Aviso</strong>: neste caso, a entrada Ã© formatada exatamente como a saÃ­da de <code class="language-plaintext highlighter-rouge">ImportStatement.ToString</code>. No entanto, se vocÃª analisar algo como <code class="language-plaintext highlighter-rouge">" import name.surname"</code>, enquanto a anÃ¡lise funcionarÃ¡, o <code class="language-plaintext highlighter-rouge">ToString</code> retornarÃ¡ <code class="language-plaintext highlighter-rouge">"import name.surname"</code>, sem espaÃ§os. Isso significa que a regra <code class="language-plaintext highlighter-rouge">Token ()</code> nÃ£o estÃ¡ sendo testada em nossa suÃ­te - a razÃ£o para isso Ã© que ela nÃ£o aparece em nosso escopo - portanto, os testes sÃ£o um pouco frÃ¡geis e devem ser melhorados na maioria das circunstÃ¢ncias. NÃ£o vou fazer isso durante esses exercÃ­cios, mas os leitores devem definitivamente fazÃª-lo.</p> </blockquote> <p>Agora, precisamos ler um bloco de importaÃ§Ãµes em nosso arquivo. Chamamos isso de IMPORT_LIST no eBNF. A estrutura de dados para isso nÃ£o precisa ser mais do que <code class="language-plaintext highlighter-rouge">List &lt;ImportStatement&gt;</code>, mas precisamos de um analisador para isso. Comece com um teste:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ImportListParserTests</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">[</span><span class="k">]&gt;</span> <span class="nf">ImportLists</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">string</span><span class="p">[]</span>
		<span class="p">{</span>
			<span class="s">@"
import com.google.android.apps.authenticator.util.EmptySpaceClickableDragSortListView;
import com.google.android.apps.authenticator.util.annotations.FixWhenMinSdkVersion;
import com.google.android.apps.authenticator2.R;
import com.google.common.annotations.VisibleForTesting;
			"</span><span class="p">.</span><span class="nf">Trim</span><span class="p">(),</span>
		<span class="p">};</span>

		<span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">string</span><span class="p">[]</span>
		<span class="p">{</span>
			<span class="s">@"
import android.support.v7.widget.Toolbar;
import android.text.Html;
import android.util.Log;
import android.view.ActionMode;
import android.view.ContextMenu;
			"</span><span class="p">.</span><span class="nf">Trim</span><span class="p">(),</span>
		<span class="p">};</span>
	<span class="p">}</span>

	<span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
	<span class="p">[</span><span class="nf">MemberData</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">ImportLists</span><span class="p">))]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackageName_ReturnsStructureWithCorrectName</span><span class="p">(</span><span class="kt">string</span> <span class="n">importList</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">expected</span> <span class="p">=</span> <span class="n">importList</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">).</span><span class="nf">ToList</span><span class="p">();</span>
		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">ImportList</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">importList</span><span class="p">);</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span> <span class="n">_</span><span class="p">.</span><span class="nf">ToString</span><span class="p">()));</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>A implementaÃ§Ã£o da lista Ã© simples:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">ImportStatement</span><span class="p">&gt;&gt;</span> <span class="n">ImportList</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">statements</span> <span class="k">in</span> <span class="n">ImportStatement</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">select</span> <span class="n">statements</span><span class="p">.</span><span class="nf">ToList</span><span class="p">();</span>
</code></pre></div></div> <p>Agora que as importaÃ§Ãµes foram tratadas, vamos passar para a prÃ³xima estrutura de cÃ³digo em <code class="language-plaintext highlighter-rouge">AuthenticatorActivity.java</code>, uma <em>anotaÃ§Ã£o</em>.</p> <h2 id="anotaÃ§Ãµes">AnotaÃ§Ãµes</h2> <p>A prÃ³xima estrutura de cÃ³digo em <code class="language-plaintext highlighter-rouge">AuthenticatorActivity</code> Ã© a declaraÃ§Ã£o da classe. Ele contÃ©m um trecho de cÃ³digo sobre o qual nÃ£o falamos antes, uma anotaÃ§Ã£o.</p> <p>As anotaÃ§Ãµes Java sÃ£o anÃ¡logas aos atributos C# e tÃªm a seguinte aparÃªncia:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FixWhenMinSdkVersion</span><span class="o">(</span><span class="mi">11</span><span class="o">)</span>
</code></pre></div></div> <p>Assim como no C#, essas estruturas sÃ³ podem aparecer antes das declaraÃ§Ãµes e, neste caso, Ã© uma declaraÃ§Ã£o de classe. Precisamos criar a estrutura de dados para acomodar isso e o analisador para produzi-la.</p> <p>Conforme mencionado anteriormente, estamos construindo interativamente o eBNF. Isso Ã© para tornar nosso analisador mais simples - apenas escrever o cÃ³digo necessÃ¡rio para as estruturas que estÃ£o presentes no cÃ³digo-fonte. Ã‰ por isso que a anotaÃ§Ã£o nÃ£o foi mencionada antes. Vamos atualizÃ¡-lo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ANNOTATION = "@", IDENTIFIER, "(", ARGUMENT_LIST, ")"

ARGUMENT_LIST = ARGUMENT, { "," ARGUMENT }

ARGUMENT = LITERAL

LITERAL = INTEGER_LITERAL
</code></pre></div></div> <p><strong>O eBNF acima Ã© parcial</strong>; Por exemplo, a lista de argumentos para a anotaÃ§Ã£o Ã© mais complexa, permitindo outros tipos. Mas atÃ© agora sÃ³ temos o parÃ¢metro inteiro, entÃ£o vamos nos ater a ele.</p> <p>A primeira coisa Ã© definir a estrutura de dados de uma anotaÃ§Ã£o. Olhando para ele, vocÃª pode imaginar que tem um identificador como nome e, em seguida, a lista de argumentos.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">interface</span> <span class="nc">ILiteral</span>
<span class="p">{</span>
	<span class="kt">object</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">IntegerLiteral</span>  <span class="p">:</span> <span class="n">ILiteral</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">IntegerLiteral</span><span class="p">(</span><span class="kt">int</span> <span class="k">value</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="n">Value</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> 

	<span class="kt">object</span> <span class="n">ILiteral</span><span class="p">.</span><span class="n">Value</span> <span class="p">=&gt;</span> <span class="n">Value</span><span class="p">;</span>

	<span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">Value</span><span class="p">.</span><span class="nf">ToString</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Annotation</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">Annotation</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ILiteral</span><span class="p">&gt;</span> <span class="n">arguments</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Name</span> <span class="p">=</span> <span class="n">name</span><span class="p">;</span>
		<span class="n">Arguments</span> <span class="p">=</span> <span class="n">arguments</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

	<span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Argument</span><span class="p">&gt;</span> <span class="n">Arguments</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

	<span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="s">$"@</span><span class="p">{</span><span class="n">Name</span><span class="p">}</span><span class="s">(</span><span class="p">{</span><span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="s">", "</span><span class="p">,</span> <span class="n">Arguments</span><span class="p">)}</span><span class="s">)"</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Introduzimos um pouco de abstraÃ§Ã£o que pode nos poupar algum trabalho mais tarde - deixamos claro que literal pode ser muitas coisas, nÃ£o apenas inteiros. A conversÃ£o para a estrutura correta permitirÃ¡ que os usuÃ¡rios obtenham o valor digitado - caso contrÃ¡rio, por enquanto, encaixaremos o int e o retornamos como um objeto.</p> <p>Precisamos criar um analisador para essa nova estrutura - um literal inteiro.</p> <p>Testes:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">IntergerLiteralParserTests</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
	<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="m">11</span><span class="p">)]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">MyTheory</span><span class="p">(</span><span class="kt">int</span> <span class="k">value</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">IntegerLiteral</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="k">value</span><span class="p">.</span><span class="nf">ToString</span><span class="p">());</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="k">value</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>E o analisador:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">IntegerLiteral</span><span class="p">&gt;</span> <span class="n">IntegerLiteral</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">digits</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="n">Digit</span><span class="p">.</span><span class="nf">AtLeastOnce</span><span class="p">()</span>
	<span class="k">let</span> <span class="n">number</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Concat</span><span class="p">(</span><span class="n">digits</span><span class="p">)</span>
	<span class="k">let</span> <span class="k">value</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">IntegerLiteral</span><span class="p">(</span><span class="k">value</span><span class="p">);</span>
</code></pre></div></div> <p>Uma coisa no cÃ³digo acima que pode fazer vocÃª se perguntar Ã© o <code class="language-plaintext highlighter-rouge">AtLeastOnce()</code>. Isso Ã© muito prÃ³ximo de <code class="language-plaintext highlighter-rouge">Many()</code>, com a diferenÃ§a de que irÃ¡ falhar na anÃ¡lise quando nÃ£o houver pelo menos um Ãºnico dÃ­gito. Se nÃ£o aplicarmos isso aqui, o analisador aceitarÃ¡ uma lista de argumentos vazia.</p> <p>Agora vamos para a anotaÃ§Ã£o real.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">AnnotationParserTests</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
	<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"@Number(11)"</span><span class="p">,</span> <span class="k">new</span> <span class="kt">object</span><span class="p">[]</span> <span class="p">{</span> <span class="m">11</span> <span class="p">})]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenAnnotationHasParameters_CorrectParameters</span><span class="p">(</span><span class="kt">string</span> <span class="n">annotation</span><span class="p">,</span> <span class="kt">object</span><span class="p">[]</span> <span class="n">parameters</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">Annotation</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">annotation</span><span class="p">);</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Arguments</span><span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;().</span><span class="nf">ToArray</span><span class="p">());</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>â— Esses testes sÃ£o muito bÃ¡sicos; na maioria dos cenÃ¡rios de produÃ§Ã£o, sugiro escrever testes que tenham mais condiÃ§Ãµes; por exemplo, poderÃ­amos testar casos como <code class="language-plaintext highlighter-rouge">@ SomeAnnotation</code>, dividindo o cÃ³digo em duas linhas, etc. Observe o cÃ³digo que estÃ¡ sendo testado para encontrar lacunas ou riscos e crie os testes correspondentes. Finalmente, com TDD devemos escrever um teste por vez e evoluir iterativamente.</p> <p>A razÃ£o pela qual podemos nos safar com testes tÃ£o simples Ã© que sabemos com antecedÃªncia todo o cÃ³digo que precisa ser analisado, entÃ£o podemos testar novamente um caso real e verificar se surgem bugs, mas mesmo assim, eu teria cuidado onde isso nÃ£o apenas uma postagem no blog.</p> </blockquote> <p>A implementaÃ§Ã£o irÃ¡ alavancar o analisador <code class="language-plaintext highlighter-rouge">IntegerLiteral</code> que acabamos de codificar:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">Annotation</span><span class="p">&gt;</span> <span class="n">Annotation</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">at</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'@'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">Identifier</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">startList</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'('</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">literal</span> <span class="k">in</span> <span class="n">IntegerLiteral</span><span class="p">.</span><span class="nf">Token</span><span class="p">().</span><span class="nf">Optional</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">endList</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">')'</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">let</span> <span class="n">arguments</span> <span class="p">=</span> <span class="n">literal</span><span class="p">.</span><span class="n">IsDefined</span>
		<span class="p">?</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ILiteral</span><span class="p">&gt;</span> <span class="p">{</span> <span class="n">literal</span><span class="p">.</span><span class="nf">Get</span><span class="p">()</span> <span class="p">}</span>
		<span class="p">:</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ILiteral</span><span class="p">&gt;()</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">Annotation</span><span class="p">(</span><span class="n">identifier</span><span class="p">,</span> <span class="n">arguments</span><span class="p">);</span>
</code></pre></div></div> <p>Novamente, podemos ver um analisador opcional sendo chamado. Para obter a lista real, precisamos fazer alguma ginÃ¡stica LINQ - retornar uma lista com um Ãºnico literal ou uma lista vazia. No futuro, provavelmente criaremos um analisador <code class="language-plaintext highlighter-rouge">ArgumentList</code> que deve substituir isso, mas atÃ© agora, nÃ£o hÃ¡ necessidade.</p> <p>Os testes devem ser ğŸŸ¢.</p> <h2 id="declaraÃ§Ã£o-de-classe">DeclaraÃ§Ã£o de classe</h2> <p>A prÃ³xima coisa no arquivo Ã© a definiÃ§Ã£o real da classe. Vamos decompÃ´-lo:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FixWhenMinSdkVersion</span> <span class="o">(</span><span class="mi">11</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AuthenticatorActivity</span> <span class="n">estende</span> <span class="nc">TestableActivity</span> <span class="o">{</span>
<span class="c1">// ...</span>
</code></pre></div></div> <p>Este Ã© um bom exemplo porque, de cara, lidaremos com <code class="language-plaintext highlighter-rouge">extends</code>, um caso comum, mas nÃ£o basal. A anotaÃ§Ã£o jÃ¡ foi cuidada, entÃ£o vamos analisar a declaraÃ§Ã£o da classe:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>visibility
   â”‚
   â”‚          identifier, class          identifier, base class
   â”‚                   â”‚                          â”‚
â”Œâ”€â”€â”´â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
public class AuthenticatorActivity extends TestableActivity 
       â””â”€â”¬â”€â”˜                       â””â”€â”€â”¬â”€â”€â”˜
         â”‚             interface inheritance keyword
         â”‚
class declaration keyword
</code></pre></div></div> <p>Portanto, precisamos expandir o EBNF:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CLASS_DECLARATION = VISIBILITY, "class", IDENTIFIER, { "extends", IDENTIFIER }, "{", (* ommited *), "}";

VISIBILITY = "public" 
</code></pre></div></div> <blockquote> <p>â— NÃ£o estamos lidando com outras visibilidades apenas no momento, a nÃ£o ser para refletir nossa abordagem em evoluÃ§Ã£o. Ã€ medida que lidamos com mais casos, expandimos a definiÃ§Ã£o.</p> </blockquote> <p>Isso deve ser realmente simples, mas precisamos atualizar a estrutura da classe para refleti-la:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">enum</span> <span class="n">Visibility</span>
<span class="p">{</span>
	<span class="n">Public</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">ClassDefinition</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">ClassDefinition</span><span class="p">(</span><span class="n">Visibility</span> <span class="n">visibility</span><span class="p">,</span> <span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">string</span><span class="p">?</span> <span class="n">baseClass</span> <span class="p">=</span> <span class="k">null</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">?</span> <span class="n">annotation</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Visibility</span> <span class="p">=</span> <span class="n">visibility</span><span class="p">;</span>
		<span class="n">Name</span> <span class="p">=</span> <span class="n">name</span><span class="p">;</span>
		<span class="n">BaseClass</span> <span class="p">=</span> <span class="n">baseClass</span><span class="p">;</span>
		<span class="n">Annotation</span> <span class="p">=</span> <span class="n">annotation</span><span class="p">;</span>
	<span class="p">}</span>

		<span class="k">public</span> <span class="n">Visibility</span> <span class="n">Visibility</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

		<span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

		<span class="k">public</span> <span class="kt">string</span><span class="p">?</span> <span class="n">BaseClass</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

		<span class="k">public</span> <span class="n">Annotation</span><span class="p">?</span> <span class="n">Annotation</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Algumas coisas a serem observadas: estamos seguindo estritamente o trecho de cÃ³digo que estÃ¡ sendo processado, entÃ£o, embora haja um membro Visibility, o Ãºnico valor possÃ­vel Ã© <code class="language-plaintext highlighter-rouge">Public</code>; embora Java permita vÃ¡rias anotaÃ§Ãµes, estamos apenas considerando uma Ãºnica anotaÃ§Ã£o etc. O motivo pelo qual estou seguindo essa abordagem Ã© que ainda nÃ£o sabemos se esses casos surgirÃ£o dentro do cÃ³digo. Se o fizerem, iremos reescrever o cÃ³digo acima.</p> <p>Agora vamos criar nossos testes:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ClassDefinitionParserTests</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_AnnotatedClassWithExtends_CorrectParameters</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">code</span> <span class="p">=</span> <span class="s">@"
@FixWhenMinSdkVersion(11)
public class AuthenticatorActivity extends TestableActivity
"</span><span class="p">.</span><span class="nf">Trim</span><span class="p">();</span>

		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">ClassDefinition</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">"FixWhenMinSdkVersion"</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Annotation</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="m">11</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Annotation</span><span class="p">.</span><span class="n">Arguments</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">Value</span><span class="p">);</span>
		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">Visibility</span><span class="p">.</span><span class="n">Public</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Visibility</span><span class="p">);</span>
		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">"AuthenticatorActivity"</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">"TestableActivity"</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">BaseClass</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Novamente, os testes lidam apenas com o que vimos atÃ© agora. Usei um <code class="language-plaintext highlighter-rouge">Fact</code> em vez de uma <code class="language-plaintext highlighter-rouge">Theory</code> porque estamos lidando apenas com um Ãºnico caso. Assim que tivermos mais casos para testar, vou convertÃª-lo em <code class="language-plaintext highlighter-rouge">Theory</code>.</p> <p>Ah! Estou testando o resultado da anÃ¡lise de anotaÃ§Ã£o, que na verdade estÃ¡ repetindo os testes jÃ¡ feitos no <code class="language-plaintext highlighter-rouge">AnnotationParserTests</code>. PoderÃ­amos fazer isso de forma um pouco diferente e apenas ter certeza de que o analisador correto foi chamado, mas por enquanto, vamos manter isso simples e repetir o teste.</p> <p>Agora, a implementaÃ§Ã£o, embora longa, Ã© simples, apenas analise cada fragmento que vimos na anÃ¡lise acima:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">ClassDefinition</span><span class="p">&gt;</span> <span class="n">ClassDefinition</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">annotation</span> <span class="k">in</span> <span class="n">Annotation</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">visibility</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"public"</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">classKeyword</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"class"</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">className</span> <span class="k">in</span> <span class="n">Identifier</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">extendsKeyword</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"extends"</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">baseClassName</span> <span class="k">in</span> <span class="n">Identifier</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">ClassDefinition</span><span class="p">(</span><span class="n">Visibility</span><span class="p">.</span><span class="n">Public</span><span class="p">,</span> <span class="n">className</span><span class="p">,</span> <span class="n">baseClassName</span><span class="p">,</span> <span class="n">annotation</span><span class="p">);</span>
</code></pre></div></div> <p>Eu cortei alguns cantos aqui, como analisar a visibilidade diretamente. TambÃ©m lidaremos com isso quando for necessÃ¡rio.</p> <p>FaÃ§a seus testes e aprecie seu ğŸŸ¢.</p> <h1 id="resumo">Resumo</h1> <p>Com este artigo, concluÃ­mos a primeira etapa: podemos analisar todos os elementos de nÃ­vel superior de um arquivo de origem Java. VocÃª aprendeu um pouco mais sobre como usar Sprache e combinar analisadores e provavelmente aprendeu algumas tÃ©cnicas sobre como criar cÃ³digo <em>apto para o propÃ³sito</em>, usando uma abordagem orientada a testes e evoluindo o cÃ³digo anterior Ã  medida que avanÃ§amos em nosso entendimento do domÃ­nio do problema, um processo denominado ** descoberta **.</p> <p>Todo o cÃ³digo produzido atÃ© agora foi armazenado em <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser" target="_blank" rel="noopener noreferrer">Github</a>. VocÃª pode fazer um fork e usÃ¡-lo da maneira que quiser. Para obter a versÃ£o exata deste cÃ³digo, use <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser/releases/tag/SecondArticle" target="_blank" rel="noopener noreferrer">esta tag</a>.</p> <p>No prÃ³ximo artigo, comeÃ§aremos a analisar elementos de classe como construtores, campos e mÃ©todos. Estaremos ainda mais focados, lidando apenas com as estruturas de cÃ³digo que aparecem no cÃ³digo e, com sorte, poderemos terminar de analisar nossa primeira classe.</p> <p>Vejo vocÃª na prÃ³xima vez!</p> <br> <div class="tag-list"> <a href="/pt/tags/#dotnet">#dotnet</a> Â  <a href="/pt/tags/#programa%C3%A7%C3%A3o">#programaÃ§Ã£o</a> Â  <a href="/pt/tags/#linguagem">#linguagem</a> Â  <a href="/pt/tags/#sprache">#sprache</a> Â  <a href="/pt/tags/#tdd">#tdd</a> </div> </article> <div class="PageNavigation"> <a class="prev" href="/pt/read-my-blog-in-portuguese/">â† Anterior</a> </div> <aside class="related"> <h3>Related Posts</h3> <ul class="related-posts"> <li> <a href="/pt/read-my-blog-in-portuguese/"> Leia meu blog em portuguÃªs ou inglÃªs! <small><time datetime="2021-02-17T00:00:00+00:00">February 17th, 2021</time></small> </a> </li> <li> <a href="/pt/parsing-code-with-sprache/"> Analisando cÃ³digo com Sprache - Parte 1 <small><time datetime="2021-02-13T10:00:00+00:00">February 13th, 2021</time></small> </a> </li> <li> <a href="/pt/happy-halloween-blog-is-back/"> Feliz Halloween! Meu blog estÃ¡ de volta! <small><time datetime="2020-10-31T18:00:00+00:00">October 31st, 2020</time></small> </a> </li> </ul> </aside> </main> <footer class="footer"> <div class="wrapper"> <div> Â© Copyright 2021 Bruno Brant. Tema baseado em <a href="https://github.com/essentialenemy/noir/" target="_blank" rel="noopener noreferrer">Noir</a> de <a href="https://essentialenemy.com/" target="_blank" rel="noopener noreferrer">Victor Johnson</a>. </div> <div class="social-links">
<ul class="social-media-list">
<li><a rel="noopener noreferrer" href="https://github.com/bruno-brant" title="bruno-brant" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li>
<li><a rel="noopener noreferrer" href="https://stackoverflow.com/users/227332%2Fbruno-brant" title="227332/bruno-brant" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#stackoverflow"></use></svg></a></li>
<li><a rel="noopener noreferrer" href="https://www.linkedin.com/in/brunobrant" title="brunobrant" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg></a></li>
<li><a rel="noopener noreferrer" href="https://twitter.com/HeavyStorm" title="HeavyStorm" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li>
</ul> </div> </div> </footer> </div> </body> </html>
