<!doctype html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <meta property="og:image" content="https://blog.brunobrant.net/assets/technology-matters-logo.png" /> <title> &middot; TECHNOLOGY MATTERS </title> <link rel="stylesheet" href="/pt/styles.css"> <!-- <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/pt/assets/apple-touch-icon-precomposed.png"> --> <link rel="shortcut icon" href="/pt/assets/favicon.ico"> <link rel="alternate" type="application/atom+xml" title="TECHNOLOGY MATTERS" href="/pt/feed.xml"> <!-- Country flags from open source project--> <link rel="stylesheet" type="text/css" href="//github.com/downloads/lafeber/world-flags-sprite/flags16.css" /> <!-- Begin Jekyll SEO tag v2.7.1 --> <meta name="generator" content="Jekyll v4.1.1" /> <meta property="og:title" content="Analisando c√≥digo com Sprache - Parte 2" /> <meta name="author" content="Bruno Brant" /> <meta property="og:locale" content="pt" /> <meta name="description" content="üòé Este √© o segundo artigo de uma s√©rie de m√∫ltiplas partes sobre como analisar c√≥digo com Sprache. Voc√™ pode ler a primeira parte aqui. No post anterior, vimos como analisar algum texto (em particular, c√≥digo Java) usando Sprache, uma poderosa biblioteca para C#. Vimos como usar uma abordagem incremental e como usar testes unit√°rios para conduzir o desenvolvimento com esta ferramenta. At√© agora, escrevemos um analisador para Identifier e PackageName (verifique aqui). Agora vamos avan√ßar um pouco mais r√°pido. Lembre-se de que temos como alvo o source Java/Android Google Authenticator e que nosso objetivo final √© gerar um gr√°fico de depend√™ncias de classe para este projeto. Neste artigo, vamos tentar analisar todos os elementos de n√≠vel superior do arquivo atual em que estamos trabalhando, AuthenticatorActivity.java." /> <meta property="og:description" content="üòé Este √© o segundo artigo de uma s√©rie de m√∫ltiplas partes sobre como analisar c√≥digo com Sprache. Voc√™ pode ler a primeira parte aqui. No post anterior, vimos como analisar algum texto (em particular, c√≥digo Java) usando Sprache, uma poderosa biblioteca para C#. Vimos como usar uma abordagem incremental e como usar testes unit√°rios para conduzir o desenvolvimento com esta ferramenta. At√© agora, escrevemos um analisador para Identifier e PackageName (verifique aqui). Agora vamos avan√ßar um pouco mais r√°pido. Lembre-se de que temos como alvo o source Java/Android Google Authenticator e que nosso objetivo final √© gerar um gr√°fico de depend√™ncias de classe para este projeto. Neste artigo, vamos tentar analisar todos os elementos de n√≠vel superior do arquivo atual em que estamos trabalhando, AuthenticatorActivity.java." /> <link rel="canonical" href="https://blog.brunobrant.net/parsing-code-with-sprache-part-2/" /> <meta property="og:url" content="https://blog.brunobrant.net/parsing-code-with-sprache-part-2/" /> <meta property="og:site_name" content="TECHNOLOGY MATTERS" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2021-03-13T10:00:00+00:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Analisando c√≥digo com Sprache - Parte 2" /> <script type="application/ld+json"> {"datePublished":"2021-03-13T10:00:00+00:00","description":"üòé Este √© o segundo artigo de uma s√©rie de m√∫ltiplas partes sobre como analisar c√≥digo com Sprache. Voc√™ pode ler a primeira parte aqui. No post anterior, vimos como analisar algum texto (em particular, c√≥digo Java) usando Sprache, uma poderosa biblioteca para C#. Vimos como usar uma abordagem incremental e como usar testes unit√°rios para conduzir o desenvolvimento com esta ferramenta. At√© agora, escrevemos um analisador para Identifier e PackageName (verifique aqui). Agora vamos avan√ßar um pouco mais r√°pido. Lembre-se de que temos como alvo o source Java/Android Google Authenticator e que nosso objetivo final √© gerar um gr√°fico de depend√™ncias de classe para este projeto. Neste artigo, vamos tentar analisar todos os elementos de n√≠vel superior do arquivo atual em que estamos trabalhando, AuthenticatorActivity.java.","url":"https://blog.brunobrant.net/parsing-code-with-sprache-part-2/","@type":"BlogPosting","dateModified":"2021-03-13T10:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.brunobrant.net/parsing-code-with-sprache-part-2/"},"author":{"@type":"Person","name":"Bruno Brant"},"headline":"Analisando c√≥digo com Sprache - Parte 2","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <script> /* Toggle between adding and removing the "responsive" class to topnav when the user clicks on the icon */ function openNavigation() { const navigationElems = document.getElementsByClassName("navigation"); if (navigationElems.length != 1) { console.warn("Couldn't find navbar"); return; } const x = navigationElems[0]; if (x.className === "navigation") { x.className += " responsive"; } else { x.className = "navigation"; } } </script> <body> <div class="container content"> <header class="masthead"> <h3 class="masthead-title"> <a href="/pt/" title="Home" class="masthead-title-main">TECHNOLOGY MATTERS</a><br> <small>pensamentos desordenados sobre tecnologia, software, etc.</small> </h3> <!-- Change navigation links here --> <div class="navigation"> <ul id="navigation-list"> <li> <a href="/pt/">HOME</a> </li> <li> <a href="/pt/archive/">POSTS</a> </li> <li> <a href="/pt/tags/">TAGS</a> </li> <li> <a href="/pt/categories/">CATEGORIAS</a> </li> <li> <a href="/pt/about/">SOBRE</a> </li> <li id="subscribe"> <a href="/feed.xml"> <p>ASSINAR</p> <svg class="svg-icon grey" style="fill: #f66a0a;"> <use xlink:href="/assets/minima-social-icons.svg#rss"></use> </svg> </a> </li> </ul> <div style="float:right"> <a href="javascript:void(0);" class="navigation-icon" onclick="openNavigation()">‚ò∞</a> </div> </div> <!-- Language selector --> <div class="language-selector f16"> <span class="language-selector-label">ler esse site em:</span> <a href="/parsing-code-with-sprache-part-2/"><img class="flag us" src="/assets/Transparent32x32.png"></a> | <a href="/pt/parsing-code-with-sprache-part-2/"><img class="flag br" src="/assets/Transparent32x32.png"></a> </div> </header> <main> <!-- Change navigation links here --> <article class="post"> <h1 class="post-title">Analisando c√≥digo com Sprache - Parte 2</h1> <time datetime="2021-03-13T10:00:00+00:00" class="post-date">March 13th, 2021 in <a href="/pt/categories/#Desenvolvimento">Desenvolvimento</a> </time> <blockquote> <p>üòé Este √© o segundo artigo de uma s√©rie de m√∫ltiplas partes sobre <strong>como analisar c√≥digo com Sprache</strong>. Voc√™ pode ler a primeira parte <a href="2021-02-13-parsing-code-with-sprache">aqui</a>.</p> </blockquote> <p>No post anterior, vimos como analisar algum texto (em particular, c√≥digo Java) usando <a href="https://github.com/sprache/Sprache" target="_blank" rel="noopener noreferrer">Sprache</a>, uma poderosa biblioteca para C#. Vimos como usar uma abordagem incremental e como usar testes unit√°rios para conduzir o desenvolvimento com esta ferramenta. At√© agora, escrevemos um analisador para <code class="language-plaintext highlighter-rouge">Identifier</code> e <code class="language-plaintext highlighter-rouge">PackageName</code> (verifique <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser/blob/c5f7f6ce78382ac47e8ab0d03ca43851425d1545/src/TinyJavaParser/JavaGram.cs" target="_blank" rel="noopener noreferrer">aqui</a>).</p> <p>Agora vamos avan√ßar um pouco mais r√°pido. Lembre-se de que temos como alvo o source Java/Android <a href="https://github.com/google/google-authenticator-android/tree/master/java/com/google/android/apps/authenticator" target="_blank" rel="noopener noreferrer">Google Authenticator</a> e que nosso objetivo final √© gerar um gr√°fico de depend√™ncias de classe para este projeto. Neste artigo, vamos tentar analisar todos os elementos de n√≠vel superior do arquivo atual em que estamos trabalhando, <a href="https://github.com/google/google-authenticator-android/blob/master/java/com/google/android/apps/authenticator/AuthenticatorActivity.java" target="_blank" rel="noopener noreferrer">AuthenticatorActivity.java</a>.</p> <!--more--> <blockquote> <p>‚ùó Em todo o c√≥digo do blog, eliminei a documenta√ß√£o interna para maior clareza. Verifique o <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser" target="_blank" rel="noopener noreferrer">repo</a> para ver os coment√°rios.</p> </blockquote> <h1 id="refatorando-nosso-caminho-para-o-sucesso">Refatorando nosso caminho para o sucesso</h1> <p>Antes de incrementar o c√≥digo atual, identifiquei um pequeno ajuste que nos ajudar√° na pr√≥xima etapa. Veja, o analisador <code class="language-plaintext highlighter-rouge">PackageName</code> est√°, na verdade, analisando uma <em>instru√ß√£o package (package statement)</em>. Nomes de pacotes s√£o usados ‚Äã‚Äãem outros lugares, portanto, facilitaremos a reutiliza√ß√£o extraindo um <code class="language-plaintext highlighter-rouge">PackageName</code> do analisador atual.</p> <p>Primeiro, renomeie o analisador <code class="language-plaintext highlighter-rouge">JavaGrammar.PackageName</code> para <code class="language-plaintext highlighter-rouge">JavaGrammar.PackageStament</code>, o nome correto para o que est√° analisando; use suas ferramentas de refatora√ß√£o de IDE para isso. Voc√™ tamb√©m precisa renomear a unidade de teste anterior de <code class="language-plaintext highlighter-rouge">PackageNameParserTests</code> para <code class="language-plaintext highlighter-rouge">PackageStatementParserTests</code> para manter as coisas coerentes.</p> <p>A seguir, vamos extrair a an√°lise de um <code class="language-plaintext highlighter-rouge">PackageName</code> de <code class="language-plaintext highlighter-rouge">JavaGrammar.PackageStament</code>. Veja as linhas abaixo:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">PackageStatement</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
	<span class="c1">// ‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì Parsing of Package Name ‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì</span>
	<span class="k">from</span> <span class="n">packageHead</span> <span class="k">in</span> <span class="n">Identifier</span>
	<span class="k">from</span> <span class="n">packageTail</span> <span class="k">in</span> <span class="p">(</span><span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'.'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
							<span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">Identifier</span>
							<span class="k">select</span> <span class="n">identifier</span><span class="p">).</span><span class="nf">Many</span><span class="p">()</span>
	<span class="c1">// ‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë Parsing of Package Name ‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë</span>
	<span class="k">from</span> <span class="n">terminator</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
	<span class="c1">// ‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì And this is how the result is build ‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">PackageName</span><span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="n">packageHead</span> <span class="p">}.</span><span class="nf">Concat</span><span class="p">(</span><span class="n">packageTail</span><span class="p">).</span><span class="nf">ToList</span><span class="p">());</span>
	<span class="c1">// ‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë And this is how the result is build ‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë</span>
</code></pre></div></div> <p>Vamos extrair isso em um analisador isolado, este na verdade chamado <code class="language-plaintext highlighter-rouge">PackageName</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">PackageName</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">packageHead</span> <span class="k">in</span> <span class="n">Identifier</span>
	<span class="k">from</span> <span class="n">packageTail</span> <span class="k">in</span> <span class="p">(</span><span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'.'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
						 <span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">Identifier</span>
						 <span class="k">select</span> <span class="n">identifier</span><span class="p">).</span><span class="nf">Many</span><span class="p">()</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">PackageName</span><span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="n">packageHead</span> <span class="p">}.</span><span class="nf">Concat</span><span class="p">(</span><span class="n">packageTail</span><span class="p">).</span><span class="nf">ToList</span><span class="p">());</span>
</code></pre></div></div> <p>Precisamos criar uma estrutura para representar a <em>instru√ß√£o package</em>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageStatement</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">PackageStatement</span><span class="p">(</span><span class="n">PackageName</span> <span class="n">packageName</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">PackageName</span> <span class="p">=</span> <span class="n">packageName</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">PackageName</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Vamos atualizar o analisador <code class="language-plaintext highlighter-rouge">PackageStatement</code> para retornar a estrutura, usando o analisador<code class="language-plaintext highlighter-rouge"> PackageName</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">PackageStatement</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">packageName</span> <span class="k">in</span> <span class="n">PackageName</span>
	<span class="k">from</span> <span class="n">terminator</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
	<span class="k">select</span> <span class="n">packageName</span><span class="p">;</span>
</code></pre></div></div> <p>Execute todos os testes e voc√™ descobrir√° que tudo est√° funcionando como deveria. Esta refatora√ß√£o foi confirmada sob a tag <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser/tree/Refactor_PackageName" target="_blank" rel="noopener noreferrer">Refactor_PackageName</a>.</p> <h1 id="analisando-mais-estruturas">Analisando mais estruturas</h1> <p>Vamos voltar √† cria√ß√£o de novos analisadores. A pr√≥xima estrutura natural √© uma declara√ß√£o de importa√ß√£o que tem o seguinte BNF:</p> <h2 id="declara√ß√£o-de-importa√ß√£o">Declara√ß√£o de importa√ß√£o</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IMPORT = "import", PACKAGE_NAME, ";";
</code></pre></div></div> <p>Vamos come√ßar atualizando nossa classe <code class="language-plaintext highlighter-rouge">Import</code> anterior. Mude seu nome de <code class="language-plaintext highlighter-rouge">Import</code> para <code class="language-plaintext highlighter-rouge">ImportStatement</code>, que √© mais exato. <strong>Use sua ferramenta de refatora√ß√£o IDE para renomear a classe.</strong> Eu tamb√©m criei um construtor para ela que inicializa o <code class="language-plaintext highlighter-rouge">PackageName</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ImportStatement</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">ImportStatement</span><span class="p">(</span><span class="n">PackageName</span> <span class="n">packageName</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">PackageName</span> <span class="p">=</span> <span class="n">packageName</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">PackageName</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Agora, vamos criar um teste para isso:</p> <blockquote> <p>üòé Estou criando um arquivo de teste para cada analisador, embora eles (atualmente) sejam todos parte da mesma classe. Isso n√£o √© <em>padr√£o</em>; √© a melhor pr√°tica ter uma classe de teste de unidade <em>por classe</em>. Entretanto, fazer dessa forma torna mais f√°cil localizar os testes e nos permite mant√™-los mais organizados.</p> </blockquote> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ImportStatementParserTests</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
	<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"import android.annotation.TargetApi;"</span><span class="p">)]</span>
	<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"import android.app.Activity;"</span><span class="p">)]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackageName_ReturnsStructureWithCorrectName</span><span class="p">(</span><span class="kt">string</span> <span class="n">importStatement</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">ImportStatement</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">importStatement</span><span class="p">);</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">packageName</span><span class="p">,</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">PackageName</span><span class="p">.</span><span class="n">Identifiers</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Usamos as primeiras instru√ß√µes de <code class="language-plaintext highlighter-rouge">import</code> de <code class="language-plaintext highlighter-rouge">AuthenticatorActivity</code>, como voc√™ pode ver. Tamb√©m estamos fazendo um <code class="language-plaintext highlighter-rouge">join</code> dos identificadores assim como fizemos da √∫ltima vez, o que √© um pouco tedioso; vamos melhorar isso na etapa de <em>refatorar</em>.</p> <p>A execu√ß√£o desse teste levar√° a üî¥, pois o c√≥digo n√£o foi implementado. Vamos escrever o analisador agora:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">ImportStatement</span><span class="p">&gt;</span> <span class="n">ImportStatement</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">importKeyword</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"import"</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">packageName</span> <span class="k">in</span> <span class="n">PackageName</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">ImportStatement</span><span class="p">(</span><span class="n">packageName</span><span class="p">);</span>
</code></pre></div></div> <p>Leitores √°vidos notar√£o o m√©todo anteriormente n√£o visto <code class="language-plaintext highlighter-rouge">Token()</code> na segunda linha. Este √© um dos m√©todos mais √∫teis no Sprache - remover√° os espa√ßos em branco ao redor do caractere, mas * exigir√° * que ele esteja l√°. Isso significa que, por exemplo, <code class="language-plaintext highlighter-rouge">Parse.String("import").Token().Parse(" import ")</code> funcionar√°, mas <code class="language-plaintext highlighter-rouge">Parse.String("import").Token().Parse(" importasd ")</code> n√£o.</p> <p>O resto deve ser muito leg√≠vel - procure a palavra-chave <code class="language-plaintext highlighter-rouge">import</code>, depois uma estrutura PackageName e retorne uma instru√ß√£o import. <strong>Execute todos os testes.</strong> Voc√™ deve obter um üü¢.</p> <p>Continuando, vamos refatorar um pouco. Lembra que eu disse que far√≠amos algo sobre <code class="language-plaintext highlighter-rouge">string.Join('.', actual.PackageName.Identifiers)</code>? Agora √© a hora!</p> <p>A representa√ß√£o de string de um nome de pacote, digamos, ‚Äúandroid.content.ActivityNotFoundException‚Äù n√£o √© outro sen√£o ‚Äúandroid.content.ActivityNotFoundException‚Äù. Ent√£o, o que voc√™ acha de substituir <code class="language-plaintext highlighter-rouge">PackageName.ToString</code> para cumprir esse comportamento?</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageName</span>
<span class="p">{</span>
	<span class="c1">// ...</span>

	<span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span> <span class="n">Identifiers</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>üòé <strong>DICA:</strong> Ao realizer um <code class="language-plaintext highlighter-rouge">override</code> em m√©todos e propriedades, use o xml doc <code class="language-plaintext highlighter-rouge">/// &lt;inheritdoc /&gt;</code> como documenta√ß√£o.</p> </blockquote> <p>Agora, seguindo a mesma ideia, podemos adicionar uma substitui√ß√£o de <code class="language-plaintext highlighter-rouge">ToString</code> em <code class="language-plaintext highlighter-rouge">ImportStatement</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ImportStatement</span>
<span class="p">{</span>
	<span class="c1">// ...</span>

	<span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="s">$"import </span><span class="p">{</span><span class="n">PackageName</span><span class="p">}</span><span class="s">;"</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Agora podemos atualizar nosso teste de unidade para refletir este refator:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"import android.annotation.TargetApi;"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"import android.app.Activity;"</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackageName_ReturnsStructureWithCorrectName</span><span class="p">(</span><span class="kt">string</span> <span class="n">importStatement</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">ImportStatement</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">importStatement</span><span class="p">);</span>

	<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">importStatement</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="nf">ToString</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>‚ö† <strong>Aviso</strong>: neste caso, a entrada √© formatada exatamente como a sa√≠da de <code class="language-plaintext highlighter-rouge">ImportStatement.ToString</code>. No entanto, se voc√™ analisar algo como <code class="language-plaintext highlighter-rouge">" import name.surname"</code>, enquanto a an√°lise funcionar√°, o <code class="language-plaintext highlighter-rouge">ToString</code> retornar√° <code class="language-plaintext highlighter-rouge">"import name.surname"</code>, sem espa√ßos. Isso significa que a regra <code class="language-plaintext highlighter-rouge">Token ()</code> n√£o est√° sendo testada em nossa su√≠te - a raz√£o para isso √© que ela n√£o aparece em nosso escopo - portanto, os testes s√£o um pouco fr√°geis e devem ser melhorados na maioria das circunst√¢ncias. N√£o vou fazer isso durante esses exerc√≠cios, mas os leitores devem definitivamente faz√™-lo.</p> </blockquote> <p>Agora, precisamos ler um bloco de importa√ß√µes em nosso arquivo. Chamamos isso de IMPORT_LIST no eBNF. A estrutura de dados para isso n√£o precisa ser mais do que <code class="language-plaintext highlighter-rouge">List &lt;ImportStatement&gt;</code>, mas precisamos de um analisador para isso. Comece com um teste:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ImportListParserTests</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">[</span><span class="k">]&gt;</span> <span class="nf">ImportLists</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">string</span><span class="p">[]</span>
		<span class="p">{</span>
			<span class="s">@"
import com.google.android.apps.authenticator.util.EmptySpaceClickableDragSortListView;
import com.google.android.apps.authenticator.util.annotations.FixWhenMinSdkVersion;
import com.google.android.apps.authenticator2.R;
import com.google.common.annotations.VisibleForTesting;
			"</span><span class="p">.</span><span class="nf">Trim</span><span class="p">(),</span>
		<span class="p">};</span>

		<span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">string</span><span class="p">[]</span>
		<span class="p">{</span>
			<span class="s">@"
import android.support.v7.widget.Toolbar;
import android.text.Html;
import android.util.Log;
import android.view.ActionMode;
import android.view.ContextMenu;
			"</span><span class="p">.</span><span class="nf">Trim</span><span class="p">(),</span>
		<span class="p">};</span>
	<span class="p">}</span>

	<span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
	<span class="p">[</span><span class="nf">MemberData</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">ImportLists</span><span class="p">))]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackageName_ReturnsStructureWithCorrectName</span><span class="p">(</span><span class="kt">string</span> <span class="n">importList</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">expected</span> <span class="p">=</span> <span class="n">importList</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">).</span><span class="nf">ToList</span><span class="p">();</span>
		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">ImportList</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">importList</span><span class="p">);</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span> <span class="n">_</span><span class="p">.</span><span class="nf">ToString</span><span class="p">()));</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>A implementa√ß√£o da lista √© simples:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">ImportStatement</span><span class="p">&gt;&gt;</span> <span class="n">ImportList</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">statements</span> <span class="k">in</span> <span class="n">ImportStatement</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">select</span> <span class="n">statements</span><span class="p">.</span><span class="nf">ToList</span><span class="p">();</span>
</code></pre></div></div> <p>Agora que as importa√ß√µes foram tratadas, vamos passar para a pr√≥xima estrutura de c√≥digo em <code class="language-plaintext highlighter-rouge">AuthenticatorActivity.java</code>, uma <em>anota√ß√£o</em>.</p> <h2 id="anota√ß√µes">Anota√ß√µes</h2> <p>A pr√≥xima estrutura de c√≥digo em <code class="language-plaintext highlighter-rouge">AuthenticatorActivity</code> √© a declara√ß√£o da classe. Ele cont√©m um trecho de c√≥digo sobre o qual n√£o falamos antes, uma anota√ß√£o.</p> <p>As anota√ß√µes Java s√£o an√°logas aos atributos C# e t√™m a seguinte apar√™ncia:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FixWhenMinSdkVersion</span><span class="o">(</span><span class="mi">11</span><span class="o">)</span>
</code></pre></div></div> <p>Assim como no C#, essas estruturas s√≥ podem aparecer antes das declara√ß√µes e, neste caso, √© uma declara√ß√£o de classe. Precisamos criar a estrutura de dados para acomodar isso e o analisador para produzi-la.</p> <p>Conforme mencionado anteriormente, estamos construindo interativamente o eBNF. Isso √© para tornar nosso analisador mais simples - apenas escrever o c√≥digo necess√°rio para as estruturas que est√£o presentes no c√≥digo-fonte. √â por isso que a anota√ß√£o n√£o foi mencionada antes. Vamos atualiz√°-lo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ANNOTATION = "@", IDENTIFIER, "(", ARGUMENT_LIST, ")"

ARGUMENT_LIST = ARGUMENT, { "," ARGUMENT }

ARGUMENT = LITERAL

LITERAL = INTEGER_LITERAL
</code></pre></div></div> <p><strong>O eBNF acima √© parcial</strong>; Por exemplo, a lista de argumentos para a anota√ß√£o √© mais complexa, permitindo outros tipos. Mas at√© agora s√≥ temos o par√¢metro inteiro, ent√£o vamos nos ater a ele.</p> <p>A primeira coisa √© definir a estrutura de dados de uma anota√ß√£o. Olhando para ele, voc√™ pode imaginar que tem um identificador como nome e, em seguida, a lista de argumentos.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">interface</span> <span class="nc">ILiteral</span>
<span class="p">{</span>
	<span class="kt">object</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">IntegerLiteral</span>  <span class="p">:</span> <span class="n">ILiteral</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">IntegerLiteral</span><span class="p">(</span><span class="kt">int</span> <span class="k">value</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="n">Value</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> 

	<span class="kt">object</span> <span class="n">ILiteral</span><span class="p">.</span><span class="n">Value</span> <span class="p">=&gt;</span> <span class="n">Value</span><span class="p">;</span>

	<span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">Value</span><span class="p">.</span><span class="nf">ToString</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Annotation</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">Annotation</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ILiteral</span><span class="p">&gt;</span> <span class="n">arguments</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Name</span> <span class="p">=</span> <span class="n">name</span><span class="p">;</span>
		<span class="n">Arguments</span> <span class="p">=</span> <span class="n">arguments</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

	<span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Argument</span><span class="p">&gt;</span> <span class="n">Arguments</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

	<span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="s">$"@</span><span class="p">{</span><span class="n">Name</span><span class="p">}</span><span class="s">(</span><span class="p">{</span><span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="s">", "</span><span class="p">,</span> <span class="n">Arguments</span><span class="p">)}</span><span class="s">)"</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Introduzimos um pouco de abstra√ß√£o que pode nos poupar algum trabalho mais tarde - deixamos claro que literal pode ser muitas coisas, n√£o apenas inteiros. A convers√£o para a estrutura correta permitir√° que os usu√°rios obtenham o valor digitado - caso contr√°rio, por enquanto, encaixaremos o int e o retornamos como um objeto.</p> <p>Precisamos criar um analisador para essa nova estrutura - um literal inteiro.</p> <p>Testes:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">IntergerLiteralParserTests</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
	<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="m">11</span><span class="p">)]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">MyTheory</span><span class="p">(</span><span class="kt">int</span> <span class="k">value</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">IntegerLiteral</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="k">value</span><span class="p">.</span><span class="nf">ToString</span><span class="p">());</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="k">value</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>E o analisador:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">IntegerLiteral</span><span class="p">&gt;</span> <span class="n">IntegerLiteral</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">digits</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="n">Digit</span><span class="p">.</span><span class="nf">AtLeastOnce</span><span class="p">()</span>
	<span class="k">let</span> <span class="n">number</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Concat</span><span class="p">(</span><span class="n">digits</span><span class="p">)</span>
	<span class="k">let</span> <span class="k">value</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">IntegerLiteral</span><span class="p">(</span><span class="k">value</span><span class="p">);</span>
</code></pre></div></div> <p>Uma coisa no c√≥digo acima que pode fazer voc√™ se perguntar √© o <code class="language-plaintext highlighter-rouge">AtLeastOnce()</code>. Isso √© muito pr√≥ximo de <code class="language-plaintext highlighter-rouge">Many()</code>, com a diferen√ßa de que ir√° falhar na an√°lise quando n√£o houver pelo menos um √∫nico d√≠gito. Se n√£o aplicarmos isso aqui, o analisador aceitar√° uma lista de argumentos vazia.</p> <p>Agora vamos para a anota√ß√£o real.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">AnnotationParserTests</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
	<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"@Number(11)"</span><span class="p">,</span> <span class="k">new</span> <span class="kt">object</span><span class="p">[]</span> <span class="p">{</span> <span class="m">11</span> <span class="p">})]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenAnnotationHasParameters_CorrectParameters</span><span class="p">(</span><span class="kt">string</span> <span class="n">annotation</span><span class="p">,</span> <span class="kt">object</span><span class="p">[]</span> <span class="n">parameters</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">Annotation</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">annotation</span><span class="p">);</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Arguments</span><span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;().</span><span class="nf">ToArray</span><span class="p">());</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>‚ùó Esses testes s√£o muito b√°sicos; na maioria dos cen√°rios de produ√ß√£o, sugiro escrever testes que tenham mais condi√ß√µes; por exemplo, poder√≠amos testar casos como <code class="language-plaintext highlighter-rouge">@ SomeAnnotation</code>, dividindo o c√≥digo em duas linhas, etc. Observe o c√≥digo que est√° sendo testado para encontrar lacunas ou riscos e crie os testes correspondentes. Finalmente, com TDD devemos escrever um teste por vez e evoluir iterativamente.</p> <p>A raz√£o pela qual podemos nos safar com testes t√£o simples √© que sabemos com anteced√™ncia todo o c√≥digo que precisa ser analisado, ent√£o podemos testar novamente um caso real e verificar se surgem bugs, mas mesmo assim, eu teria cuidado onde isso n√£o apenas uma postagem no blog.</p> </blockquote> <p>A implementa√ß√£o ir√° alavancar o analisador <code class="language-plaintext highlighter-rouge">IntegerLiteral</code> que acabamos de codificar:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">Annotation</span><span class="p">&gt;</span> <span class="n">Annotation</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">at</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'@'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">Identifier</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">startList</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'('</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">literal</span> <span class="k">in</span> <span class="n">IntegerLiteral</span><span class="p">.</span><span class="nf">Token</span><span class="p">().</span><span class="nf">Optional</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">endList</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">')'</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">let</span> <span class="n">arguments</span> <span class="p">=</span> <span class="n">literal</span><span class="p">.</span><span class="n">IsDefined</span>
		<span class="p">?</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ILiteral</span><span class="p">&gt;</span> <span class="p">{</span> <span class="n">literal</span><span class="p">.</span><span class="nf">Get</span><span class="p">()</span> <span class="p">}</span>
		<span class="p">:</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ILiteral</span><span class="p">&gt;()</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">Annotation</span><span class="p">(</span><span class="n">identifier</span><span class="p">,</span> <span class="n">arguments</span><span class="p">);</span>
</code></pre></div></div> <p>Novamente, podemos ver um analisador opcional sendo chamado. Para obter a lista real, precisamos fazer alguma gin√°stica LINQ - retornar uma lista com um √∫nico literal ou uma lista vazia. No futuro, provavelmente criaremos um analisador <code class="language-plaintext highlighter-rouge">ArgumentList</code> que deve substituir isso, mas at√© agora, n√£o h√° necessidade.</p> <p>Os testes devem ser üü¢.</p> <h2 id="declara√ß√£o-de-classe">Declara√ß√£o de classe</h2> <p>A pr√≥xima coisa no arquivo √© a defini√ß√£o real da classe. Vamos decomp√¥-lo:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FixWhenMinSdkVersion</span> <span class="o">(</span><span class="mi">11</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AuthenticatorActivity</span> <span class="n">estende</span> <span class="nc">TestableActivity</span> <span class="o">{</span>
<span class="c1">// ...</span>
</code></pre></div></div> <p>Este √© um bom exemplo porque, de cara, lidaremos com <code class="language-plaintext highlighter-rouge">extends</code>, um caso comum, mas n√£o basal. A anota√ß√£o j√° foi cuidada, ent√£o vamos analisar a declara√ß√£o da classe:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>visibility
   ‚îÇ
   ‚îÇ          identifier, class          identifier, base class
   ‚îÇ                   ‚îÇ                          ‚îÇ
‚îå‚îÄ‚îÄ‚î¥‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
public class AuthenticatorActivity extends TestableActivity 
       ‚îî‚îÄ‚î¨‚îÄ‚îò                       ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò
         ‚îÇ             interface inheritance keyword
         ‚îÇ
class declaration keyword
</code></pre></div></div> <p>Portanto, precisamos expandir o EBNF:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CLASS_DECLARATION = VISIBILITY, "class", IDENTIFIER, { "extends", IDENTIFIER }, "{", (* ommited *), "}";

VISIBILITY = "public" 
</code></pre></div></div> <blockquote> <p>‚ùó N√£o estamos lidando com outras visibilidades apenas no momento, a n√£o ser para refletir nossa abordagem em evolu√ß√£o. √Ä medida que lidamos com mais casos, expandimos a defini√ß√£o.</p> </blockquote> <p>Isso deve ser realmente simples, mas precisamos atualizar a estrutura da classe para refleti-la:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">enum</span> <span class="n">Visibility</span>
<span class="p">{</span>
	<span class="n">Public</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">ClassDefinition</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">ClassDefinition</span><span class="p">(</span><span class="n">Visibility</span> <span class="n">visibility</span><span class="p">,</span> <span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">string</span><span class="p">?</span> <span class="n">baseClass</span> <span class="p">=</span> <span class="k">null</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">?</span> <span class="n">annotation</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Visibility</span> <span class="p">=</span> <span class="n">visibility</span><span class="p">;</span>
		<span class="n">Name</span> <span class="p">=</span> <span class="n">name</span><span class="p">;</span>
		<span class="n">BaseClass</span> <span class="p">=</span> <span class="n">baseClass</span><span class="p">;</span>
		<span class="n">Annotation</span> <span class="p">=</span> <span class="n">annotation</span><span class="p">;</span>
	<span class="p">}</span>

		<span class="k">public</span> <span class="n">Visibility</span> <span class="n">Visibility</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

		<span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

		<span class="k">public</span> <span class="kt">string</span><span class="p">?</span> <span class="n">BaseClass</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

		<span class="k">public</span> <span class="n">Annotation</span><span class="p">?</span> <span class="n">Annotation</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Algumas coisas a serem observadas: estamos seguindo estritamente o trecho de c√≥digo que est√° sendo processado, ent√£o, embora haja um membro Visibility, o √∫nico valor poss√≠vel √© <code class="language-plaintext highlighter-rouge">Public</code>; embora Java permita v√°rias anota√ß√µes, estamos apenas considerando uma √∫nica anota√ß√£o etc. O motivo pelo qual estou seguindo essa abordagem √© que ainda n√£o sabemos se esses casos surgir√£o dentro do c√≥digo. Se o fizerem, iremos reescrever o c√≥digo acima.</p> <p>Agora vamos criar nossos testes:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ClassDefinitionParserTests</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_AnnotatedClassWithExtends_CorrectParameters</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">code</span> <span class="p">=</span> <span class="s">@"
@FixWhenMinSdkVersion(11)
public class AuthenticatorActivity extends TestableActivity
"</span><span class="p">.</span><span class="nf">Trim</span><span class="p">();</span>

		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">ClassDefinition</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">"FixWhenMinSdkVersion"</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Annotation</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="m">11</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Annotation</span><span class="p">.</span><span class="n">Arguments</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">Value</span><span class="p">);</span>
		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">Visibility</span><span class="p">.</span><span class="n">Public</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Visibility</span><span class="p">);</span>
		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">"AuthenticatorActivity"</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">"TestableActivity"</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">BaseClass</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Novamente, os testes lidam apenas com o que vimos at√© agora. Usei um <code class="language-plaintext highlighter-rouge">Fact</code> em vez de uma <code class="language-plaintext highlighter-rouge">Theory</code> porque estamos lidando apenas com um √∫nico caso. Assim que tivermos mais casos para testar, vou convert√™-lo em <code class="language-plaintext highlighter-rouge">Theory</code>.</p> <p>Ah! Estou testando o resultado da an√°lise de anota√ß√£o, que na verdade est√° repetindo os testes j√° feitos no <code class="language-plaintext highlighter-rouge">AnnotationParserTests</code>. Poder√≠amos fazer isso de forma um pouco diferente e apenas ter certeza de que o analisador correto foi chamado, mas por enquanto, vamos manter isso simples e repetir o teste.</p> <p>Agora, a implementa√ß√£o, embora longa, √© simples, apenas analise cada fragmento que vimos na an√°lise acima:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">ClassDefinition</span><span class="p">&gt;</span> <span class="n">ClassDefinition</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">annotation</span> <span class="k">in</span> <span class="n">Annotation</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">visibility</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"public"</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">classKeyword</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"class"</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">className</span> <span class="k">in</span> <span class="n">Identifier</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">extendsKeyword</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"extends"</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">baseClassName</span> <span class="k">in</span> <span class="n">Identifier</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">ClassDefinition</span><span class="p">(</span><span class="n">Visibility</span><span class="p">.</span><span class="n">Public</span><span class="p">,</span> <span class="n">className</span><span class="p">,</span> <span class="n">baseClassName</span><span class="p">,</span> <span class="n">annotation</span><span class="p">);</span>
</code></pre></div></div> <p>Eu cortei alguns cantos aqui, como analisar a visibilidade diretamente. Tamb√©m lidaremos com isso quando for necess√°rio.</p> <p>Fa√ßa seus testes e aprecie seu üü¢.</p> <h1 id="resumo">Resumo</h1> <p>Com este artigo, conclu√≠mos a primeira etapa: podemos analisar todos os elementos de n√≠vel superior de um arquivo de origem Java. Voc√™ aprendeu um pouco mais sobre como usar Sprache e combinar analisadores e provavelmente aprendeu algumas t√©cnicas sobre como criar c√≥digo <em>apto para o prop√≥sito</em>, usando uma abordagem orientada a testes e evoluindo o c√≥digo anterior √† medida que avan√ßamos em nosso entendimento do dom√≠nio do problema, um processo denominado ** descoberta **.</p> <p>Todo o c√≥digo produzido at√© agora foi armazenado em <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser" target="_blank" rel="noopener noreferrer">Github</a>. Voc√™ pode fazer um fork e us√°-lo da maneira que quiser. Para obter a vers√£o exata deste c√≥digo, use <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser/releases/tag/SecondArticle" target="_blank" rel="noopener noreferrer">esta tag</a>.</p> <p>No pr√≥ximo artigo, come√ßaremos a analisar elementos de classe como construtores, campos e m√©todos. Estaremos ainda mais focados, lidando apenas com as estruturas de c√≥digo que aparecem no c√≥digo e, com sorte, poderemos terminar de analisar nossa primeira classe.</p> <p>Vejo voc√™ na pr√≥xima vez!</p> <br> <div class="tag-list"> <a href="/pt/tags/#dotnet">#dotnet</a> ¬† <a href="/pt/tags/#programa%C3%A7%C3%A3o">#programa√ß√£o</a> ¬† <a href="/pt/tags/#linguagem">#linguagem</a> ¬† <a href="/pt/tags/#sprache">#sprache</a> ¬† <a href="/pt/tags/#tdd">#tdd</a> </div> </article> <div class="PageNavigation"> <a class="prev" href="/pt/read-my-blog-in-portuguese/">‚Üê Anterior</a> </div> <aside class="related"> <h3>Related Posts</h3> <ul class="related-posts"> <li> <a href="/pt/read-my-blog-in-portuguese/"> Leia meu blog em portugu√™s ou ingl√™s! <small><time datetime="2021-02-17T00:00:00+00:00">February 17th, 2021</time></small> </a> </li> <li> <a href="/pt/parsing-code-with-sprache/"> Analisando c√≥digo com Sprache - Parte 1 <small><time datetime="2021-02-13T10:00:00+00:00">February 13th, 2021</time></small> </a> </li> <li> <a href="/pt/happy-halloween-blog-is-back/"> Feliz Halloween! Meu blog est√° de volta! <small><time datetime="2020-10-31T18:00:00+00:00">October 31st, 2020</time></small> </a> </li> </ul> </aside> </main> <footer class="footer"> <div class="wrapper"> <div> ¬© Copyright 2021 Bruno Brant. Tema baseado em <a href="https://github.com/essentialenemy/noir/" target="_blank" rel="noopener noreferrer">Noir</a> de <a href="https://essentialenemy.com/" target="_blank" rel="noopener noreferrer">Victor Johnson</a>. </div> <div class="social-links">
<ul class="social-media-list">
<li><a rel="noopener noreferrer" href="https://github.com/bruno-brant" title="bruno-brant" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li>
<li><a rel="noopener noreferrer" href="https://stackoverflow.com/users/227332%2Fbruno-brant" title="227332/bruno-brant" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#stackoverflow"></use></svg></a></li>
<li><a rel="noopener noreferrer" href="https://www.linkedin.com/in/brunobrant" title="brunobrant" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg></a></li>
<li><a rel="noopener noreferrer" href="https://twitter.com/HeavyStorm" title="HeavyStorm" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li>
</ul> </div> </div> </footer> </div> </body> </html>
