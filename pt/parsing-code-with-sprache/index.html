<!doctype html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <meta property="og:image" content="https://blog.brunobrant.net/assets/technology-matters-logo.png" /> <title> &middot; TECHNOLOGY MATTERS </title> <link rel="stylesheet" href="/pt/styles.css"> <!-- <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/pt/assets/apple-touch-icon-precomposed.png"> --> <link rel="shortcut icon" href="/pt/assets/favicon.ico"> <link rel="alternate" type="application/atom+xml" title="TECHNOLOGY MATTERS" href="/pt/feed.xml"> <!-- Country flags from open source project--> <link rel="stylesheet" type="text/css" href="//github.com/downloads/lafeber/world-flags-sprite/flags16.css" /> <!-- Begin Jekyll SEO tag v2.7.1 --> <meta name="generator" content="Jekyll v4.1.1" /> <meta property="og:title" content="Analisando c√≥digo com Sprache - Parte 1" /> <meta name="author" content="Bruno Brant" /> <meta property="og:locale" content="pt" /> <meta name="description" content="üòé Este √© o primeiro artigo de uma s√©rie de m√∫ltiplas partes sobre como analisar c√≥digo com Sprache. Voc√™ pode ler a segunda parte aqui. Voc√™ provavelmente sabe que √†s vezes (muitas vezes), o trabalho de um desenvolvedor √© muito mais pesquisa ou an√°lise do que programa√ß√£o! No passado, houve muitos casos em que eu estava em um projeto em que meu objetivo era migrar ou reescrever software antigo e, durante esses compromissos, acabei criando ferramentas para me ajudar. Muitas dessas ferramentas eram analisadores de c√≥digo especializados que realizavam automaticamente a an√°lise que eu exigia ou at√© mesmo geravam c√≥digos mais novos que eu poderia utilizar. Em todos esses casos, precisei analisar algum c√≥digo estruturado e h√° uma maneira simples de fazer isso: usando Sprache, um framework de parsing para dotnet. Neste artigo, vamos ver como fazer isso." /> <meta property="og:description" content="üòé Este √© o primeiro artigo de uma s√©rie de m√∫ltiplas partes sobre como analisar c√≥digo com Sprache. Voc√™ pode ler a segunda parte aqui. Voc√™ provavelmente sabe que √†s vezes (muitas vezes), o trabalho de um desenvolvedor √© muito mais pesquisa ou an√°lise do que programa√ß√£o! No passado, houve muitos casos em que eu estava em um projeto em que meu objetivo era migrar ou reescrever software antigo e, durante esses compromissos, acabei criando ferramentas para me ajudar. Muitas dessas ferramentas eram analisadores de c√≥digo especializados que realizavam automaticamente a an√°lise que eu exigia ou at√© mesmo geravam c√≥digos mais novos que eu poderia utilizar. Em todos esses casos, precisei analisar algum c√≥digo estruturado e h√° uma maneira simples de fazer isso: usando Sprache, um framework de parsing para dotnet. Neste artigo, vamos ver como fazer isso." /> <link rel="canonical" href="https://blog.brunobrant.net/parsing-code-with-sprache/" /> <meta property="og:url" content="https://blog.brunobrant.net/parsing-code-with-sprache/" /> <meta property="og:site_name" content="TECHNOLOGY MATTERS" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2021-02-13T10:00:00+00:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Analisando c√≥digo com Sprache - Parte 1" /> <script type="application/ld+json"> {"datePublished":"2021-02-13T10:00:00+00:00","description":"üòé Este √© o primeiro artigo de uma s√©rie de m√∫ltiplas partes sobre como analisar c√≥digo com Sprache. Voc√™ pode ler a segunda parte aqui. Voc√™ provavelmente sabe que √†s vezes (muitas vezes), o trabalho de um desenvolvedor √© muito mais pesquisa ou an√°lise do que programa√ß√£o! No passado, houve muitos casos em que eu estava em um projeto em que meu objetivo era migrar ou reescrever software antigo e, durante esses compromissos, acabei criando ferramentas para me ajudar. Muitas dessas ferramentas eram analisadores de c√≥digo especializados que realizavam automaticamente a an√°lise que eu exigia ou at√© mesmo geravam c√≥digos mais novos que eu poderia utilizar. Em todos esses casos, precisei analisar algum c√≥digo estruturado e h√° uma maneira simples de fazer isso: usando Sprache, um framework de parsing para dotnet. Neste artigo, vamos ver como fazer isso.","url":"https://blog.brunobrant.net/parsing-code-with-sprache/","@type":"BlogPosting","dateModified":"2021-02-13T10:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.brunobrant.net/parsing-code-with-sprache/"},"author":{"@type":"Person","name":"Bruno Brant"},"headline":"Analisando c√≥digo com Sprache - Parte 1","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <script> /* Toggle between adding and removing the "responsive" class to topnav when the user clicks on the icon */ function openNavigation() { const navigationElems = document.getElementsByClassName("navigation"); if (navigationElems.length != 1) { console.warn("Couldn't find navbar"); return; } const x = navigationElems[0]; if (x.className === "navigation") { x.className += " responsive"; } else { x.className = "navigation"; } } </script> <body> <div class="container content"> <header class="masthead"> <h3 class="masthead-title"> <a href="/pt/" title="Home" class="masthead-title-main">TECHNOLOGY MATTERS</a><br> <small>pensamentos desordenados sobre tecnologia, software, etc.</small> </h3> <!-- Change navigation links here --> <div class="navigation"> <ul id="navigation-list"> <li> <a href="/pt/">HOME</a> </li> <li> <a href="/pt/archive/">POSTS</a> </li> <li> <a href="/pt/tags/">TAGS</a> </li> <li> <a href="/pt/categories/">CATEGORIAS</a> </li> <li> <a href="/pt/about/">SOBRE</a> </li> <li id="subscribe"> <a href="/feed.xml"> <p>ASSINAR</p> <svg class="svg-icon grey" style="fill: #f66a0a;"> <use xlink:href="/assets/minima-social-icons.svg#rss"></use> </svg> </a> </li> </ul> <div style="float:right"> <a href="javascript:void(0);" class="navigation-icon" onclick="openNavigation()">‚ò∞</a> </div> </div> <!-- Language selector --> <div class="language-selector f16"> <span class="language-selector-label">ler esse site em:</span> <a href="/parsing-code-with-sprache/"><img class="flag us" src="/assets/Transparent32x32.png"></a> | <a href="/pt/parsing-code-with-sprache/"><img class="flag br" src="/assets/Transparent32x32.png"></a> </div> </header> <main> <!-- Change navigation links here --> <article class="post"> <h1 class="post-title">Analisando c√≥digo com Sprache - Parte 1</h1> <time datetime="2021-02-13T10:00:00+00:00" class="post-date">February 13th, 2021 in <a href="/pt/categories/#Desenvolvimento">Desenvolvimento</a> </time> <blockquote> <p>üòé Este √© o primeiro artigo de uma s√©rie de m√∫ltiplas partes sobre <strong>como analisar c√≥digo com Sprache</strong>. Voc√™ pode ler a segunda parte <a href="2021-02-13-parsing-code-with-sprache-part-2">aqui</a>.</p> </blockquote> <p>Voc√™ provavelmente sabe que √†s vezes (<em>muitas</em> vezes), o trabalho de um desenvolvedor √© muito mais pesquisa ou an√°lise do que programa√ß√£o! No passado, houve muitos casos em que eu estava em um projeto em que meu objetivo era migrar ou reescrever software antigo e, durante esses compromissos, acabei criando ferramentas para me ajudar. Muitas dessas ferramentas eram analisadores de c√≥digo especializados que realizavam automaticamente a an√°lise que eu exigia ou at√© mesmo geravam c√≥digos mais novos que eu poderia utilizar.</p> <p>Em todos esses casos, precisei analisar algum c√≥digo estruturado e h√° uma maneira simples de fazer isso: usando <a href="https://github.com/sprache/Sprache" target="_blank" rel="noopener noreferrer">Sprache</a>, um framework de parsing para dotnet. Neste artigo, vamos ver como fazer isso.</p> <!--more--> <h1 id="analisando-c√≥digo-java">Analisando c√≥digo Java</h1> <p>Voc√™ pode escrever todos os tipos de analisadores com Sprache. Contanto que a linguagem seja formal, √© f√°cil construir o c√≥digo necess√°rio, e voc√™ faz isso aproveitando todas as maravilhas da sintaxe C#. Vou propor um exemplo: um analisador para uma gram√°tica <strong>parcial</strong> Java ‚òï.</p> <p>Estou escolhendo Java porque √© complexo o suficiente para nos permitir ver como o Sprache pode tornar sua vida mais f√°cil; tab√©m por que o Java est√° pr√≥ximo do C#, ent√£o os leitores entender√£o rapidamente a maior parte dele; e porque a gram√°tica formal do Java √© estruturada de tal forma que √© poss√≠vel extrapolar sua gram√°tica sem muita pesquisa.</p> <p>Obviamente, escrever um analisador completo demoraria muito; teremos que nos limitar a um analisador parcial. A maneira como fazemos isso √© obter o c√≥digo que queremos analisar e, em seguida, especificar a gram√°tica exatamente para isso (eu chamo essa abordagem de <em>best fit</em>, importante princ√≠pio √°gil). Ent√£o, escolhi uma v√≠tima para este esfor√ßo: <a href="https://github.com/google/google-authenticator-android/tree/master/java/com/google/android/apps/authenticator" target="_blank" rel="noopener noreferrer">Google Authenticator</a> √© a fonte de um aplicativo Android que gera OTP‚Äôs. O aplicativo pode ser encontrado na <a href="https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&amp;hl=en_US&amp;gl=US" target="_blank" rel="noopener noreferrer">Play Store</a>.</p> <blockquote> <p>üòé Eu j√° ysei este c√≥digo-fonte como base para reproduzir o algoritmo de OTP, ent√£o estou familiarizado com ele.</p> </blockquote> <p>Para ter um objetivo tang√≠vel, iremos gerar um gr√°fico de depend√™ncias entre classes do c√≥digo; Isso deve ajud√°-lo a saber como fazer mais do que apenas a an√°lise, mas tamb√©m como usar o c√≥digo analisado para obter insights ou produzir outros artefatos.</p> <h1 id="java-bnf">Java BNF</h1> <p>O ponto de partida para nosso c√≥digo √© a gram√°tica formal do Java. O <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form" target="_blank" rel="noopener noreferrer">eBNF</a> - Nota√ß√£o ou Forma Backus-Naur Estendida - √© uma descri√ß√£o de uma gram√°tica formal. Por exemplo, um bloco <code class="language-plaintext highlighter-rouge">for</code> em Java pode ser:</p> <p>Exemplo:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span> <span class="o">}</span>
</code></pre></div></div> <p>Gram√°tica:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FORBLOCK = "for" "(" INITIALIZER ";" CONDITION ";" INCREMENT) BLOCK

INITIALIZER = ASSIGNMENT

ASSIGNMENT = TYPE VARIABLE "=" LITERAL 

CONDITION = BOOLEAN_EXPRESSION

INCREMENT = VARIABLE "++" | "++" VARIABLE

BLOCK = STATEMENT | "{" STATEMENT_LIST "}"
</code></pre></div></div> <blockquote> <p>‚ùó Esta gram√°tica est√° incompleta e n√£o necessariamente correta; Este √© um guia pr√°tico sobre como usar o Sprache, n√£o sobre BNF e linguagens formais.</p> </blockquote> <p>Portanto, come√ßamos observando nosso c√≥digo-alvo e criando uma pequena gram√°tica. Para manter as coisas simples, iremos escrever analisadores para cada fonte em <code class="language-plaintext highlighter-rouge">java/com/google/android/apps/authenticator/</code> e ignorar os arquivos n√£o-java.</p> <p>Por exemplo, d√™ uma olhada em <a href="https://github.com/google/google-authenticator-android/blob/master/java/com/google/android/apps/authenticator/AuthenticatorActivity.java" target="_blank" rel="noopener noreferrer">AuthenticatorActivity.java</a>, o primeiro arquivo no escopo. Voc√™ ver√° que as primeiras linhas s√£o coment√°rios e ent√£o temos uma instru√ß√£o <code class="language-plaintext highlighter-rouge">package</code>, seguida por v√°rias instru√ß√µes <code class="language-plaintext highlighter-rouge">import</code> e, finalmente, uma defini√ß√£o de <code class="language-plaintext highlighter-rouge">class</code>. Excluindo os coment√°rios (abordaremos isso mais tarde), a gram√°tica seria:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>JAVA_FILE = PACKAGE, IMPORT_LIST, CLASS_DECLARATIONS;

PACKAGE = "pacote", PACKAGE_NAME, ";";

PACKAGE_NAME = WORD, {"." PALAVRA };

WORD = CHARACTER, {CHARACTER};

CHARACTER = LETTER | DIGIT;

IMPORT_LIST = IMPORT, {IMPORT};

IMPORT = "importar", PACKAGE_NAME, ";";

CLASS_DECLARATION = "public", "class", WORD, "{" (*omitido*) "}";
</code></pre></div></div> <p>D√™ uma olhada nessa linguagem, compare-a com o arquivo, mas cheque-a contra seu conhecimento de Java (ou C#, apenas percebendo que essas duas linguagens s√£o muito semelhantes). Por um lado, voc√™ provavelmente ver√° que a gram√°tica acima pode ser usada para produzir o c√≥digo-fonte; por outro, voc√™ perceber√° rapidamente que ele n√£o leva em considera√ß√£o muitas constru√ß√µes que s√£o legais em Java: por exemplo, uma fonte pode n√£o ter <code class="language-plaintext highlighter-rouge">import</code>s quaisquer. Isso √© o que quero dizer com * melhor ajuste * - estamos procurando uma maneira de analisar <strong>apenas</strong> o c√≥digo no escopo.</p> <h1 id="configurando-o-projeto">Configurando o projeto</h1> <p>Assim que tivermos uma pequena gram√°tica, podemos come√ßar a codificar. Crie um novo projeto de biblioteca dotnet, adicione Sprache a ele via Nuget, crie um projeto de teste adicional com xUnit e baixe o c√≥digo-fonte do Google Authenticator paraum diret√≥rio.</p> <p>Definiremos estruturas de dados para armazenar cada elemento de nossa gram√°tica e um teste para verificar se a an√°lise funcionou conforme o esperado.</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// BNF classes</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">JavaFile</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Package</span> <span class="n">Package</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Import</span><span class="p">&gt;</span> <span class="n">ImportList</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="n">ClassDefinition</span> <span class="n">ClassDefinition</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Package</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">PackageName</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">PackageName</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">PackageName</span><span class="p">()</span> <span class="p">{}</span>

	<span class="k">public</span> <span class="nf">PackageName</span><span class="p">(</span><span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">identifers</span><span class="p">)</span> 
	<span class="p">{</span> 
		<span class="n">Identifiers</span> <span class="p">=</span> <span class="n">identifers</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">Identifiers</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Import</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">PackageName</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">ClassDefinition</span>
<span class="p">{</span>
    <span class="c1">// OMMITED</span>
<span class="p">}</span>
</code></pre></div></div> <p>Algumas coisas importantes a serem observadas na estrutura acima:</p> <ul> <li>Eu n√£o defini ImportList ou qualquer estrutura de lista - eu simplesmente usei o <code class="language-plaintext highlighter-rouge">List</code> gen√©rico do C#.</li> <li>Eu n√£o defini uma constru√ß√£o de WORD ainda - irei armazen√°-las simplesmente como strings por enquanto, j√° que n√£o estamos interessados ‚Äã‚Äãnela.</li> </ul> <p>Agora, como se parece um <em>parser</em>? Precisamos de algo que possa obter os dados da fonte - texto, afinal - e produzir as estruturas acima:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">interface</span> <span class="nc">IParser</span> <span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="nf">Parse</span> <span class="p">(</span><span class="n">c</span><span class="err">√≥</span><span class="n">digo</span> <span class="n">de</span> <span class="kt">string</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Este √© um analisador b√°sico para uma determinada defini√ß√£o <code class="language-plaintext highlighter-rouge">T</code> - √© apenas um √∫nico m√©todo que l√™ uma string e retorna a estrutura desejada. Come√ßaremos declarando um dos analisadores b√°sicos, o analisador <code class="language-plaintext highlighter-rouge">Package</code>. <em>Revisitaremos essas estrutura com o tempo.</em></p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageNameParser</span> <span class="p">:</span> <span class="n">IParser</span><span class="p">&lt;</span><span class="n">Package</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Package</span> <span class="nf">Parse</span><span class="p">(</span><span class="kt">string</span> <span class="n">code</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotImplementedException</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Este ser√° o nosso ponto de partida para o analisador.</p> <p>Com essas classes definidas, podemos passar √† configura√ß√£o dos testes.</p> <h1 id="os-primeiros-testes">Os primeiros testes</h1> <blockquote> <p>üòé Sempre escreva os testes primeiro.</p> </blockquote> <p>Usarei o xUnit, que provavelmente √© o melhor framework de testes para C#. Voc√™ pode adaptar o c√≥digo abaixo para o que quiser.</p> <p>O primeiro caso de teste deve ser um ‚Äúaquecimento‚Äù, ent√£o testamos o que acontece quando o c√≥digo √© <code class="language-plaintext highlighter-rouge">nulo</code>.</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageNameParserTests</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenCodeNull_Throws</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">sut</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">PackageNameParser</span><span class="p">();</span>

        <span class="n">Assert</span><span class="p">.</span><span class="n">Throws</span><span class="p">&lt;</span><span class="n">ArgumentNullException</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="n">sut</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="k">null</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Execute o teste - ele falhar√°, como de costume, em conformidade com uma abordagem <em>red-green-refactor</em>. A pr√≥xima etapa √© deix√°-lo verde:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageNameParser</span> <span class="p">:</span> <span class="n">IParser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">PackageName</span> <span class="nf">Parse</span><span class="p">(</span><span class="kt">string</span> <span class="n">code</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentNullException</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">code</span><span class="p">));</span>

        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotImplementedException</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Execute-o novamente e o teste ser√° aprovado. O aquecimento est√° feito, nosso pr√≥ximo passo √© criar um caminho feliz. Queremos testar se podemos capturar corretamente o nome do pacote:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackage_ReturnsName</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">packageExpresison</span> <span class="p">=</span> <span class="s">"package tinyJavaParser;"</span><span class="p">;</span>

    <span class="kt">var</span> <span class="n">sut</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">PackageNameParser</span><span class="p">();</span>
    
    <span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">sut</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">packageExpresison</span><span class="p">);</span>

    <span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">"tinyJavaParser"</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Indentifiers</span><span class="p">[</span><span class="m">0</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Execute-o e o teste falhar√°. Vamos implementar nosso primeiro analisador Sprache!</p> <h2 id="analisadores-sprache">Analisadores Sprache</h2> <p>Se voc√™ der uma olhada no README do Sprache, saber√° rapidamente como trabalhar com ele. Tudo come√ßa com o objeto <code class="language-plaintext highlighter-rouge">Parse</code> est√°tico, que pode ser chamado para analisar v√°rios tipos de textos. Voc√™ constr√≥i um analisador complexo combinando esses analisadores b√°sicos usando LINQ.</p> <p>Por exemplo, nosso nome de pacote √© uma string feita de chars, ent√£o podemos usar <code class="language-plaintext highlighter-rouge">Sprache.Parse.Letter</code> para analis√°-lo, mas primeiro devemos levar em conta a palavra-chave<code class="language-plaintext highlighter-rouge"> package</code> e espa√ßos que vem antes:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">parser</span> <span class="p">=</span>
    <span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
    <span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
    <span class="k">from</span> <span class="n">packageName</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">Letter</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">()</span>
    <span class="k">from</span> <span class="n">ending</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
    <span class="k">select</span> <span class="k">new</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="n">Indentifiers</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="p">{</span> <span class="n">packageName</span> <span class="p">}</span> <span class="p">};</span>
</code></pre></div></div> <p>Vejamos linha por linha. Em primeiro lugar, consideramos a palavra-chave do pacote, afirmando claramente que ela deve aparecer apenas <strong>uma vez</strong>:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
</code></pre></div></div> <p>Ent√£o sabemos que haver√° alguns espa√ßos entre a palavra-chave e o identificador:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">from</span> <span class="n">space1</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
</code></pre></div></div> <p>Depois disso, extra√≠mos o nome do pacote, que √© uma sequ√™ncia de letras:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">from</span> <span class="n">packageName</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">Letter</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">()</span>
</code></pre></div></div> <p>E, finalmente, certificamo-nos de que a linha termina com um <code class="language-plaintext highlighter-rouge">;</code>:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">from</span> <span class="n">ending</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
</code></pre></div></div> <p>Depois de fazer tudo isso, podemos produzir a estrutura analisada, <code class="language-plaintext highlighter-rouge">PackageName</code>, usando os dados que coletamos antes:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">select</span> <span class="k">new</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="n">Indentifiers</span> <span class="p">=</span> <span class="k">new</span><span class="p">()</span> <span class="p">{</span> <span class="n">packageName</span> <span class="p">}</span> <span class="p">};</span>
</code></pre></div></div> <p>Vamos usar esse conhecimento e implementar o m√©todo:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">PackageName</span> <span class="nf">Parse</span><span class="p">(</span><span class="kt">string</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentNullException</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">code</span><span class="p">));</span>

    <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">parser</span> <span class="p">=</span>
        <span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">packageName</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">Letter</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">ending</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
        <span class="k">select</span> <span class="k">new</span> <span class="nf">PackageName</span><span class="p">(</span><span class="k">new</span><span class="p">()</span> <span class="p">{</span> <span class="n">packageName</span> <span class="p">})</span> <span class="p">};</span>

    <span class="k">return</span> <span class="n">parser</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Execute os testes, voc√™ obter√° üü¢. Agora, antes de passarmos para <em>refatorar</em>, quero melhorar o teste que acabamos de fazer e torn√°-lo mais gen√©rico.</p> <p>O teste considera apenas um nome de pacote com uma √∫nica palavra. Isso n√£o √© suficiente, e talvez voc√™ j√° tenha adivinhado que os identificadores compostos falhar√£o. Adicionaremos alguns outros exemplos, e a melhor fonte para eles √© - voc√™ adivinhou! - o c√≥digo-fonte do Autenticador.</p> <blockquote> <p>Voc√™ pode perceber que tamb√©m n√£o consideramos poss√≠veis identificadores que tenham letras ou s√≠mbolos como sublinhado. Mas, para manter nosso objetivo, n√£o precisamos de um analisador que leia todos os c√≥digos Java v√°lidos j√° escritos, em vez disso, apenas algo que analise o fonte com o qual estamos lidando. Isso pode n√£o ser o caso em outros projetos onde voc√™ precise de um parser - por exemplo, talvez voc√™ n√£o tenha acesso total ao c√≥digo antes de executar o analisador e, nesse caso, voc√™ precisar√° dar um mergulho profundo no defini√ß√£o de linguagem. Da mesma forma, nosso analisador n√£o est√° tentando validar o c√≥digo que est√° consumindo - seja o que for que encontrarmos nesses arquivos, aceitamos que seja Java v√°lido. Novamente, voc√™ pode querer adotar uma abordagem diferente, por exemplo, se este analisador for alimentado com c√≥digo escrito apenas para ele, j√° que ent√£o voc√™ ter√° pessoas cometendo erros e precisar√° dizer a elas quais s√£o.</p> </blockquote> <p>Para encontrar os exemplos de pacotes, usei apenas o VSCode para abrir o diret√≥rio onde o c√≥digo est√°, <code class="language-plaintext highlighter-rouge">java/com/google/android/apps/authenticator/</code>, e abri a ferrament de pesquisa:</p> <p><img src="../../../assets/vscode-search-example.png" alt="Caixa de pesquisa em VSCode"></p> <p>E agora mudamos o teste de <code class="language-plaintext highlighter-rouge">Fact</code> para <code class="language-plaintext highlighter-rouge">Theory</code> usando alguns desses nomes:</p> <blockquote> <p>Eu examinei a lista de pacotes e escolhi aqueles que achei representativos do dom√≠nio do nome. Vamos, depois, analisar tudo, mas √© importante que antes disso j√° tenhamos alguns bons testes em funcionamento.</p> </blockquote> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"tinyJavaParser"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"com.google.android.apps.authenticator"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"com.google.android.apps.authenticator.enroll2sv.wizard"</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackage_ReturnsName</span><span class="p">(</span><span class="kt">string</span> <span class="n">packageName</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">packageExpresison</span> <span class="p">=</span> <span class="s">$"package </span><span class="p">{</span><span class="n">packageName</span><span class="p">}</span><span class="s">;"</span><span class="p">;</span>

    <span class="kt">var</span> <span class="n">sut</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">PackageNameParser</span><span class="p">();</span>

    <span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">sut</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">packageExpresison</span><span class="p">);</span>

    <span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">packageName</span><span class="p">,</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Identifiers</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div> <p>Tome seu tempo para entender as mudan√ßas que fizemos no teste. Lembre-se de que a etapa <em>refatorar</em> se aplica tamb√©m aos testes, portanto, embora possamos <em>poder</em> manter o teste como estava e apenas adicionar uma nova teoria, isso √© mais limpo, ou seja, mais f√°cil de manter.</p> <p>Agora executamos os testes e, claro, üî¥. √â hora de corrigir o c√≥digo.</p> <p>Primeiro, tentamos corrigi-lo para * com.google.android.apps.authenticator *, contabilizando v√°rios identificadores:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">PackageName</span> <span class="nf">Parse</span><span class="p">(</span><span class="kt">string</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentNullException</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">code</span><span class="p">));</span>

    <span class="n">Parser</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">identifierParser</span> <span class="p">=</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">Letter</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">();</span>

    <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">parser</span> <span class="p">=</span>
        <span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">packageHead</span> <span class="k">in</span> <span class="n">identifierParser</span>
        <span class="k">from</span> <span class="n">packageTail</span> <span class="k">in</span> <span class="p">(</span><span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'.'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
                                <span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">identifierParser</span>
                                <span class="k">select</span> <span class="n">identifier</span><span class="p">).</span><span class="nf">Many</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">terminator</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
        <span class="k">select</span> <span class="k">new</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="n">Identifiers</span> <span class="p">=</span> <span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="n">packageHead</span> <span class="p">}).</span><span class="nf">Concat</span><span class="p">(</span><span class="n">packageTail</span><span class="p">).</span><span class="nf">ToList</span><span class="p">()</span> <span class="p">};</span>

    <span class="k">return</span> <span class="n">parser</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Vamos mais uma vez dissecar o c√≥digo.</p> <p>Come√ßamos criando um ‚Äúsub parser‚Äù, por assim dizer, que l√™ um identificador. Deve ser muito simples, pois √© o mesmo c√≥digo que t√≠nhamos antes - pegue o m√°ximo de letras em sequ√™ncia poss√≠vel e converta em ‚Äútexto‚Äù, ou seja, uma <code class="language-plaintext highlighter-rouge">string</code>.</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">identifierParser</span> <span class="p">=</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">Letter</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">();</span>
</code></pre></div></div> <p>Agora incrementamos as regras de an√°lise antigas para contabilizar as repeti√ß√µes de identificadores. Fazemos isso obtendo pelo menos o primeiro identificador e, opcionalmente, muitos outros. <code class="language-plaintext highlighter-rouge">packageTail</code> tamb√©m usa um sub-analisador que eu n√£o declarei, ent√£o √© embutido porque s√≥ faz sentido dentro deste analisador.</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span> <span class="n">packageHead</span> <span class="k">in</span> <span class="n">identifierParser</span>
<span class="k">from</span> <span class="n">packageTail</span> <span class="k">in</span> <span class="p">(</span><span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'.'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
                        <span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">identifierParser</span>
                        <span class="k">select</span> <span class="n">identifier</span><span class="p">).</span><span class="nf">Many</span><span class="p">()</span>
</code></pre></div></div> <p>Finalmente, precisamos criar uma lista a partir do identificador √∫nico <code class="language-plaintext highlighter-rouge">packageHead</code> e os m√∫ltiplos em<code class="language-plaintext highlighter-rouge"> packageTail</code>, ent√£o eu trapacei um pouco:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="k">new</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="n">Identifiers</span> <span class="p">=</span> <span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="n">packageHead</span> <span class="p">}).</span><span class="nf">Concat</span><span class="p">(</span><span class="n">packageTail</span><span class="p">).</span><span class="nf">ToList</span><span class="p">()</span> <span class="p">};</span>
</code></pre></div></div> <p>Eu crio um array apenas com o packageHead (<code class="language-plaintext highlighter-rouge">new [] {packageHead}</code>) e concateno-o wcom <code class="language-plaintext highlighter-rouge">packageTail</code>. Depois disso, eu apenas chamo <code class="language-plaintext highlighter-rouge">ToList()</code> para transformar o array resultante em uma lista.</p> <p>Isso testar√° üü¢ verde para <code class="language-plaintext highlighter-rouge">"com.google.android.apps.authenticator"</code>, mas ainda falhar√° para <code class="language-plaintext highlighter-rouge">"com.google.android.apps.authenticator.enroll2sv.wizard "</code>. Vamos dar uma olhada no erro:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Message: 
    Sprache.ParseException : Parsing failure: unexpected '2'; expected ; (Line 1, Column 53); recently consumed: tor.enroll
</code></pre></div></div> <p>Sprache est√° nos dizendo que h√° um <code class="language-plaintext highlighter-rouge">2</code> que ele n√£o esperava no stream e que acabou de consumir <code class="language-plaintext highlighter-rouge">"tor.enroll"</code>. Se olharmos para a string de entrada, √© f√°cil ver por que ela falha:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                         Apenas leia daqui
                                  ‚Üì
com.google.android.apps.authenticator.enroll2sv.wizard
                                            ‚Üë
                                      Falhou aqui
</code></pre></div></div> <p>Portanto, como esperado, o n√∫mero 2 n√£o √© permitido. Isso √© apenas uma quest√£o de expandir a defini√ß√£o de <code class="language-plaintext highlighter-rouge">identifierParser</code> para levar isso em considera√ß√£o:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">identifierParser</span> <span class="p">=</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">LetterOrDigit</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">();</span>
</code></pre></div></div> <p>Fa√ßa testes e aprecie seu üü¢!</p> <h2 id="refatorar">Refatorar!</h2> <p>Agora √© a hora de refatorar o c√≥digo. Veremos como tornar nosso c√≥digo mais simples de manter e usar.</p> <p>H√° duas coisas que devemos observar:</p> <ul> <li> <p>Em <code class="language-plaintext highlighter-rouge">PackageNameParser.Parse</code>, criamos duas inst√¢ncias de parser, <code class="language-plaintext highlighter-rouge">identifierParser</code> e <code class="language-plaintext highlighter-rouge">parser</code>. Eles s√£o usados ‚Äã‚Äãapenas uma vez, logo no retorno. V√°rias chamadas para este m√©todo resultam na recria√ß√£o dessas inst√¢ncias, mas podem ser reutilizadas. Isso tamb√©m √© evidenciado pelos documentos do Sprache.</p> </li> <li> <p>Definimos uma interface <code class="language-plaintext highlighter-rouge">IParser&lt;T&gt;</code>, e Sprache tem um delegate <code class="language-plaintext highlighter-rouge">Parser&lt;out T&gt;</code>, que √© muito pr√≥ximo ao nosso. O Sprache pode definir analisadores usando seu delegate, e podemos combin√°-los para produzir analisadores novos e mais complexos.</p> </li> </ul> <p>Com esse conhecimento, devemos refatorar nosso c√≥digo para definir uma vez e usar os analisadores v√°rias vezes; Devemos tamb√©m abandonar nossa interface de an√°lise e usar o delegado do Sprache. A maneira de fazer as coisas do Sprache √© definir esses delegados como membros est√°ticos de uma classe, para que possamos criar:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">JavaGrammar</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">Identifier</span> <span class="p">=</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">LetterOrDigit</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">();</span>

	<span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">PackageName</span> <span class="p">=</span>
		<span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
		<span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
		<span class="k">from</span> <span class="n">packageHead</span> <span class="k">in</span> <span class="n">Identifier</span>
		<span class="k">from</span> <span class="n">packageTail</span> <span class="k">in</span> <span class="p">(</span><span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'.'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
								<span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">Identifier</span>
								<span class="k">select</span> <span class="n">identifier</span><span class="p">).</span><span class="nf">Many</span><span class="p">()</span>
		<span class="k">from</span> <span class="n">terminator</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
		<span class="k">select</span> <span class="k">new</span> <span class="nf">PackageName</span><span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="n">packageHead</span> <span class="p">}.</span><span class="nf">Concat</span><span class="p">(</span><span class="n">packageTail</span><span class="p">).</span><span class="nf">ToList</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div> <p>E mudar os testes para refletir isso:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageNameParserTests</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenCodeNull_Throws</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Assert</span><span class="p">.</span><span class="n">Throws</span><span class="p">&lt;</span><span class="n">ArgumentNullException</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">PackageName</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="k">null</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
    <span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"tinyJavaParser"</span><span class="p">)]</span>
    <span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"com.google.android.apps.authenticator"</span><span class="p">)]</span>
    <span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"com.google.android.apps.authenticator.enroll2sv.wizard"</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackage_ReturnsName</span><span class="p">(</span><span class="kt">string</span> <span class="n">packageName</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">packageExpresison</span> <span class="p">=</span> <span class="s">$"package </span><span class="p">{</span><span class="n">packageName</span><span class="p">}</span><span class="s">;"</span><span class="p">;</span>

        <span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">PackageName</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">packageExpresison</span><span class="p">);</span>

        <span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">packageName</span><span class="p">,</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Identifiers</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>‚ùó Se voc√™ estiver recebendo um erro informando que o delegado n√£o tem um m√©todo Parse, n√£o se preocupe! Voc√™ apenas tem que adicionar uma diretiva <code class="language-plaintext highlighter-rouge">using Sprache;</code> no topo do arquivo.</p> </blockquote> <p>Voc√™ pode remover a interface IParser que criamos para nos ajudar a definir como o c√≥digo deve ser.</p> <h1 id="an√°lise">An√°lise</h1> <p>Ufs, demorou muito! ‚ÄúN√≥s vimos muito! Vamos revisar tudo isso por um momento, certo?</p> <ul> <li>Voc√™ aprendeu que as sintaxes de linguagem s√£o governadas por * gram√°ticas * e que podem ser expressas com uma nota√ß√£o conhecida como BNF ou EBNF.</li> <li>Voc√™ criou um EBNF simplificado para Java, levando em considera√ß√£o apenas o que estava no escopo. Voc√™ sabe que chamamos isso de * melhor ajuste *, e um princ√≠pio √°gil semelhante ao YAGNI - construa apenas o que voc√™ vai usar.</li> <li>Voc√™ criou v√°rios casos de teste, a maioria derivados do pr√≥prio dom√≠nio do problema - a fonte do Autenticador do Google.</li> <li>Voc√™ aprendeu como combinar analisadores Sprache para criar outro analisador mais complexo.</li> </ul> <p>Isso lan√ßou as bases para analisar as estruturas de programa mais complexas. No pr√≥ximo artigo, terminaremos nossa gram√°tica criando mais analisadores que podem lidar com todo o c√≥digo-fonte. Tamb√©m mostrarei como lidar com coment√°rios e como ‚Äúpular‚Äù c√≥digo no qual voc√™ n√£o est√° interessado. Seguindo esse artigo, como um b√¥nus, terminaremos de construir nossa ferramenta e gerar o gr√°fico que mostrar√° aos usu√°rios a rela√ß√£o entre as aulas.</p> <p>Todo o c√≥digo produzido at√© agora foi armazenado no <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser" target="_blank" rel="noopener noreferrer">Github</a>. Voc√™ pode fazer um fork e us√°-lo da maneira que quiser. Para obter a vers√£o exata deste c√≥digo, use <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser/releases/tag/FirstArticle" target="_blank" rel="noopener noreferrer">esta tag</a>.</p> <br> <div class="tag-list"> <a href="/pt/tags/#dotnet">#dotnet</a> ¬† <a href="/pt/tags/#programa%C3%A7%C3%A3o">#programa√ß√£o</a> ¬† <a href="/pt/tags/#linguagem">#linguagem</a> </div> </article> <div class="PageNavigation"> <a class="prev" href="/pt/happy-halloween-blog-is-back/">‚Üê Anterior</a> <a class="next" href="/pt/read-my-blog-in-portuguese/">Pr√≥ximo ‚Üí</a> </div> <aside class="related"> <h3>Related Posts</h3> <ul class="related-posts"> <li> <a href="/pt/parsing-code-with-sprache-part-2/"> Analisando c√≥digo com Sprache - Parte 2 <small><time datetime="2021-03-13T10:00:00+00:00">March 13th, 2021</time></small> </a> </li> <li> <a href="/pt/read-my-blog-in-portuguese/"> Leia meu blog em portugu√™s ou ingl√™s! <small><time datetime="2021-02-17T00:00:00+00:00">February 17th, 2021</time></small> </a> </li> <li> <a href="/pt/happy-halloween-blog-is-back/"> Feliz Halloween! Meu blog est√° de volta! <small><time datetime="2020-10-31T18:00:00+00:00">October 31st, 2020</time></small> </a> </li> </ul> </aside> </main> <footer class="footer"> <div class="wrapper"> <div> ¬© Copyright 2021 Bruno Brant. Tema baseado em <a href="https://github.com/essentialenemy/noir/" target="_blank" rel="noopener noreferrer">Noir</a> de <a href="https://essentialenemy.com/" target="_blank" rel="noopener noreferrer">Victor Johnson</a>. </div> <div class="social-links">
<ul class="social-media-list">
<li><a rel="noopener noreferrer" href="https://github.com/bruno-brant" title="bruno-brant" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li>
<li><a rel="noopener noreferrer" href="https://stackoverflow.com/users/227332%2Fbruno-brant" title="227332/bruno-brant" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#stackoverflow"></use></svg></a></li>
<li><a rel="noopener noreferrer" href="https://www.linkedin.com/in/brunobrant" title="brunobrant" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg></a></li>
<li><a rel="noopener noreferrer" href="https://twitter.com/HeavyStorm" title="HeavyStorm" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li>
</ul> </div> </div> </footer> </div> </body> </html>
