<!doctype html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <meta property="og:image" content="https://blog.brunobrant.net/assets/technology-matters-logo.png" /> <title> &middot; TECHNOLOGY MATTERS </title> <link rel="stylesheet" href="/styles.css"> <!-- <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/apple-touch-icon-precomposed.png"> --> <link rel="shortcut icon" href="/assets/favicon.ico"> <link rel="alternate" type="application/atom+xml" title="TECHNOLOGY MATTERS" href="/feed.xml"> <!-- Begin Jekyll SEO tag v2.7.1 --> <meta name="generator" content="Jekyll v4.1.1" /> <meta property="og:title" content="Parsing code with Sprache - Part 1" /> <meta name="author" content="Bruno Brant" /> <meta property="og:locale" content="en" /> <meta name="description" content="😎 This the second article of a multiple part series on _how to parse code with Sprache. You can read the second part here. You probably know that sometimes (many times), a developer’s job is much more research or analysis than programming! In the past, there have been many instances where I was on a project where my goal was to migrate or rewrite old software, and during those engagements, I ended up creating tools to help me. Many of those tools were specialized code parsers that would automatically perform the analysis I required or even spit out newer code that I could reuse. In all those cases, I needed to parse some structured code, and there’s a simple way of doing this: by using Sprache, a parsing framework for dotnet. In this article, I’m going to teach you how to do that. Parsing Java code You can write all sorts of parsers with Sprache. As long as the language is formal, it’s easy to build the necessary code, and you do that leveraging all of C# syntax greatness. I will propose an example: a parser to a partial Java ☕ grammar. I’m choosing Java because it’s complex enough to let us see how Sprache can make your life easier; because Java is close to C#, so readers will quickly understand most of it; and because Java’s formal grammar is structured in such a way that one can extrapolate its grammar without much research. Of course, writing a full parser would take too long; we will have to constrain ourselves to a partial analyzer. The way we do that is to get the code we want to parse and then specify the grammar for just that (I call this approach best fit, an important agile principle). So I decided on a victim for this endeavor: Google Authenticator is the source of an Android app that generates OTP’s. The app can be found in the Play Store. 😎 I’ve used this source code to reproduce the OTP algorithm, so I’m familiar with it. To have a tangible goal, we will output a graph of class dependencies; This should help you get how to do more than just the parsing but also how to use the parsed code to get insight or produce other artifacts. Java BNF The starting point for our code is the formal grammar for Java. The eBNF - Extended Backus-Naur Form or notation - is a description of a formal grammar. For instance, a for block in Java can be: Example: for (int i = 0; i &lt; 100; i++) { System.out.println(i); } Grammar: FORBLOCK = &quot;for&quot; &quot;(&quot; INITIALIZER &quot;;&quot; CONDITION &quot;;&quot; INCREMENT) BLOCK INITIALIZER = ASSIGNMENT ASSIGNMENT = TYPE VARIABLE &quot;=&quot; LITERAL CONDITION = BOOLEAN_EXPRESSION INCREMENT = VARIABLE &quot;++&quot; | &quot;++&quot; VARIABLE BLOCK = STATEMENT | &quot;{&quot; STATEMENT_LIST &quot;}&quot; ❗ This grammar is incomplete and not necessarily correct; This is a practical guide on using Sprache, not on BNF and formal languages. So we begin by looking at our target code and creating a small grammar. To keep things simple, we will be writing parsers for every source in java/com/google/android/apps/authenticator/ and ignore non-java files. For instance, take a look at AuthenticatorActivity.java, the first file in scope. You will see that the first few lines are comments, and then we have a package instruction, followed by several import statements, and finally a class definition. Excluding the comments (we will touch on that later), the grammar would be: JAVA_FILE = PACKAGE, IMPORT_LIST, CLASS_DECLARATIONS; PACKAGE = &quot;package&quot;, PACKAGE_NAME, &quot;;&quot;; PACKAGE_NAME = WORD, { &quot;.&quot; WORD }; WORD = CHARACTER, { CHARACTER }; CHARACTER = LETTER | DIGIT; IMPORT_LIST = IMPORT, { IMPORT }; IMPORT = &quot;import&quot;, PACKAGE_NAME, &quot;;&quot;; CLASS_DECLARATION = &quot;public&quot;, &quot;class&quot;, WORD, &quot;{&quot; (* ommited *) &quot;}&quot;; Take a look at that language, compare it to the file, but check it against your knowledge of Java (or C#, just by realizing that those two languages are very similar). On one hand, you’ll probably see that the grammar above could be used to produce the source code; on the other, you’ll quickly realize that it doesn’t account for many constructs that are legal in Java: for instance, a source could have no imports whatsoever. That’s what I meant by best fit - we are looking for a way to parse only the code in scope. Setting up the project Once we have a small grammar, we can start to code. Create a new dotnet library project, add Sprache to it via Nuget, create an additional test project with xUnit, and download Google Authenticator’s source to a directory. We will define data structures to store each element of our grammar, and a test to check if the parse worked as expected. // BNF classes public class JavaFile { public Package Package { get; private set; } public List&lt;Import&gt; ImportList { get; private set; } public ClassDefinition ClassDefinition { get; private set; } } public class Package { public PackageName PackageName { get; set; } } public class PackageName { public PackageName() {} public PackageName(List&lt;string&gt; identifers) { Identifiers = identifers; } public List&lt;string&gt; Identifiers { get; } = new List&lt;string&gt;(); } public class Import { public PackageName PackageName { get; set; } } public class ClassDefinition { // OMMITED } A few important things to note on the structure above: I didn’t define ImportList or any list structures - I simply used the List generic from C#. I didn’t define a WORD construct yet - I will be storing those simply as strings for the time being since we’re not interested in it. Now, how does a parser looks like? We need something that can get the data from the source - text, after all - and produce the structures above: interface IParser&lt;T&gt; { T Parse(string code); } This is a basic parser for a certain definition T - it’s just a single method that reads a string and returns the desired structure. We’ll begin by declaring one of the basics parsers, the Package parser. We’ll revisit this structure in time. public class PackageNameParser : IParser&lt;Package&gt; { public Package Parse(string code) { throw new NotImplementedException(); } } This will be our starting point for the parser. With those classes defined, we can move into setting up the tests. The first few tests 😎 Always write tests first. I’ll be using xUnit, which is probably the best testing framework for C#. You can adapt the code below to anything you want, though. The first test case should be a warm-up, so we test what happens when code is null. public class PackageNameParserTests { [Fact] public void Parse_WhenCodeNull_Throws() { var sut = new PackageNameParser(); Assert.Throws&lt;ArgumentNullException&gt;(() =&gt; sut.Parse(null)); } } Run the test - it will fail, as usual, complying with a red-green-refactor approach. The next step is to turn it green: public class PackageNameParser : IParser&lt;PackageName&gt; { public PackageName Parse(string code) { if (code == null) throw new ArgumentNullException(nameof(code)); throw new NotImplementedException(); } } Run it again and the test will pass. The warm-up is done, our next step is to create a happy path. We want to test that we can correctly capture the package name: [Fact] public void Parse_WhenValidPackage_ReturnsName() { var packageExpresison = &quot;package tinyJavaParser;&quot;; var sut = new PackageNameParser(); var actual = sut.Parse(packageExpresison); Assert.Equal(&quot;tinyJavaParser&quot;, actual.Indentifiers[0]); } Run it and the test will fail. Let’s implement our first Sprache parser! Sprache parsers If you take a look at Sprache’s README, you’ll quickly grasp how to work with it. All begins with the static Parse object, which call be called to parse multiple types of texts. You build a complex parser by combining those basic parsers using LINQ. For instance, our package name is a string made up of chars, so we can use Sprache.Parse.Letter to parse it, but first we must account for the package keyword and whitespace that comes before: Parser&lt;PackageName&gt; parser = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() from packageName in Sprache.Parse.Letter.Many().Text() from ending in Sprache.Parse.Char(&#39;;&#39;) select new PackageName { Indentifiers = new List&lt;string&gt; { packageName } }; Let’s look at it line by line. First, we account for the package keyword, stating clearly that it must appear only once: from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() Then we know that there’ll be some spaces between the keyword and the identifier: from space1 in Sprache.Parse.WhiteSpace.Many() After that we extract the package name, which is a sequence of letters: from packageName in Sprache.Parse.Letter.Many().Text() And finally, we make sure the line ends with a ;: from ending in Sprache.Parse.Char(&#39;;&#39;) Once we did all that, we can produce the parsed structure, PackageName, using the data we gathered before: select new PackageName { Indentifiers = new() { packageName } }; Let’s use this knowledge and implement the method: public PackageName Parse(string code) { if (code == null) throw new ArgumentNullException(nameof(code)); Parser&lt;PackageName&gt; parser = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() from packageName in Sprache.Parse.Letter.Many().Text() from ending in Sprache.Parse.Char(&#39;;&#39;) select new PackageName(new() { packageName }) }; return parser.Parse(code); } Run the tests, you’ll get 🟢. Now, before we go on to refactor, I want to improve the test we just made, and make it more generic. The test is only accounting for a package name with a single word. This is not enough, and maybe you already guessed that composed identifiers will fail. We’ll add some other examples, and the best source for those is - you’ve guessed it! - the Authenticator source code. You may realize that we are also not accounting for possible identifiers that those that have letters or symbols such as underscore. But in keeping with our goal, we don’t need a parser that will read every legal Java code ever written, instead, just something that will parse the source we’re dealing with. This might not be the case on other projects where you need a parser - for instance, maybe you don’t have full access to the code before running the parser, and in that case, you’ll need to take a deep dive into the language definition. Likewise, our parser isn’t trying to validate the code that it’s consuming - whatever we find on those files we accept that it’s valid Java. Again, you may want to take a different approach, for instance if this parser is going to be fed code written just for it, since then you’ll have people making mistakes and you’ll need to tell them what those are. To find the examples of packages, I just used VSCode to open the directory where the code is, java/com/google/android/apps/authenticator/, and went to search: And now we turn the test from Fact to Theory using some of those names: I eyeballed the list of packages and picked those that I found to be representative of the domain of the name. We’ll, afterward, parse everything but it’s important that before that we already have some good testing in place. [Theory] [InlineData(&quot;tinyJavaParser&quot;)] [InlineData(&quot;com.google.android.apps.authenticator&quot;)] [InlineData(&quot;com.google.android.apps.authenticator.enroll2sv.wizard&quot;)] public void Parse_WhenValidPackage_ReturnsName(string packageName) { var packageExpresison = $&quot;package {packageName};&quot;; var sut = new PackageNameParser(); var actual = sut.Parse(packageExpresison); Assert.Equal(packageName, string.Join(&#39;.&#39;, actual.Identifiers)); } Take your time understanding the changes we’ve made to the test. Remember that the refactor step applies also to tests so, while we could keep the test as it was and just add a new theory, this is cleaner, i.e., easier to maintain. Now we run the tests and, of course, 🔴. Time to correct the code. First we try to fix it for com.google.android.apps.authenticator, by accounting for multiple identifiers: public PackageName Parse(string code) { if (code == null) throw new ArgumentNullException(nameof(code)); Parser&lt;string&gt; identifierParser = Sprache.Parse.Letter.Many().Text(); Parser&lt;PackageName&gt; parser = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() from packageHead in identifierParser from packageTail in (from delimiter in Sprache.Parse.Char(&#39;.&#39;).Once() from identifier in identifierParser select identifier).Many() from terminator in Sprache.Parse.Char(&#39;;&#39;) select new PackageName { Identifiers = (new[] { packageHead }).Concat(packageTail).ToList() }; return parser.Parse(code); } Let’s once again dissect the code. We begin by creating a “sub parser”, so to speak, that reads an identifier. It should be very straightforward since it’s the same code that we had before - get as many letters in sequence as possible, and convert it to “text”, i.e., a string. Parser&lt;string&gt; identifierParser = Sprache.Parse.Letter.Many().Text(); Now we increment the old parsing rules to account for repetitions of identifiers. We do this by getting at least the first identifier and then, optionally, many others. packageTail also uses a sub parser that I didn’t declare, so it’s inlined because it only makes sense inside this parser. from packageHead in identifierParser from packageTail in (from delimiter in Sprache.Parse.Char(&#39;.&#39;).Once() from identifier in identifierParser select identifier).Many() Finally, we need to create a list from the single identifier packageHead and the multiples in packageTail, so I cheated a bit: select new PackageName { Identifiers = (new[] { packageHead }).Concat(packageTail).ToList() }; I create an array with just the packageHead (new[] { packageHead }) and concatenate it with packageTail. After that, I just call ToList() to turn the resulting array into a list. This will test green 🟢 for &quot;com.google.android.apps.authenticator&quot;, but still fails for &quot;com.google.android.apps.authenticator.enroll2sv.wizard&quot;. Let’s take a look at the error: Message: Sprache.ParseException : Parsing failure: unexpected &#39;2&#39;; expected ; (Line 1, Column 53); recently consumed: tor.enroll Sprache is telling us there’s a 2 it didn’t expect in the stream, and that it just had consumed &quot;tor.enroll&quot;. If we look at the input string, it’s easy to see why it fails: Just read from here ↓ com.google.android.apps.authenticator.enroll2sv.wizard ↑ Failed here So, as expected, the number 2 isn’t allowed. This is just a matter of expanding the identifierParser definition to take that into account: Parser&lt;string&gt; identifierParser = Sprache.Parse.LetterOrDigit.Many().Text(); Run tests and appreciate your 🟢! Refactor! Now it’s time we refactor the code. We will look at how to make our code simpler to maintain and use. There two things that we should take notice of: In PackageNameParser.Parse we create two parser instances, identifierParser and parser. They are then used only once, right at the return. Multiple calls to this method result in recreating those instances, but they can be reused. This is made evident by Sprache docs as well. We defined an IParser&lt;T&gt; interface, and Sprache has a Parser&lt;out T&gt; delegate, which is very close to ours. Sprache can define parsers using its delegate, and we can combine those to produce new, more complex, parsers. With this knowledge, we should refactor our code to define once and use the parsers multiple times; We should also ditch our parsing interface and use Sprache’s delegate. Sprache way of doing things is defining those delegates as static members of a class, so we could create: public static class JavaGrammar { public static readonly Parser&lt;string&gt; Identifier = Sprache.Parse.LetterOrDigit.Many().Text(); public static readonly Parser&lt;PackageName&gt; PackageName = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() from packageHead in Identifier from packageTail in (from delimiter in Sprache.Parse.Char(&#39;.&#39;).Once() from identifier in Identifier select identifier).Many() from terminator in Sprache.Parse.Char(&#39;;&#39;) select new PackageName(new[] { packageHead }.Concat(packageTail).ToList()); } And changing the tests to reflect that: public class PackageNameParserTests { [Fact] public void Parse_WhenCodeNull_Throws() { Assert.Throws&lt;ArgumentNullException&gt;(() =&gt; JavaGrammar.PackageName.Parse(null)); } [Theory] [InlineData(&quot;tinyJavaParser&quot;)] [InlineData(&quot;com.google.android.apps.authenticator&quot;)] [InlineData(&quot;com.google.android.apps.authenticator.enroll2sv.wizard&quot;)] public void Parse_WhenValidPackage_ReturnsName(string packageName) { var packageExpresison = $&quot;package {packageName};&quot;; var actual = JavaGrammar.PackageName.Parse(packageExpresison); Assert.Equal(packageName, string.Join(&#39;.&#39;, actual.Identifiers)); } } ❗ If you’re getting an error that the delegate doesn’t have a Parse method, fret not! You just have to add a using Sprache; directive at the top of the file. You can remove the IParser interface that we created to help us define how the code should look like. Review Ufs, that was long! 😩We’ve seen a lot! Let’s review all that for a moment, shall we? You’ve learned that language syntaxes are governed by grammars and that those can be expressed with a notation known as BNF or EBNF. You’ve created a simplified EBNF for Java, taking into account only what was in scope. You know we call this best fit, and an agile principle that is similar to YAGNI - build only what you’re going to use. You’ve created a bunch of test cases, mostly derived from the problem domain itself - the source from Google’s Authenticator. You’ve learned how to combine Sprache parsers to create another, more complex parser. This has laid the foundation for parsing the more complex program structures. In the next article, we’ll finish our grammar by creating more parsers that can deal with the whole source. I will also show you how to deal with comments and how to “skip” code that you’re not interested in. Following that article, as a bonus, we’ll finish building our tool and outputting the graph that will show users the relationship between classes. All code produced thus far has been stored at Github. You’re welcome to fork it and use it in whichever way you want. To get the exact version of this code, use this tag." /> <meta property="og:description" content="😎 This the second article of a multiple part series on _how to parse code with Sprache. You can read the second part here. You probably know that sometimes (many times), a developer’s job is much more research or analysis than programming! In the past, there have been many instances where I was on a project where my goal was to migrate or rewrite old software, and during those engagements, I ended up creating tools to help me. Many of those tools were specialized code parsers that would automatically perform the analysis I required or even spit out newer code that I could reuse. In all those cases, I needed to parse some structured code, and there’s a simple way of doing this: by using Sprache, a parsing framework for dotnet. In this article, I’m going to teach you how to do that. Parsing Java code You can write all sorts of parsers with Sprache. As long as the language is formal, it’s easy to build the necessary code, and you do that leveraging all of C# syntax greatness. I will propose an example: a parser to a partial Java ☕ grammar. I’m choosing Java because it’s complex enough to let us see how Sprache can make your life easier; because Java is close to C#, so readers will quickly understand most of it; and because Java’s formal grammar is structured in such a way that one can extrapolate its grammar without much research. Of course, writing a full parser would take too long; we will have to constrain ourselves to a partial analyzer. The way we do that is to get the code we want to parse and then specify the grammar for just that (I call this approach best fit, an important agile principle). So I decided on a victim for this endeavor: Google Authenticator is the source of an Android app that generates OTP’s. The app can be found in the Play Store. 😎 I’ve used this source code to reproduce the OTP algorithm, so I’m familiar with it. To have a tangible goal, we will output a graph of class dependencies; This should help you get how to do more than just the parsing but also how to use the parsed code to get insight or produce other artifacts. Java BNF The starting point for our code is the formal grammar for Java. The eBNF - Extended Backus-Naur Form or notation - is a description of a formal grammar. For instance, a for block in Java can be: Example: for (int i = 0; i &lt; 100; i++) { System.out.println(i); } Grammar: FORBLOCK = &quot;for&quot; &quot;(&quot; INITIALIZER &quot;;&quot; CONDITION &quot;;&quot; INCREMENT) BLOCK INITIALIZER = ASSIGNMENT ASSIGNMENT = TYPE VARIABLE &quot;=&quot; LITERAL CONDITION = BOOLEAN_EXPRESSION INCREMENT = VARIABLE &quot;++&quot; | &quot;++&quot; VARIABLE BLOCK = STATEMENT | &quot;{&quot; STATEMENT_LIST &quot;}&quot; ❗ This grammar is incomplete and not necessarily correct; This is a practical guide on using Sprache, not on BNF and formal languages. So we begin by looking at our target code and creating a small grammar. To keep things simple, we will be writing parsers for every source in java/com/google/android/apps/authenticator/ and ignore non-java files. For instance, take a look at AuthenticatorActivity.java, the first file in scope. You will see that the first few lines are comments, and then we have a package instruction, followed by several import statements, and finally a class definition. Excluding the comments (we will touch on that later), the grammar would be: JAVA_FILE = PACKAGE, IMPORT_LIST, CLASS_DECLARATIONS; PACKAGE = &quot;package&quot;, PACKAGE_NAME, &quot;;&quot;; PACKAGE_NAME = WORD, { &quot;.&quot; WORD }; WORD = CHARACTER, { CHARACTER }; CHARACTER = LETTER | DIGIT; IMPORT_LIST = IMPORT, { IMPORT }; IMPORT = &quot;import&quot;, PACKAGE_NAME, &quot;;&quot;; CLASS_DECLARATION = &quot;public&quot;, &quot;class&quot;, WORD, &quot;{&quot; (* ommited *) &quot;}&quot;; Take a look at that language, compare it to the file, but check it against your knowledge of Java (or C#, just by realizing that those two languages are very similar). On one hand, you’ll probably see that the grammar above could be used to produce the source code; on the other, you’ll quickly realize that it doesn’t account for many constructs that are legal in Java: for instance, a source could have no imports whatsoever. That’s what I meant by best fit - we are looking for a way to parse only the code in scope. Setting up the project Once we have a small grammar, we can start to code. Create a new dotnet library project, add Sprache to it via Nuget, create an additional test project with xUnit, and download Google Authenticator’s source to a directory. We will define data structures to store each element of our grammar, and a test to check if the parse worked as expected. // BNF classes public class JavaFile { public Package Package { get; private set; } public List&lt;Import&gt; ImportList { get; private set; } public ClassDefinition ClassDefinition { get; private set; } } public class Package { public PackageName PackageName { get; set; } } public class PackageName { public PackageName() {} public PackageName(List&lt;string&gt; identifers) { Identifiers = identifers; } public List&lt;string&gt; Identifiers { get; } = new List&lt;string&gt;(); } public class Import { public PackageName PackageName { get; set; } } public class ClassDefinition { // OMMITED } A few important things to note on the structure above: I didn’t define ImportList or any list structures - I simply used the List generic from C#. I didn’t define a WORD construct yet - I will be storing those simply as strings for the time being since we’re not interested in it. Now, how does a parser looks like? We need something that can get the data from the source - text, after all - and produce the structures above: interface IParser&lt;T&gt; { T Parse(string code); } This is a basic parser for a certain definition T - it’s just a single method that reads a string and returns the desired structure. We’ll begin by declaring one of the basics parsers, the Package parser. We’ll revisit this structure in time. public class PackageNameParser : IParser&lt;Package&gt; { public Package Parse(string code) { throw new NotImplementedException(); } } This will be our starting point for the parser. With those classes defined, we can move into setting up the tests. The first few tests 😎 Always write tests first. I’ll be using xUnit, which is probably the best testing framework for C#. You can adapt the code below to anything you want, though. The first test case should be a warm-up, so we test what happens when code is null. public class PackageNameParserTests { [Fact] public void Parse_WhenCodeNull_Throws() { var sut = new PackageNameParser(); Assert.Throws&lt;ArgumentNullException&gt;(() =&gt; sut.Parse(null)); } } Run the test - it will fail, as usual, complying with a red-green-refactor approach. The next step is to turn it green: public class PackageNameParser : IParser&lt;PackageName&gt; { public PackageName Parse(string code) { if (code == null) throw new ArgumentNullException(nameof(code)); throw new NotImplementedException(); } } Run it again and the test will pass. The warm-up is done, our next step is to create a happy path. We want to test that we can correctly capture the package name: [Fact] public void Parse_WhenValidPackage_ReturnsName() { var packageExpresison = &quot;package tinyJavaParser;&quot;; var sut = new PackageNameParser(); var actual = sut.Parse(packageExpresison); Assert.Equal(&quot;tinyJavaParser&quot;, actual.Indentifiers[0]); } Run it and the test will fail. Let’s implement our first Sprache parser! Sprache parsers If you take a look at Sprache’s README, you’ll quickly grasp how to work with it. All begins with the static Parse object, which call be called to parse multiple types of texts. You build a complex parser by combining those basic parsers using LINQ. For instance, our package name is a string made up of chars, so we can use Sprache.Parse.Letter to parse it, but first we must account for the package keyword and whitespace that comes before: Parser&lt;PackageName&gt; parser = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() from packageName in Sprache.Parse.Letter.Many().Text() from ending in Sprache.Parse.Char(&#39;;&#39;) select new PackageName { Indentifiers = new List&lt;string&gt; { packageName } }; Let’s look at it line by line. First, we account for the package keyword, stating clearly that it must appear only once: from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() Then we know that there’ll be some spaces between the keyword and the identifier: from space1 in Sprache.Parse.WhiteSpace.Many() After that we extract the package name, which is a sequence of letters: from packageName in Sprache.Parse.Letter.Many().Text() And finally, we make sure the line ends with a ;: from ending in Sprache.Parse.Char(&#39;;&#39;) Once we did all that, we can produce the parsed structure, PackageName, using the data we gathered before: select new PackageName { Indentifiers = new() { packageName } }; Let’s use this knowledge and implement the method: public PackageName Parse(string code) { if (code == null) throw new ArgumentNullException(nameof(code)); Parser&lt;PackageName&gt; parser = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() from packageName in Sprache.Parse.Letter.Many().Text() from ending in Sprache.Parse.Char(&#39;;&#39;) select new PackageName(new() { packageName }) }; return parser.Parse(code); } Run the tests, you’ll get 🟢. Now, before we go on to refactor, I want to improve the test we just made, and make it more generic. The test is only accounting for a package name with a single word. This is not enough, and maybe you already guessed that composed identifiers will fail. We’ll add some other examples, and the best source for those is - you’ve guessed it! - the Authenticator source code. You may realize that we are also not accounting for possible identifiers that those that have letters or symbols such as underscore. But in keeping with our goal, we don’t need a parser that will read every legal Java code ever written, instead, just something that will parse the source we’re dealing with. This might not be the case on other projects where you need a parser - for instance, maybe you don’t have full access to the code before running the parser, and in that case, you’ll need to take a deep dive into the language definition. Likewise, our parser isn’t trying to validate the code that it’s consuming - whatever we find on those files we accept that it’s valid Java. Again, you may want to take a different approach, for instance if this parser is going to be fed code written just for it, since then you’ll have people making mistakes and you’ll need to tell them what those are. To find the examples of packages, I just used VSCode to open the directory where the code is, java/com/google/android/apps/authenticator/, and went to search: And now we turn the test from Fact to Theory using some of those names: I eyeballed the list of packages and picked those that I found to be representative of the domain of the name. We’ll, afterward, parse everything but it’s important that before that we already have some good testing in place. [Theory] [InlineData(&quot;tinyJavaParser&quot;)] [InlineData(&quot;com.google.android.apps.authenticator&quot;)] [InlineData(&quot;com.google.android.apps.authenticator.enroll2sv.wizard&quot;)] public void Parse_WhenValidPackage_ReturnsName(string packageName) { var packageExpresison = $&quot;package {packageName};&quot;; var sut = new PackageNameParser(); var actual = sut.Parse(packageExpresison); Assert.Equal(packageName, string.Join(&#39;.&#39;, actual.Identifiers)); } Take your time understanding the changes we’ve made to the test. Remember that the refactor step applies also to tests so, while we could keep the test as it was and just add a new theory, this is cleaner, i.e., easier to maintain. Now we run the tests and, of course, 🔴. Time to correct the code. First we try to fix it for com.google.android.apps.authenticator, by accounting for multiple identifiers: public PackageName Parse(string code) { if (code == null) throw new ArgumentNullException(nameof(code)); Parser&lt;string&gt; identifierParser = Sprache.Parse.Letter.Many().Text(); Parser&lt;PackageName&gt; parser = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() from packageHead in identifierParser from packageTail in (from delimiter in Sprache.Parse.Char(&#39;.&#39;).Once() from identifier in identifierParser select identifier).Many() from terminator in Sprache.Parse.Char(&#39;;&#39;) select new PackageName { Identifiers = (new[] { packageHead }).Concat(packageTail).ToList() }; return parser.Parse(code); } Let’s once again dissect the code. We begin by creating a “sub parser”, so to speak, that reads an identifier. It should be very straightforward since it’s the same code that we had before - get as many letters in sequence as possible, and convert it to “text”, i.e., a string. Parser&lt;string&gt; identifierParser = Sprache.Parse.Letter.Many().Text(); Now we increment the old parsing rules to account for repetitions of identifiers. We do this by getting at least the first identifier and then, optionally, many others. packageTail also uses a sub parser that I didn’t declare, so it’s inlined because it only makes sense inside this parser. from packageHead in identifierParser from packageTail in (from delimiter in Sprache.Parse.Char(&#39;.&#39;).Once() from identifier in identifierParser select identifier).Many() Finally, we need to create a list from the single identifier packageHead and the multiples in packageTail, so I cheated a bit: select new PackageName { Identifiers = (new[] { packageHead }).Concat(packageTail).ToList() }; I create an array with just the packageHead (new[] { packageHead }) and concatenate it with packageTail. After that, I just call ToList() to turn the resulting array into a list. This will test green 🟢 for &quot;com.google.android.apps.authenticator&quot;, but still fails for &quot;com.google.android.apps.authenticator.enroll2sv.wizard&quot;. Let’s take a look at the error: Message: Sprache.ParseException : Parsing failure: unexpected &#39;2&#39;; expected ; (Line 1, Column 53); recently consumed: tor.enroll Sprache is telling us there’s a 2 it didn’t expect in the stream, and that it just had consumed &quot;tor.enroll&quot;. If we look at the input string, it’s easy to see why it fails: Just read from here ↓ com.google.android.apps.authenticator.enroll2sv.wizard ↑ Failed here So, as expected, the number 2 isn’t allowed. This is just a matter of expanding the identifierParser definition to take that into account: Parser&lt;string&gt; identifierParser = Sprache.Parse.LetterOrDigit.Many().Text(); Run tests and appreciate your 🟢! Refactor! Now it’s time we refactor the code. We will look at how to make our code simpler to maintain and use. There two things that we should take notice of: In PackageNameParser.Parse we create two parser instances, identifierParser and parser. They are then used only once, right at the return. Multiple calls to this method result in recreating those instances, but they can be reused. This is made evident by Sprache docs as well. We defined an IParser&lt;T&gt; interface, and Sprache has a Parser&lt;out T&gt; delegate, which is very close to ours. Sprache can define parsers using its delegate, and we can combine those to produce new, more complex, parsers. With this knowledge, we should refactor our code to define once and use the parsers multiple times; We should also ditch our parsing interface and use Sprache’s delegate. Sprache way of doing things is defining those delegates as static members of a class, so we could create: public static class JavaGrammar { public static readonly Parser&lt;string&gt; Identifier = Sprache.Parse.LetterOrDigit.Many().Text(); public static readonly Parser&lt;PackageName&gt; PackageName = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() from packageHead in Identifier from packageTail in (from delimiter in Sprache.Parse.Char(&#39;.&#39;).Once() from identifier in Identifier select identifier).Many() from terminator in Sprache.Parse.Char(&#39;;&#39;) select new PackageName(new[] { packageHead }.Concat(packageTail).ToList()); } And changing the tests to reflect that: public class PackageNameParserTests { [Fact] public void Parse_WhenCodeNull_Throws() { Assert.Throws&lt;ArgumentNullException&gt;(() =&gt; JavaGrammar.PackageName.Parse(null)); } [Theory] [InlineData(&quot;tinyJavaParser&quot;)] [InlineData(&quot;com.google.android.apps.authenticator&quot;)] [InlineData(&quot;com.google.android.apps.authenticator.enroll2sv.wizard&quot;)] public void Parse_WhenValidPackage_ReturnsName(string packageName) { var packageExpresison = $&quot;package {packageName};&quot;; var actual = JavaGrammar.PackageName.Parse(packageExpresison); Assert.Equal(packageName, string.Join(&#39;.&#39;, actual.Identifiers)); } } ❗ If you’re getting an error that the delegate doesn’t have a Parse method, fret not! You just have to add a using Sprache; directive at the top of the file. You can remove the IParser interface that we created to help us define how the code should look like. Review Ufs, that was long! 😩We’ve seen a lot! Let’s review all that for a moment, shall we? You’ve learned that language syntaxes are governed by grammars and that those can be expressed with a notation known as BNF or EBNF. You’ve created a simplified EBNF for Java, taking into account only what was in scope. You know we call this best fit, and an agile principle that is similar to YAGNI - build only what you’re going to use. You’ve created a bunch of test cases, mostly derived from the problem domain itself - the source from Google’s Authenticator. You’ve learned how to combine Sprache parsers to create another, more complex parser. This has laid the foundation for parsing the more complex program structures. In the next article, we’ll finish our grammar by creating more parsers that can deal with the whole source. I will also show you how to deal with comments and how to “skip” code that you’re not interested in. Following that article, as a bonus, we’ll finish building our tool and outputting the graph that will show users the relationship between classes. All code produced thus far has been stored at Github. You’re welcome to fork it and use it in whichever way you want. To get the exact version of this code, use this tag." /> <link rel="canonical" href="https://blog.brunobrant.net/parsing-code-with-sprache/" /> <meta property="og:url" content="https://blog.brunobrant.net/parsing-code-with-sprache/" /> <meta property="og:site_name" content="TECHNOLOGY MATTERS" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2021-02-13T10:00:00+00:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Parsing code with Sprache - Part 1" /> <script type="application/ld+json"> {"datePublished":"2021-02-13T10:00:00+00:00","description":"😎 This the second article of a multiple part series on _how to parse code with Sprache. You can read the second part here. You probably know that sometimes (many times), a developer’s job is much more research or analysis than programming! In the past, there have been many instances where I was on a project where my goal was to migrate or rewrite old software, and during those engagements, I ended up creating tools to help me. Many of those tools were specialized code parsers that would automatically perform the analysis I required or even spit out newer code that I could reuse. In all those cases, I needed to parse some structured code, and there’s a simple way of doing this: by using Sprache, a parsing framework for dotnet. In this article, I’m going to teach you how to do that. Parsing Java code You can write all sorts of parsers with Sprache. As long as the language is formal, it’s easy to build the necessary code, and you do that leveraging all of C# syntax greatness. I will propose an example: a parser to a partial Java ☕ grammar. I’m choosing Java because it’s complex enough to let us see how Sprache can make your life easier; because Java is close to C#, so readers will quickly understand most of it; and because Java’s formal grammar is structured in such a way that one can extrapolate its grammar without much research. Of course, writing a full parser would take too long; we will have to constrain ourselves to a partial analyzer. The way we do that is to get the code we want to parse and then specify the grammar for just that (I call this approach best fit, an important agile principle). So I decided on a victim for this endeavor: Google Authenticator is the source of an Android app that generates OTP’s. The app can be found in the Play Store. 😎 I’ve used this source code to reproduce the OTP algorithm, so I’m familiar with it. To have a tangible goal, we will output a graph of class dependencies; This should help you get how to do more than just the parsing but also how to use the parsed code to get insight or produce other artifacts. Java BNF The starting point for our code is the formal grammar for Java. The eBNF - Extended Backus-Naur Form or notation - is a description of a formal grammar. For instance, a for block in Java can be: Example: for (int i = 0; i &lt; 100; i++) { System.out.println(i); } Grammar: FORBLOCK = &quot;for&quot; &quot;(&quot; INITIALIZER &quot;;&quot; CONDITION &quot;;&quot; INCREMENT) BLOCK INITIALIZER = ASSIGNMENT ASSIGNMENT = TYPE VARIABLE &quot;=&quot; LITERAL CONDITION = BOOLEAN_EXPRESSION INCREMENT = VARIABLE &quot;++&quot; | &quot;++&quot; VARIABLE BLOCK = STATEMENT | &quot;{&quot; STATEMENT_LIST &quot;}&quot; ❗ This grammar is incomplete and not necessarily correct; This is a practical guide on using Sprache, not on BNF and formal languages. So we begin by looking at our target code and creating a small grammar. To keep things simple, we will be writing parsers for every source in java/com/google/android/apps/authenticator/ and ignore non-java files. For instance, take a look at AuthenticatorActivity.java, the first file in scope. You will see that the first few lines are comments, and then we have a package instruction, followed by several import statements, and finally a class definition. Excluding the comments (we will touch on that later), the grammar would be: JAVA_FILE = PACKAGE, IMPORT_LIST, CLASS_DECLARATIONS; PACKAGE = &quot;package&quot;, PACKAGE_NAME, &quot;;&quot;; PACKAGE_NAME = WORD, { &quot;.&quot; WORD }; WORD = CHARACTER, { CHARACTER }; CHARACTER = LETTER | DIGIT; IMPORT_LIST = IMPORT, { IMPORT }; IMPORT = &quot;import&quot;, PACKAGE_NAME, &quot;;&quot;; CLASS_DECLARATION = &quot;public&quot;, &quot;class&quot;, WORD, &quot;{&quot; (* ommited *) &quot;}&quot;; Take a look at that language, compare it to the file, but check it against your knowledge of Java (or C#, just by realizing that those two languages are very similar). On one hand, you’ll probably see that the grammar above could be used to produce the source code; on the other, you’ll quickly realize that it doesn’t account for many constructs that are legal in Java: for instance, a source could have no imports whatsoever. That’s what I meant by best fit - we are looking for a way to parse only the code in scope. Setting up the project Once we have a small grammar, we can start to code. Create a new dotnet library project, add Sprache to it via Nuget, create an additional test project with xUnit, and download Google Authenticator’s source to a directory. We will define data structures to store each element of our grammar, and a test to check if the parse worked as expected. // BNF classes public class JavaFile { public Package Package { get; private set; } public List&lt;Import&gt; ImportList { get; private set; } public ClassDefinition ClassDefinition { get; private set; } } public class Package { public PackageName PackageName { get; set; } } public class PackageName { public PackageName() {} public PackageName(List&lt;string&gt; identifers) { Identifiers = identifers; } public List&lt;string&gt; Identifiers { get; } = new List&lt;string&gt;(); } public class Import { public PackageName PackageName { get; set; } } public class ClassDefinition { // OMMITED } A few important things to note on the structure above: I didn’t define ImportList or any list structures - I simply used the List generic from C#. I didn’t define a WORD construct yet - I will be storing those simply as strings for the time being since we’re not interested in it. Now, how does a parser looks like? We need something that can get the data from the source - text, after all - and produce the structures above: interface IParser&lt;T&gt; { T Parse(string code); } This is a basic parser for a certain definition T - it’s just a single method that reads a string and returns the desired structure. We’ll begin by declaring one of the basics parsers, the Package parser. We’ll revisit this structure in time. public class PackageNameParser : IParser&lt;Package&gt; { public Package Parse(string code) { throw new NotImplementedException(); } } This will be our starting point for the parser. With those classes defined, we can move into setting up the tests. The first few tests 😎 Always write tests first. I’ll be using xUnit, which is probably the best testing framework for C#. You can adapt the code below to anything you want, though. The first test case should be a warm-up, so we test what happens when code is null. public class PackageNameParserTests { [Fact] public void Parse_WhenCodeNull_Throws() { var sut = new PackageNameParser(); Assert.Throws&lt;ArgumentNullException&gt;(() =&gt; sut.Parse(null)); } } Run the test - it will fail, as usual, complying with a red-green-refactor approach. The next step is to turn it green: public class PackageNameParser : IParser&lt;PackageName&gt; { public PackageName Parse(string code) { if (code == null) throw new ArgumentNullException(nameof(code)); throw new NotImplementedException(); } } Run it again and the test will pass. The warm-up is done, our next step is to create a happy path. We want to test that we can correctly capture the package name: [Fact] public void Parse_WhenValidPackage_ReturnsName() { var packageExpresison = &quot;package tinyJavaParser;&quot;; var sut = new PackageNameParser(); var actual = sut.Parse(packageExpresison); Assert.Equal(&quot;tinyJavaParser&quot;, actual.Indentifiers[0]); } Run it and the test will fail. Let’s implement our first Sprache parser! Sprache parsers If you take a look at Sprache’s README, you’ll quickly grasp how to work with it. All begins with the static Parse object, which call be called to parse multiple types of texts. You build a complex parser by combining those basic parsers using LINQ. For instance, our package name is a string made up of chars, so we can use Sprache.Parse.Letter to parse it, but first we must account for the package keyword and whitespace that comes before: Parser&lt;PackageName&gt; parser = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() from packageName in Sprache.Parse.Letter.Many().Text() from ending in Sprache.Parse.Char(&#39;;&#39;) select new PackageName { Indentifiers = new List&lt;string&gt; { packageName } }; Let’s look at it line by line. First, we account for the package keyword, stating clearly that it must appear only once: from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() Then we know that there’ll be some spaces between the keyword and the identifier: from space1 in Sprache.Parse.WhiteSpace.Many() After that we extract the package name, which is a sequence of letters: from packageName in Sprache.Parse.Letter.Many().Text() And finally, we make sure the line ends with a ;: from ending in Sprache.Parse.Char(&#39;;&#39;) Once we did all that, we can produce the parsed structure, PackageName, using the data we gathered before: select new PackageName { Indentifiers = new() { packageName } }; Let’s use this knowledge and implement the method: public PackageName Parse(string code) { if (code == null) throw new ArgumentNullException(nameof(code)); Parser&lt;PackageName&gt; parser = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() from packageName in Sprache.Parse.Letter.Many().Text() from ending in Sprache.Parse.Char(&#39;;&#39;) select new PackageName(new() { packageName }) }; return parser.Parse(code); } Run the tests, you’ll get 🟢. Now, before we go on to refactor, I want to improve the test we just made, and make it more generic. The test is only accounting for a package name with a single word. This is not enough, and maybe you already guessed that composed identifiers will fail. We’ll add some other examples, and the best source for those is - you’ve guessed it! - the Authenticator source code. You may realize that we are also not accounting for possible identifiers that those that have letters or symbols such as underscore. But in keeping with our goal, we don’t need a parser that will read every legal Java code ever written, instead, just something that will parse the source we’re dealing with. This might not be the case on other projects where you need a parser - for instance, maybe you don’t have full access to the code before running the parser, and in that case, you’ll need to take a deep dive into the language definition. Likewise, our parser isn’t trying to validate the code that it’s consuming - whatever we find on those files we accept that it’s valid Java. Again, you may want to take a different approach, for instance if this parser is going to be fed code written just for it, since then you’ll have people making mistakes and you’ll need to tell them what those are. To find the examples of packages, I just used VSCode to open the directory where the code is, java/com/google/android/apps/authenticator/, and went to search: And now we turn the test from Fact to Theory using some of those names: I eyeballed the list of packages and picked those that I found to be representative of the domain of the name. We’ll, afterward, parse everything but it’s important that before that we already have some good testing in place. [Theory] [InlineData(&quot;tinyJavaParser&quot;)] [InlineData(&quot;com.google.android.apps.authenticator&quot;)] [InlineData(&quot;com.google.android.apps.authenticator.enroll2sv.wizard&quot;)] public void Parse_WhenValidPackage_ReturnsName(string packageName) { var packageExpresison = $&quot;package {packageName};&quot;; var sut = new PackageNameParser(); var actual = sut.Parse(packageExpresison); Assert.Equal(packageName, string.Join(&#39;.&#39;, actual.Identifiers)); } Take your time understanding the changes we’ve made to the test. Remember that the refactor step applies also to tests so, while we could keep the test as it was and just add a new theory, this is cleaner, i.e., easier to maintain. Now we run the tests and, of course, 🔴. Time to correct the code. First we try to fix it for com.google.android.apps.authenticator, by accounting for multiple identifiers: public PackageName Parse(string code) { if (code == null) throw new ArgumentNullException(nameof(code)); Parser&lt;string&gt; identifierParser = Sprache.Parse.Letter.Many().Text(); Parser&lt;PackageName&gt; parser = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() from packageHead in identifierParser from packageTail in (from delimiter in Sprache.Parse.Char(&#39;.&#39;).Once() from identifier in identifierParser select identifier).Many() from terminator in Sprache.Parse.Char(&#39;;&#39;) select new PackageName { Identifiers = (new[] { packageHead }).Concat(packageTail).ToList() }; return parser.Parse(code); } Let’s once again dissect the code. We begin by creating a “sub parser”, so to speak, that reads an identifier. It should be very straightforward since it’s the same code that we had before - get as many letters in sequence as possible, and convert it to “text”, i.e., a string. Parser&lt;string&gt; identifierParser = Sprache.Parse.Letter.Many().Text(); Now we increment the old parsing rules to account for repetitions of identifiers. We do this by getting at least the first identifier and then, optionally, many others. packageTail also uses a sub parser that I didn’t declare, so it’s inlined because it only makes sense inside this parser. from packageHead in identifierParser from packageTail in (from delimiter in Sprache.Parse.Char(&#39;.&#39;).Once() from identifier in identifierParser select identifier).Many() Finally, we need to create a list from the single identifier packageHead and the multiples in packageTail, so I cheated a bit: select new PackageName { Identifiers = (new[] { packageHead }).Concat(packageTail).ToList() }; I create an array with just the packageHead (new[] { packageHead }) and concatenate it with packageTail. After that, I just call ToList() to turn the resulting array into a list. This will test green 🟢 for &quot;com.google.android.apps.authenticator&quot;, but still fails for &quot;com.google.android.apps.authenticator.enroll2sv.wizard&quot;. Let’s take a look at the error: Message: Sprache.ParseException : Parsing failure: unexpected &#39;2&#39;; expected ; (Line 1, Column 53); recently consumed: tor.enroll Sprache is telling us there’s a 2 it didn’t expect in the stream, and that it just had consumed &quot;tor.enroll&quot;. If we look at the input string, it’s easy to see why it fails: Just read from here ↓ com.google.android.apps.authenticator.enroll2sv.wizard ↑ Failed here So, as expected, the number 2 isn’t allowed. This is just a matter of expanding the identifierParser definition to take that into account: Parser&lt;string&gt; identifierParser = Sprache.Parse.LetterOrDigit.Many().Text(); Run tests and appreciate your 🟢! Refactor! Now it’s time we refactor the code. We will look at how to make our code simpler to maintain and use. There two things that we should take notice of: In PackageNameParser.Parse we create two parser instances, identifierParser and parser. They are then used only once, right at the return. Multiple calls to this method result in recreating those instances, but they can be reused. This is made evident by Sprache docs as well. We defined an IParser&lt;T&gt; interface, and Sprache has a Parser&lt;out T&gt; delegate, which is very close to ours. Sprache can define parsers using its delegate, and we can combine those to produce new, more complex, parsers. With this knowledge, we should refactor our code to define once and use the parsers multiple times; We should also ditch our parsing interface and use Sprache’s delegate. Sprache way of doing things is defining those delegates as static members of a class, so we could create: public static class JavaGrammar { public static readonly Parser&lt;string&gt; Identifier = Sprache.Parse.LetterOrDigit.Many().Text(); public static readonly Parser&lt;PackageName&gt; PackageName = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() from packageHead in Identifier from packageTail in (from delimiter in Sprache.Parse.Char(&#39;.&#39;).Once() from identifier in Identifier select identifier).Many() from terminator in Sprache.Parse.Char(&#39;;&#39;) select new PackageName(new[] { packageHead }.Concat(packageTail).ToList()); } And changing the tests to reflect that: public class PackageNameParserTests { [Fact] public void Parse_WhenCodeNull_Throws() { Assert.Throws&lt;ArgumentNullException&gt;(() =&gt; JavaGrammar.PackageName.Parse(null)); } [Theory] [InlineData(&quot;tinyJavaParser&quot;)] [InlineData(&quot;com.google.android.apps.authenticator&quot;)] [InlineData(&quot;com.google.android.apps.authenticator.enroll2sv.wizard&quot;)] public void Parse_WhenValidPackage_ReturnsName(string packageName) { var packageExpresison = $&quot;package {packageName};&quot;; var actual = JavaGrammar.PackageName.Parse(packageExpresison); Assert.Equal(packageName, string.Join(&#39;.&#39;, actual.Identifiers)); } } ❗ If you’re getting an error that the delegate doesn’t have a Parse method, fret not! You just have to add a using Sprache; directive at the top of the file. You can remove the IParser interface that we created to help us define how the code should look like. Review Ufs, that was long! 😩We’ve seen a lot! Let’s review all that for a moment, shall we? You’ve learned that language syntaxes are governed by grammars and that those can be expressed with a notation known as BNF or EBNF. You’ve created a simplified EBNF for Java, taking into account only what was in scope. You know we call this best fit, and an agile principle that is similar to YAGNI - build only what you’re going to use. You’ve created a bunch of test cases, mostly derived from the problem domain itself - the source from Google’s Authenticator. You’ve learned how to combine Sprache parsers to create another, more complex parser. This has laid the foundation for parsing the more complex program structures. In the next article, we’ll finish our grammar by creating more parsers that can deal with the whole source. I will also show you how to deal with comments and how to “skip” code that you’re not interested in. Following that article, as a bonus, we’ll finish building our tool and outputting the graph that will show users the relationship between classes. All code produced thus far has been stored at Github. You’re welcome to fork it and use it in whichever way you want. To get the exact version of this code, use this tag.","url":"https://blog.brunobrant.net/parsing-code-with-sprache/","@type":"BlogPosting","dateModified":"2021-02-13T10:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.brunobrant.net/parsing-code-with-sprache/"},"author":{"@type":"Person","name":"Bruno Brant"},"headline":"Parsing code with Sprache - Part 1","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <script> /* Toggle between adding and removing the "responsive" class to topnav when the user clicks on the icon */ function openNavigation() { const navigationElems = document.getElementsByClassName("navigation"); if (navigationElems.length != 1) { console.warn("Couldn't find navbar"); return; } const x = navigationElems[0]; if (x.className === "navigation") { x.className += " responsive"; } else { x.className = "navigation"; } } </script> <body> <div class="container content"> <header class="masthead"> <h3 class="masthead-title"> <a href="/" title="Home" class="masthead-title-main">TECHNOLOGY MATTERS</a><br> <small>a bunch of unsorted thoughts about tech, software, etc.</small> </h3> <!-- Change navigation links here --> <div class="navigation"> <ul id="navigation-list"> <li> <a href="/">HOME</a> </li> <li> <a href="/archive/">POSTS</a> </li> <li> <a href="/tags/">TAGS</a> </li> <li> <a href="/categories/">CATEGORIES</a> </li> <li> <a href="/about/">ABOUT</a> </li> <li id="subscribe"> <a href="/feed.xml"> <p>SUBSCRIBE</p> <svg class="svg-icon grey" style="fill: #f66a0a;"> <use xlink:href="/assets/minima-social-icons.svg#rss"></use> </svg> </a> </li> </ul> <div style="float:right"> <a href="javascript:void(0);" class="navigation-icon" onclick="openNavigation()">☰</a> </div> </div> <!-- Language selector --> <div class="language-selector"> <span class="language-selector-label">read this site in:</span> <a href="/parsing-code-with-sprache/"><span>🇺🇸</span></a> | <a href="/pt/parsing-code-with-sprache/"><span>🇧🇷</span></a> </div> </header> <main> <!-- Change navigation links here --> <article class="post"> <h1 class="post-title">Parsing code with Sprache - Part 1</h1> <time datetime="2021-02-13T10:00:00+00:00" class="post-date">February 13th, 2021 in <a href="/categories/#Development">Development</a> </time> <blockquote> <p>😎 This the second article of a multiple part series on _how to parse code with Sprache. You can read the second part <a href="2021-03-13-parsing-code-with-sprache-part-2">here</a>.</p> </blockquote> <p>You probably know that sometimes (<em>many</em> times), a developer’s job is much more research or analysis than programming! In the past, there have been many instances where I was on a project where my goal was to migrate or rewrite old software, and during those engagements, I ended up creating tools to help me. Many of those tools were specialized code parsers that would automatically perform the analysis I required or even spit out newer code that I could reuse.</p> <p>In all those cases, I needed to parse some structured code, and there’s a simple way of doing this: by using <a href="https://github.com/sprache/Sprache" target="_blank" rel="noopener noreferrer">Sprache</a>, a parsing framework for dotnet. In this article, I’m going to teach you how to do that.</p> <h1 id="parsing-java-code">Parsing Java code</h1> <p>You can write all sorts of parsers with Sprache. As long as the language is formal, it’s easy to build the necessary code, and you do that leveraging all of C# syntax greatness. I will propose an example: a parser to a <strong>partial</strong> Java ☕ grammar.</p> <p>I’m choosing Java because it’s complex enough to let us see how Sprache can make your life easier; because Java is close to C#, so readers will quickly understand most of it; and because Java’s formal grammar is structured in such a way that one can extrapolate its grammar without much research.</p> <p>Of course, writing a full parser would take too long; we will have to constrain ourselves to a partial analyzer. The way we do that is to get the code we want to parse and then specify the grammar for just that (I call this approach <em>best fit</em>, an important agile principle). So I decided on a victim for this endeavor: <a href="https://github.com/google/google-authenticator-android/tree/master/java/com/google/android/apps/authenticator" target="_blank" rel="noopener noreferrer">Google Authenticator</a> is the source of an Android app that generates OTP’s. The app can be found in the <a href="https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&amp;hl=en_US&amp;gl=US" target="_blank" rel="noopener noreferrer">Play Store</a>.</p> <blockquote> <p>😎 I’ve used this source code to reproduce the OTP algorithm, so I’m familiar with it.</p> </blockquote> <p>To have a tangible goal, we will output a graph of class dependencies; This should help you get how to do more than just the parsing but also how to use the parsed code to get insight or produce other artifacts.</p> <h1 id="java-bnf">Java BNF</h1> <p>The starting point for our code is the formal grammar for Java. The <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form" target="_blank" rel="noopener noreferrer">eBNF</a> - Extended Backus-Naur Form or notation - is a description of a formal grammar. For instance, a <code class="language-plaintext highlighter-rouge">for</code> block in Java can be:</p> <p>Example:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span> <span class="o">}</span>
</code></pre></div></div> <p>Grammar:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FORBLOCK = "for" "(" INITIALIZER ";" CONDITION ";" INCREMENT) BLOCK

INITIALIZER = ASSIGNMENT

ASSIGNMENT = TYPE VARIABLE "=" LITERAL 

CONDITION = BOOLEAN_EXPRESSION

INCREMENT = VARIABLE "++" | "++" VARIABLE

BLOCK = STATEMENT | "{" STATEMENT_LIST "}"
</code></pre></div></div> <blockquote> <p>❗ This grammar is incomplete and not necessarily correct; This is a practical guide on using Sprache, not on BNF and formal languages.</p> </blockquote> <p>So we begin by looking at our target code and creating a small grammar. To keep things simple, we will be writing parsers for every source in <code class="language-plaintext highlighter-rouge">java/com/google/android/apps/authenticator/</code> and ignore non-java files.</p> <p>For instance, take a look at <a href="https://github.com/google/google-authenticator-android/blob/master/java/com/google/android/apps/authenticator/AuthenticatorActivity.java" target="_blank" rel="noopener noreferrer">AuthenticatorActivity.java</a>, the first file in scope. You will see that the first few lines are comments, and then we have a <code class="language-plaintext highlighter-rouge">package</code> instruction, followed by several <code class="language-plaintext highlighter-rouge">import</code> statements, and finally a <code class="language-plaintext highlighter-rouge">class</code> definition. Excluding the comments (we will touch on that later), the grammar would be:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>JAVA_FILE = PACKAGE, IMPORT_LIST, CLASS_DECLARATIONS; 

PACKAGE = "package", PACKAGE_NAME, ";";

PACKAGE_NAME = WORD, { "." WORD };

WORD = CHARACTER, { CHARACTER };

CHARACTER = LETTER | DIGIT;

IMPORT_LIST = IMPORT, { IMPORT };

IMPORT = "import", PACKAGE_NAME, ";";

CLASS_DECLARATION = "public", "class", WORD, "{" (* ommited *) "}";
</code></pre></div></div> <p>Take a look at that language, compare it to the file, but check it against your knowledge of Java (or C#, just by realizing that those two languages are very similar). On one hand, you’ll probably see that the grammar above could be used to produce the source code; on the other, you’ll quickly realize that it doesn’t account for many constructs that are legal in Java: for instance, a source could have no <code class="language-plaintext highlighter-rouge">import</code>s whatsoever. That’s what I meant by <em>best fit</em> - we are looking for a way to parse <strong>only</strong> the code in scope.</p> <h1 id="setting-up-the-project">Setting up the project</h1> <p>Once we have a small grammar, we can start to code. Create a new dotnet library project, add Sprache to it via Nuget, create an additional test project with xUnit, and download Google Authenticator’s source to a directory.</p> <p>We will define data structures to store each element of our grammar, and a test to check if the parse worked as expected.</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// BNF classes</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">JavaFile</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Package</span> <span class="n">Package</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Import</span><span class="p">&gt;</span> <span class="n">ImportList</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="n">ClassDefinition</span> <span class="n">ClassDefinition</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Package</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">PackageName</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">PackageName</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">PackageName</span><span class="p">()</span> <span class="p">{}</span>

	<span class="k">public</span> <span class="nf">PackageName</span><span class="p">(</span><span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">identifers</span><span class="p">)</span> 
	<span class="p">{</span> 
		<span class="n">Identifiers</span> <span class="p">=</span> <span class="n">identifers</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">Identifiers</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Import</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">PackageName</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">ClassDefinition</span>
<span class="p">{</span>
    <span class="c1">// OMMITED</span>
<span class="p">}</span>
</code></pre></div></div> <p>A few important things to note on the structure above:</p> <ul> <li>I didn’t define ImportList or any list structures - I simply used the <code class="language-plaintext highlighter-rouge">List</code> generic from C#.</li> <li>I didn’t define a WORD construct yet - I will be storing those simply as strings for the time being since we’re not interested in it.</li> </ul> <p>Now, how does a parser looks like? We need something that can get the data from the source - text, after all - and produce the structures above:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">interface</span> <span class="nc">IParser</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="nf">Parse</span><span class="p">(</span><span class="kt">string</span> <span class="n">code</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>This is a basic parser for a certain definition <code class="language-plaintext highlighter-rouge">T</code> - it’s just a single method that reads a string and returns the desired structure. We’ll begin by declaring one of the basics parsers, the <code class="language-plaintext highlighter-rouge">Package</code> parser. <em>We’ll revisit this structure in time.</em></p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageNameParser</span> <span class="p">:</span> <span class="n">IParser</span><span class="p">&lt;</span><span class="n">Package</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Package</span> <span class="nf">Parse</span><span class="p">(</span><span class="kt">string</span> <span class="n">code</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotImplementedException</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This will be our starting point for the parser.</p> <p>With those classes defined, we can move into setting up the tests.</p> <h1 id="the-first-few-tests">The first few tests</h1> <blockquote> <p>😎 Always write tests first.</p> </blockquote> <p>I’ll be using xUnit, which is probably the best testing framework for C#. You can adapt the code below to anything you want, though.</p> <p>The first test case should be a warm-up, so we test what happens when code is <code class="language-plaintext highlighter-rouge">null</code>.</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageNameParserTests</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenCodeNull_Throws</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">sut</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">PackageNameParser</span><span class="p">();</span>

        <span class="n">Assert</span><span class="p">.</span><span class="n">Throws</span><span class="p">&lt;</span><span class="n">ArgumentNullException</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="n">sut</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="k">null</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Run the test - it will fail, as usual, complying with a <em>red-green-refactor</em> approach. The next step is to turn it green:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageNameParser</span> <span class="p">:</span> <span class="n">IParser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">PackageName</span> <span class="nf">Parse</span><span class="p">(</span><span class="kt">string</span> <span class="n">code</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentNullException</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">code</span><span class="p">));</span>

        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotImplementedException</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Run it again and the test will pass. The warm-up is done, our next step is to create a happy path. We want to test that we can correctly capture the package name:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackage_ReturnsName</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">packageExpresison</span> <span class="p">=</span> <span class="s">"package tinyJavaParser;"</span><span class="p">;</span>

    <span class="kt">var</span> <span class="n">sut</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">PackageNameParser</span><span class="p">();</span>
    
    <span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">sut</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">packageExpresison</span><span class="p">);</span>

    <span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">"tinyJavaParser"</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Indentifiers</span><span class="p">[</span><span class="m">0</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Run it and the test will fail. Let’s implement our first Sprache parser!</p> <h2 id="sprache-parsers">Sprache parsers</h2> <p>If you take a look at Sprache’s README, you’ll quickly grasp how to work with it. All begins with the static <code class="language-plaintext highlighter-rouge">Parse</code> object, which call be called to parse multiple types of texts. You build a complex parser by combining those basic parsers using LINQ.</p> <p>For instance, our package name is a string made up of chars, so we can use <code class="language-plaintext highlighter-rouge">Sprache.Parse.Letter</code> to parse it, but first we must account for the <code class="language-plaintext highlighter-rouge">package</code> keyword and whitespace that comes before:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">parser</span> <span class="p">=</span>
    <span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
    <span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
    <span class="k">from</span> <span class="n">packageName</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">Letter</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">()</span>
    <span class="k">from</span> <span class="n">ending</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
    <span class="k">select</span> <span class="k">new</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="n">Indentifiers</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="p">{</span> <span class="n">packageName</span> <span class="p">}</span> <span class="p">};</span>
</code></pre></div></div> <p>Let’s look at it line by line. First, we account for the package keyword, stating clearly that it must appear only <strong>once</strong>:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
</code></pre></div></div> <p>Then we know that there’ll be some spaces between the keyword and the identifier:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">from</span> <span class="n">space1</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
</code></pre></div></div> <p>After that we extract the package name, which is a sequence of letters:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">from</span> <span class="n">packageName</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">Letter</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">()</span>
</code></pre></div></div> <p>And finally, we make sure the line ends with a <code class="language-plaintext highlighter-rouge">;</code>:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">from</span> <span class="n">ending</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
</code></pre></div></div> <p>Once we did all that, we can produce the parsed structure, <code class="language-plaintext highlighter-rouge">PackageName</code>, using the data we gathered before:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">select</span> <span class="k">new</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="n">Indentifiers</span> <span class="p">=</span> <span class="k">new</span><span class="p">()</span> <span class="p">{</span> <span class="n">packageName</span> <span class="p">}</span> <span class="p">};</span>
</code></pre></div></div> <p>Let’s use this knowledge and implement the method:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">PackageName</span> <span class="nf">Parse</span><span class="p">(</span><span class="kt">string</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentNullException</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">code</span><span class="p">));</span>

    <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">parser</span> <span class="p">=</span>
        <span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">packageName</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">Letter</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">ending</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
        <span class="k">select</span> <span class="k">new</span> <span class="nf">PackageName</span><span class="p">(</span><span class="k">new</span><span class="p">()</span> <span class="p">{</span> <span class="n">packageName</span> <span class="p">})</span> <span class="p">};</span>

    <span class="k">return</span> <span class="n">parser</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Run the tests, you’ll get 🟢. Now, before we go on to <em>refactor</em>, I want to improve the test we just made, and make it more generic.</p> <p>The test is only accounting for a package name with a single word. This is not enough, and maybe you already guessed that composed identifiers will fail. We’ll add some other examples, and the best source for those is - you’ve guessed it! - the Authenticator source code.</p> <blockquote> <p>You may realize that we are also not accounting for possible identifiers that those that have letters or symbols such as underscore. But in keeping with our goal, we don’t need a parser that will read every legal Java code ever written, instead, just something that will parse the source we’re dealing with. This might not be the case on other projects where you need a parser - for instance, maybe you don’t have full access to the code before running the parser, and in that case, you’ll need to take a deep dive into the language definition. Likewise, our parser isn’t trying to validate the code that it’s consuming - whatever we find on those files we accept that it’s valid Java. Again, you may want to take a different approach, for instance if this parser is going to be fed code written just for it, since then you’ll have people making mistakes and you’ll need to tell them what those are.</p> </blockquote> <p>To find the examples of packages, I just used VSCode to open the directory where the code is, <code class="language-plaintext highlighter-rouge">java/com/google/android/apps/authenticator/</code>, and went to search:</p> <p><img src="../../../assets/vscode-search-example.png" alt="Search Box in VSCode"></p> <p>And now we turn the test from <code class="language-plaintext highlighter-rouge">Fact</code> to <code class="language-plaintext highlighter-rouge">Theory</code> using some of those names:</p> <blockquote> <p>I eyeballed the list of packages and picked those that I found to be representative of the domain of the name. We’ll, afterward, parse everything but it’s important that before that we already have some good testing in place.</p> </blockquote> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"tinyJavaParser"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"com.google.android.apps.authenticator"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"com.google.android.apps.authenticator.enroll2sv.wizard"</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackage_ReturnsName</span><span class="p">(</span><span class="kt">string</span> <span class="n">packageName</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">packageExpresison</span> <span class="p">=</span> <span class="s">$"package </span><span class="p">{</span><span class="n">packageName</span><span class="p">}</span><span class="s">;"</span><span class="p">;</span>

    <span class="kt">var</span> <span class="n">sut</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">PackageNameParser</span><span class="p">();</span>

    <span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">sut</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">packageExpresison</span><span class="p">);</span>

    <span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">packageName</span><span class="p">,</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Identifiers</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div> <p>Take your time understanding the changes we’ve made to the test. Remember that the <em>refactor</em> step applies also to tests so, while we <em>could</em> keep the test as it was and just add a new theory, this is cleaner, i.e., easier to maintain.</p> <p>Now we run the tests and, of course, 🔴. Time to correct the code.</p> <p>First we try to fix it for <em>com.google.android.apps.authenticator</em>, by accounting for multiple identifiers:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">PackageName</span> <span class="nf">Parse</span><span class="p">(</span><span class="kt">string</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentNullException</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">code</span><span class="p">));</span>

    <span class="n">Parser</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">identifierParser</span> <span class="p">=</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">Letter</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">();</span>

    <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">parser</span> <span class="p">=</span>
        <span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">packageHead</span> <span class="k">in</span> <span class="n">identifierParser</span>
        <span class="k">from</span> <span class="n">packageTail</span> <span class="k">in</span> <span class="p">(</span><span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'.'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
                                <span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">identifierParser</span>
                                <span class="k">select</span> <span class="n">identifier</span><span class="p">).</span><span class="nf">Many</span><span class="p">()</span>
        <span class="k">from</span> <span class="n">terminator</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
        <span class="k">select</span> <span class="k">new</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="n">Identifiers</span> <span class="p">=</span> <span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="n">packageHead</span> <span class="p">}).</span><span class="nf">Concat</span><span class="p">(</span><span class="n">packageTail</span><span class="p">).</span><span class="nf">ToList</span><span class="p">()</span> <span class="p">};</span>

    <span class="k">return</span> <span class="n">parser</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Let’s once again dissect the code.</p> <p>We begin by creating a “sub parser”, so to speak, that reads an identifier. It should be very straightforward since it’s the same code that we had before - get as many letters in sequence as possible, and convert it to “text”, i.e., a <code class="language-plaintext highlighter-rouge">string</code>.</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">identifierParser</span> <span class="p">=</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">Letter</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">();</span>
</code></pre></div></div> <p>Now we increment the old parsing rules to account for repetitions of identifiers. We do this by getting at least the first identifier and then, optionally, many others. <code class="language-plaintext highlighter-rouge">packageTail</code> also uses a sub parser that I didn’t declare, so it’s inlined because it only makes sense inside this parser.</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span> <span class="n">packageHead</span> <span class="k">in</span> <span class="n">identifierParser</span>
<span class="k">from</span> <span class="n">packageTail</span> <span class="k">in</span> <span class="p">(</span><span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'.'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
                        <span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">identifierParser</span>
                        <span class="k">select</span> <span class="n">identifier</span><span class="p">).</span><span class="nf">Many</span><span class="p">()</span>
</code></pre></div></div> <p>Finally, we need to create a list from the single identifier <code class="language-plaintext highlighter-rouge">packageHead</code> and the multiples in <code class="language-plaintext highlighter-rouge">packageTail</code>, so I cheated a bit:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="k">new</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="n">Identifiers</span> <span class="p">=</span> <span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="n">packageHead</span> <span class="p">}).</span><span class="nf">Concat</span><span class="p">(</span><span class="n">packageTail</span><span class="p">).</span><span class="nf">ToList</span><span class="p">()</span> <span class="p">};</span>
</code></pre></div></div> <p>I create an array with just the packageHead (<code class="language-plaintext highlighter-rouge">new[] { packageHead }</code>) and concatenate it with <code class="language-plaintext highlighter-rouge">packageTail</code>. After that, I just call <code class="language-plaintext highlighter-rouge">ToList()</code> to turn the resulting array into a list.</p> <p>This will test green 🟢 for <code class="language-plaintext highlighter-rouge">"com.google.android.apps.authenticator"</code>, but still fails for <code class="language-plaintext highlighter-rouge">"com.google.android.apps.authenticator.enroll2sv.wizard"</code>. Let’s take a look at the error:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Message: 
    Sprache.ParseException : Parsing failure: unexpected '2'; expected ; (Line 1, Column 53); recently consumed: tor.enroll
</code></pre></div></div> <p>Sprache is telling us there’s a <code class="language-plaintext highlighter-rouge">2</code> it didn’t expect in the stream, and that it just had consumed <code class="language-plaintext highlighter-rouge">"tor.enroll"</code>. If we look at the input string, it’s easy to see why it fails:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                         Just read from here
                                  ↓
com.google.android.apps.authenticator.enroll2sv.wizard
                                            ↑
                                      Failed here
</code></pre></div></div> <p>So, as expected, the number 2 isn’t allowed. This is just a matter of expanding the <code class="language-plaintext highlighter-rouge">identifierParser</code> definition to take that into account:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">identifierParser</span> <span class="p">=</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">LetterOrDigit</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">();</span>
</code></pre></div></div> <p>Run tests and appreciate your 🟢!</p> <h2 id="refactor">Refactor!</h2> <p>Now it’s time we refactor the code. We will look at how to make our code simpler to maintain and use.</p> <p>There two things that we should take notice of:</p> <ul> <li> <p>In <code class="language-plaintext highlighter-rouge">PackageNameParser.Parse</code> we create two parser instances, <code class="language-plaintext highlighter-rouge">identifierParser</code> and <code class="language-plaintext highlighter-rouge">parser</code>. They are then used only once, right at the return. Multiple calls to this method result in recreating those instances, but they can be reused. This is made evident by Sprache docs as well.</p> </li> <li> <p>We defined an <code class="language-plaintext highlighter-rouge">IParser&lt;T&gt;</code> interface, and Sprache has a <code class="language-plaintext highlighter-rouge">Parser&lt;out T&gt;</code> delegate, which is very close to ours. Sprache can define parsers using its delegate, and we can combine those to produce new, more complex, parsers.</p> </li> </ul> <p>With this knowledge, we should refactor our code to define once and use the parsers multiple times; We should also ditch our parsing interface and use Sprache’s delegate. Sprache way of doing things is defining those delegates as static members of a class, so we could create:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">JavaGrammar</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">Identifier</span> <span class="p">=</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">LetterOrDigit</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Text</span><span class="p">();</span>

	<span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">PackageName</span> <span class="p">=</span>
		<span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
		<span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
		<span class="k">from</span> <span class="n">packageHead</span> <span class="k">in</span> <span class="n">Identifier</span>
		<span class="k">from</span> <span class="n">packageTail</span> <span class="k">in</span> <span class="p">(</span><span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'.'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
								<span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">Identifier</span>
								<span class="k">select</span> <span class="n">identifier</span><span class="p">).</span><span class="nf">Many</span><span class="p">()</span>
		<span class="k">from</span> <span class="n">terminator</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
		<span class="k">select</span> <span class="k">new</span> <span class="nf">PackageName</span><span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="n">packageHead</span> <span class="p">}.</span><span class="nf">Concat</span><span class="p">(</span><span class="n">packageTail</span><span class="p">).</span><span class="nf">ToList</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div> <p>And changing the tests to reflect that:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageNameParserTests</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenCodeNull_Throws</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Assert</span><span class="p">.</span><span class="n">Throws</span><span class="p">&lt;</span><span class="n">ArgumentNullException</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">PackageName</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="k">null</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
    <span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"tinyJavaParser"</span><span class="p">)]</span>
    <span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"com.google.android.apps.authenticator"</span><span class="p">)]</span>
    <span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"com.google.android.apps.authenticator.enroll2sv.wizard"</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackage_ReturnsName</span><span class="p">(</span><span class="kt">string</span> <span class="n">packageName</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">packageExpresison</span> <span class="p">=</span> <span class="s">$"package </span><span class="p">{</span><span class="n">packageName</span><span class="p">}</span><span class="s">;"</span><span class="p">;</span>

        <span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">PackageName</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">packageExpresison</span><span class="p">);</span>

        <span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">packageName</span><span class="p">,</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Identifiers</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>❗ If you’re getting an error that the delegate doesn’t have a Parse method, fret not! You just have to add a <code class="language-plaintext highlighter-rouge">using Sprache;</code> directive at the top of the file.</p> </blockquote> <p>You can remove the IParser interface that we created to help us define how the code should look like.</p> <h1 id="review">Review</h1> <p>Ufs, that was long! 😩We’ve seen a lot! Let’s review all that for a moment, shall we?</p> <ul> <li>You’ve learned that language syntaxes are governed by <em>grammars</em> and that those can be expressed with a notation known as BNF or EBNF.</li> <li>You’ve created a simplified EBNF for Java, taking into account only what was in scope. You know we call this <em>best fit</em>, and an agile principle that is similar to YAGNI - build only what you’re going to use.</li> <li>You’ve created a bunch of test cases, mostly derived from the problem domain itself - the source from Google’s Authenticator.</li> <li>You’ve learned how to combine Sprache parsers to create another, more complex parser.</li> </ul> <p>This has laid the foundation for parsing the more complex program structures. In the next article, we’ll finish our grammar by creating more parsers that can deal with the whole source. I will also show you how to deal with comments and how to “skip” code that you’re not interested in. Following that article, as a bonus, we’ll finish building our tool and outputting the graph that will show users the relationship between classes.</p> <p>All code produced thus far has been stored at <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser" target="_blank" rel="noopener noreferrer">Github</a>. You’re welcome to fork it and use it in whichever way you want. To get the exact version of this code, use <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser/releases/tag/FirstArticle" target="_blank" rel="noopener noreferrer">this tag</a>.</p> <br> <div class="tag-list"> <a href="/tags/#dotnet">#dotnet</a>   <a href="/tags/#programming">#programming</a>   <a href="/tags/#language">#language</a>   <a href="/tags/#sprache">#sprache</a>   <a href="/tags/#tdd">#tdd</a> </div> </article> <div class="PageNavigation"> <a class="prev" href="/happy-halloween-blog-is-back/">← Previous</a> <a class="next" href="/read-my-blog-in-portuguese/">Next →</a> </div> <aside class="related"> <h3>Related Posts</h3> <ul class="related-posts"> <li> <a href="/parsing-code-with-sprache-part-2/"> Parsing code with Sprache - Part 2 <small><time datetime="2021-03-13T10:00:00+00:00">March 13th, 2021</time></small> </a> </li> <li> <a href="/read-my-blog-in-portuguese/"> Read my blog in portuguese or english! <small><time datetime="2021-02-17T00:00:00+00:00">February 17th, 2021</time></small> </a> </li> <li> <a href="/happy-halloween-blog-is-back/"> Happy Halloween! My blog is back! <small><time datetime="2020-10-31T18:00:00+00:00">October 31st, 2020</time></small> </a> </li> </ul> </aside> </main> <footer class="footer"> <div class="wrapper"> <div> © Copyright 2021 Bruno Brant. Theme based on <a href="https://github.com/essentialenemy/noir/" target="_blank" rel="noopener noreferrer">Noir</a> by <a href="https://essentialenemy.com/" target="_blank" rel="noopener noreferrer">Victor Johnson</a>. </div> <div class="social-links">
<ul class="social-media-list">
<li><a rel="noopener noreferrer" href="https://github.com/bruno-brant" title="bruno-brant" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li>
<li><a rel="noopener noreferrer" href="https://stackoverflow.com/users/227332%2Fbruno-brant" title="227332/bruno-brant" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#stackoverflow"></use></svg></a></li>
<li><a rel="noopener noreferrer" href="https://www.linkedin.com/in/brunobrant" title="brunobrant" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg></a></li>
<li><a rel="noopener noreferrer" href="https://twitter.com/HeavyStorm" title="HeavyStorm" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li>
</ul> </div> </div> </footer> </div> </body> </html>
