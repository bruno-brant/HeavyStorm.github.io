<!doctype html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <meta property="og:image" content="https://blog.brunobrant.net/assets/technology-matters-logo.png" /> <title> &middot; TECHNOLOGY MATTERS </title> <link rel="stylesheet" href="/styles.css"> <!-- <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/apple-touch-icon-precomposed.png"> --> <link rel="shortcut icon" href="/assets/favicon.ico"> <link rel="alternate" type="application/atom+xml" title="TECHNOLOGY MATTERS" href="/feed.xml"> <!-- Begin Jekyll SEO tag v2.7.1 --> <meta name="generator" content="Jekyll v4.1.1" /> <meta property="og:title" content="Parsing code with Sprache - Part 2" /> <meta name="author" content="Bruno Brant" /> <meta property="og:locale" content="en" /> <meta name="description" content="😎 This the second article of a multiple part series on _how to parse code with Sprache. You can read the first part here. In the previous post, we saw how to parse some text (in particular, Java code) using Sprache, a might library for C#. We saw how to use an incremental approach, and how to use unit tests to drive the development with this tool. So far we wrote a parser for Identifier and PackageName (check it here). Now we are going to move forward a bit faster. Remember that we are targeting the Java/Android source project Google Authenticator and that our final goal is to output a graph of class dependencies for this project. In this article, we’re going to try and parse all top-level elements of the current file that we’re working on, AuthenticatorActivity.java. ❗ In all code in the blog I’ve elided the inner docs for clarity. Check the repo to see the comments. Refactoring our way to success Before increment the current code, I identified a small adjustment that will help us in the next step. You see, the PackageName parser is actually parsing a package statement. Package names are used in other places so we will increase reuse by extracting a PackageName from the current parser. First, rename the parser JavaGrammar.PackageName to JavaGrammar.PackageStament, the correct name for what it’s parsing; use your IDE refactor tools for that. You also need to rename the previous test unit from PackageNameParserTests to PackageStatementParserTests to keep things coherent. Next, let’s extract the parsing of a PackageName from JavaGrammar.PackageStament. See the lines below: public static readonly Parser&lt;PackageName&gt; PackageStatement = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() // ↓↓↓↓↓↓↓ Parsing of Package Name ↓↓↓↓↓↓↓ from packageHead in Identifier from packageTail in (from delimiter in Sprache.Parse.Char(&#39;.&#39;).Once() from identifier in Identifier select identifier).Many() // ↑↑↑↑↑↑↑ Parsing of Package Name ↑↑↑↑↑↑↑ from terminator in Sprache.Parse.Char(&#39;;&#39;) // ↓↓↓↓↓↓↓ And this is how the result is build ↓↓↓↓↓↓↓ select new PackageName(new[] { packageHead }.Concat(packageTail).ToList()); // ↑↑↑↑↑↑↑ And this is how the result is build ↑↑↑↑↑↑↑↑ We will extract that into an isolated parser, this one actually called PackageName: public static readonly Parser&lt;PackageName&gt; PackageName = from packageHead in Identifier from packageTail in (from delimiter in Sprache.Parse.Char(&#39;.&#39;).Once() from identifier in Identifier select identifier).Many() select new PackageName(new[] { packageHead }.Concat(packageTail).ToList()); We need to create a structure to represent the package statement: public class PackageStatement { public PackageStatement(PackageName packageName) { PackageName = packageName; } public PackageName PackageName { get; } } Let’s update PackageStatement parser to return the structure, using PackageName parser: public static readonly Parser&lt;PackageName&gt; PackageStatement = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() from packageName in PackageName from terminator in Sprache.Parse.Char(&#39;;&#39;) select packageName; Run all tests, and you will find out that everything is working as it should. This refactor has been commited under the tag Refactor_PackageName. Parsing more structures Let’s go back to creating new parsers. The next natural structure is an import statement which has the following BNF: Import Statement IMPORT = &quot;import&quot;, PACKAGE_NAME, &quot;;&quot;; Let’s begin by updating our previous Import class. Change its name from Import to ImportStatement, which is more exact. Use your IDE refactor tool to rename the class. I’ve also created a constructor for it that initializes the PackageName: public class ImportStatement { public ImportStatement(PackageName packageName) { PackageName = packageName; } public PackageName PackageName { get; } } Now, let’s create a test for it: 😎 I’m creating a test file for each parser, even though they are (currently) all part of the same class. This isn’t standard, as it is best practice to have unit test class per class, but writing it this way makes it easier to find the tests and lets us keep our tests more organized. public class ImportStatementParserTests { [Theory] [InlineData(&quot;import android.annotation.TargetApi;&quot;)] [InlineData(&quot;import android.app.Activity;&quot;)] public void Parse_WhenValidPackageName_ReturnsStructureWithCorrectName(string importStatement) { var actual = JavaGrammar.ImportStatement.Parse(importStatement); Assert.Equal(packageName, string.Join(&#39;.&#39;, actual.PackageName.Identifiers)); } } We used the first few imports from AuthenticatorActivity, as you can see. We are also joining the identifiers as we did last time, which is becoming a bit tedious; we will improve this in the refactor step. Running this test will lead to 🔴 since code hasn’t been implemented. Let’s write the Parser now: public static readonly Parser&lt;ImportStatement&gt; ImportStatement = from importKeyword in Parse.String(&quot;import&quot;).Token() from packageName in PackageName.Token() from delimiter in Parse.Char(&#39;;&#39;).Token() select new ImportStatement(packageName); Avid readers will notice the previously-unseen-method Token() at the second line. This is one of the most useful methods in Sprache - it will remove whitespace around the character, but will demand it to be there. This means that, for instance, Parse.String(&quot;import&quot;).Token().Parse(&quot; import &quot;) will work, but Parse.String(&quot;import&quot;).Token().Parse(&quot; importasd &quot;) will not. The rest should be very readable - look for the import keyword, then a PackageName structure, and returns a import statement. Run all tests. You should get a 🟢. Moving on, let’s do a bit of refactor. Remember that I said we’d do something about string.Join(&#39;.&#39;, actual.PackageName.Identifiers)? Now it’s the time! The string representation of a package name, say, “android.content.ActivityNotFoundException” is none other than “android.content.ActivityNotFoundException”. So, what do you say we override PackageName.ToString to comply with that behavior? public class PackageName { // ... public override string ToString() { return string.Join(&#39;.&#39;, Identifiers); } } 😎 TIP: When overriding methods and properties, use the /// &lt;inheritdoc/&gt; xml doc tag. Now, following the same idea, we can add a ToString override to ImportStatement: public class ImportStatement { // ... public override string ToString() { return $&quot;import {PackageName};&quot;; } } Now we can update our unit test to reflect this refactor: [Theory] [InlineData(&quot;import android.annotation.TargetApi;&quot;)] [InlineData(&quot;import android.app.Activity;&quot;)] public void Parse_WhenValidPackageName_ReturnsStructureWithCorrectName(string importStatement) { var actual = JavaGrammar.ImportStatement.Parse(importStatement); Assert.Equal(importStatement, actual.ToString()); } ⚠ Warning: in this case the input is formatted exactly as the output of ImportStatement.ToString. However, if you parse something like &quot;import name.surname&quot;, while the parse will work, the ToString will return &quot;import name.surname&quot;, without spaces. This means that the Token() rule isn’t being tested in our suite - the reason for that being that it doesn’t appear in our scope - therefore, tests are a bit brittle and should be improved on most circunstances. I won’t do this during these exercises, but readers should definetely do it. Now, we need a way to read a block of imports in our file. We have called it IMPORT_LIST in the eBNF. The data structure for it need be no more than List&lt;ImportStatement&gt;, but we need a parser for it. Begin with a test: public class ImportListParserTests { public static IEnumerable&lt;object[]&gt; ImportLists() { yield return new string[] { @&quot; import com.google.android.apps.authenticator.util.EmptySpaceClickableDragSortListView; import com.google.android.apps.authenticator.util.annotations.FixWhenMinSdkVersion; import com.google.android.apps.authenticator2.R; import com.google.common.annotations.VisibleForTesting; &quot;.Trim(), }; yield return new string[] { @&quot; import android.support.v7.widget.Toolbar; import android.text.Html; import android.util.Log; import android.view.ActionMode; import android.view.ContextMenu; &quot;.Trim(), }; } [Theory] [MemberData(nameof(ImportLists))] public void Parse_WhenValidPackageName_ReturnsStructureWithCorrectName(string importList) { var expected = importList.Split(Environment.NewLine).ToList(); var actual = JavaGrammar.ImportList.Parse(importList); Assert.Equal(expected, actual.Select(_ =&gt; _.ToString())); } } The implementation for the list is simple: public static readonly Parser&lt;List&lt;ImportStatement&gt;&gt; ImportList = from statements in ImportStatement.Many().Token() select statements.ToList(); Now that imports are dealt with, let’s move to the next code structure in AuthenticatorActivity.java, an annotation. Annotations The next code structure in AuthenticatorActivity is the class declaration. It contains a piece of code that we haven’t talked about before, an annotation. Java annotations are analogous to C# attributes, and look like this: @FixWhenMinSdkVersion(11) Just like in C#, those structures can only appear before declarations, and in this case, it’s a class declaration. We need to create the data structure to accomodate this, and the parser to produce it. As mentioned previously, we’re interactively building the eBNF interactively. This is to make our parser simpler - to just write the code necessary for the structures that are present in the source. That’s why the annotation wasn’t mentioned before. Let’s update it: ANNOTATION = &quot;@&quot;, IDENTIFIER, &quot;(&quot;, ARGUMENT_LIST, &quot;)&quot; ARGUMENT_LIST = ARGUMENT, { &quot;,&quot; ARGUMENT } ARGUMENT = LITERAL LITERAL = INTEGER_LITERAL The above eBNF is partial; For instance, the argument list for the annotation is more complex, allowing for other types. But thus far we only have the integer parameter, so we will keep ourselves to it. The first thing is to define the data structure for an annotation. Looking at it, you can imagine that it has a identifier as its name, and then the argument list. public interface ILiteral { object Value { get; } } public class IntegerLiteral : ILiteral { public IntegerLiteral(int value) { Value = value; } public int Value { get; } object ILiteral.Value =&gt; Value; public override string ToString() { return Value.ToString(); } } public class Annotation { public Annotation(string name, List&lt;ILiteral&gt; arguments) { Name = name; Arguments = arguments; } public string Name { get; } public List&lt;Argument&gt; Arguments { get; } public override string ToString() { return $&quot;@{Name}({string.Join(&quot;, &quot;, Arguments)})&quot;; } } We have introduced a bit of abstraction that might save us some work later - we’ve made it clear that literal can be many things, no only integers. Casting it to the correct structure will enable users to get the typed value - otherwise, for now, we box the int and return it as an object. We need to create a parser for this new structure - am integer literal. Tests: public class IntergerLiteralParserTests { [Theory] [InlineData(11)] public void MyTheory(int value) { var actual = JavaGrammar.IntegerLiteral.Parse(value.ToString()); Assert.Equal(value, actual.Value); } } And the parser: public static readonly Parser&lt;IntegerLiteral&gt; IntegerLiteral = from digits in Parse.Digit.AtLeastOnce() let number = string.Concat(digits) let value = int.Parse(number) select new IntegerLiteral(value); One thing in the code above that might make you wonder is the AtLeastOnce(). This is very close to Many(), with the difference that it will fail parsing when there isn’t at least a single digit. If we do not apply this here, the parser will acceptan an empty argument list. Now we move to the actual Annotation. public class AnnotationParserTests { [Theory] [InlineData(&quot;@Number(11)&quot;, new object[] { 11 })] public void Parse_WhenAnnotationHasParameters_CorrectParameters(string annotation, object[] parameters) { var actual = JavaGrammar.Annotation.Parse(annotation); Assert.Equal(parameters, actual.Arguments.Cast&lt;object&gt;().ToArray()); } } ❗ These tests are very basic; on most production scenarios, I suggest writting tests that have more conditions; for instance, we could test cases like @ SomeAnnotation, splitting the code in two lines, etc. Look at the code being tested to find gaps or risks, and create corresponding tests. Finally, with TDD we should write one test at a time and evolve iteratively. The reason we can get away with such simple tests is we know in advance all the code that need to be parsed, so we can test agaist a real case and check if bugs arise, but even then, I would be careful where this not just a blog post. The implementation will leverage the IntegerLiteral parser we just coded: public static readonly Parser&lt;Annotation&gt; Annotation = from at in Parse.Char(&#39;@&#39;).Once() from identifier in Identifier.Token() from startList in Parse.Char(&#39;(&#39;).Token() from literal in IntegerLiteral.Token().Optional() from endList in Parse.Char(&#39;)&#39;).Token() let arguments = literal.IsDefined ? new List&lt;ILiteral&gt; { literal.Get() } : new List&lt;ILiteral&gt;() select new Annotation(identifier, arguments); Again, we can see an optional parser being called. To get the actual list, we need to do some LINQ gymnastics - either return a list with a single literal or an empty list. In the future, we’ll probably create a ArgumentList parser that should replace this, but until now, there’s no need. Tests should be 🟢. Class Declaration The next thing in the file is the actual class definition. Let’s break it down: @FixWhenMinSdkVersion(11) public class AuthenticatorActivity extends TestableActivity { // ... This is a good example because we will right out of the bat deal with extends, a common but not basal case. The annotation has already been taken care of, so let’s break down the class declaration: visibility │ │ identifier, class identifier, base class │ │ │ ┌──┴─┐ ┌─────────┴─────────┐ ┌──────┴───────┐ public class AuthenticatorActivity extends TestableActivity └─┬─┘ └──┬──┘ │ interface inheritance keyword │ class declaration keyword So we need to expand the EBNF: CLASS_DECLARATION = VISIBILITY, &quot;class&quot;, IDENTIFIER, { &quot;extends&quot;, IDENTIFIER }, &quot;{&quot;, (* ommited *), &quot;}&quot;; VISIBILITY = &quot;public&quot; ❗ We’re not dealing with other visibilities just for the moment, in other to reflect our evolving approach. As we deal with more cases, we expand on the definition. This should be actually simple, but we need to update the class structure to reflect it: public enum Visibility { Public, } public class ClassDefinition { public ClassDefinition(Visibility visibility, string name, string? baseClass = null, Annotation? annotation = null) { Visibility = visibility; Name = name; BaseClass = baseClass; Annotation = annotation; } public Visibility Visibility { get; } public string Name { get; } public string? BaseClass { get; } public Annotation? Annotation { get; } } A few things to note: we’re strictly adhering to the code excerpt that is being processed, so, even though there’s a Visibility member, it’s only possible value is Public; although Java allows for multiple annotations, we are just considering a single annotation, etc. The reason I’m folowing this approach is that we don’t know yet if those cases will arise within code. If they do, we’ll rewrite the code above. Now let’s create our tests: public class ClassDefinitionParserTests { [Fact] public void Parse_AnnotatedClassWithExtends_CorrectParameters() { var code = @&quot; @FixWhenMinSdkVersion(11) public class AuthenticatorActivity extends TestableActivity &quot;.Trim(); var actual = JavaGrammar.ClassDefinition.Parse(code); Assert.Equal(&quot;FixWhenMinSdkVersion&quot;, actual.Annotation.Name); Assert.Equal(11, actual.Annotation.Arguments[0].Value); Assert.Equal(Visibility.Public, actual.Visibility); Assert.Equal(&quot;AuthenticatorActivity&quot;, actual.Name); Assert.Equal(&quot;TestableActivity&quot;, actual.BaseClass); } } Again, the tests deal only with what we’ve seen so far. I’ve used a Fact instead of a Theory because we are only dealing with a single case. Once we have more cases to test, I’ll convert it to Theory. Ah! I’m testing the result of the annotation parsing, which is actually repeating the tests already done in the AnnotationParserTests. We could do this a bit differently and just make sure that the correct parser was called, but for now, let’s keep this simple and repeat the test. Now the implementation, albeit long, is simple, just parse each fragment we saw in the breakdown above: public static readonly Parser&lt;ClassDefinition&gt; ClassDefinition = from annotation in Annotation.Token() from visibility in Parse.String(&quot;public&quot;).Token() from classKeyword in Parse.String(&quot;class&quot;).Token() from className in Identifier.Token() from extendsKeyword in Parse.String(&quot;extends&quot;).Token() from baseClassName in Identifier.Token() select new ClassDefinition(Visibility.Public, className, baseClassName, annotation); I cut some corners here, like parsing visibility directly. We will also deal with this once we need to. Run your tests and appreciate your 🟢. Summary With this article, we’ve completed the first step: we are able to parse all top-level elements of a Java source file. You’ve learned a bit more about how to use Sprache and combine parsers, and probably picked up some techniques on how to create code that is fit for purpose, using a test-driven approach, and evolving previous code as we advance in our understanding of the problem domain, a process that is called discovery. All code produced thus far has been stored at Github. You’re welcome to fork it and use it in whichever way you want. To get the exact version of this code, use this tag. In the next article, we’ll start parsing class elements like constructors, fields and methods. We will be even more focused, dealing only with the code structures that appear in code, and hopefully we can finish parsing our first class. See you next time!" /> <meta property="og:description" content="😎 This the second article of a multiple part series on _how to parse code with Sprache. You can read the first part here. In the previous post, we saw how to parse some text (in particular, Java code) using Sprache, a might library for C#. We saw how to use an incremental approach, and how to use unit tests to drive the development with this tool. So far we wrote a parser for Identifier and PackageName (check it here). Now we are going to move forward a bit faster. Remember that we are targeting the Java/Android source project Google Authenticator and that our final goal is to output a graph of class dependencies for this project. In this article, we’re going to try and parse all top-level elements of the current file that we’re working on, AuthenticatorActivity.java. ❗ In all code in the blog I’ve elided the inner docs for clarity. Check the repo to see the comments. Refactoring our way to success Before increment the current code, I identified a small adjustment that will help us in the next step. You see, the PackageName parser is actually parsing a package statement. Package names are used in other places so we will increase reuse by extracting a PackageName from the current parser. First, rename the parser JavaGrammar.PackageName to JavaGrammar.PackageStament, the correct name for what it’s parsing; use your IDE refactor tools for that. You also need to rename the previous test unit from PackageNameParserTests to PackageStatementParserTests to keep things coherent. Next, let’s extract the parsing of a PackageName from JavaGrammar.PackageStament. See the lines below: public static readonly Parser&lt;PackageName&gt; PackageStatement = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() // ↓↓↓↓↓↓↓ Parsing of Package Name ↓↓↓↓↓↓↓ from packageHead in Identifier from packageTail in (from delimiter in Sprache.Parse.Char(&#39;.&#39;).Once() from identifier in Identifier select identifier).Many() // ↑↑↑↑↑↑↑ Parsing of Package Name ↑↑↑↑↑↑↑ from terminator in Sprache.Parse.Char(&#39;;&#39;) // ↓↓↓↓↓↓↓ And this is how the result is build ↓↓↓↓↓↓↓ select new PackageName(new[] { packageHead }.Concat(packageTail).ToList()); // ↑↑↑↑↑↑↑ And this is how the result is build ↑↑↑↑↑↑↑↑ We will extract that into an isolated parser, this one actually called PackageName: public static readonly Parser&lt;PackageName&gt; PackageName = from packageHead in Identifier from packageTail in (from delimiter in Sprache.Parse.Char(&#39;.&#39;).Once() from identifier in Identifier select identifier).Many() select new PackageName(new[] { packageHead }.Concat(packageTail).ToList()); We need to create a structure to represent the package statement: public class PackageStatement { public PackageStatement(PackageName packageName) { PackageName = packageName; } public PackageName PackageName { get; } } Let’s update PackageStatement parser to return the structure, using PackageName parser: public static readonly Parser&lt;PackageName&gt; PackageStatement = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() from packageName in PackageName from terminator in Sprache.Parse.Char(&#39;;&#39;) select packageName; Run all tests, and you will find out that everything is working as it should. This refactor has been commited under the tag Refactor_PackageName. Parsing more structures Let’s go back to creating new parsers. The next natural structure is an import statement which has the following BNF: Import Statement IMPORT = &quot;import&quot;, PACKAGE_NAME, &quot;;&quot;; Let’s begin by updating our previous Import class. Change its name from Import to ImportStatement, which is more exact. Use your IDE refactor tool to rename the class. I’ve also created a constructor for it that initializes the PackageName: public class ImportStatement { public ImportStatement(PackageName packageName) { PackageName = packageName; } public PackageName PackageName { get; } } Now, let’s create a test for it: 😎 I’m creating a test file for each parser, even though they are (currently) all part of the same class. This isn’t standard, as it is best practice to have unit test class per class, but writing it this way makes it easier to find the tests and lets us keep our tests more organized. public class ImportStatementParserTests { [Theory] [InlineData(&quot;import android.annotation.TargetApi;&quot;)] [InlineData(&quot;import android.app.Activity;&quot;)] public void Parse_WhenValidPackageName_ReturnsStructureWithCorrectName(string importStatement) { var actual = JavaGrammar.ImportStatement.Parse(importStatement); Assert.Equal(packageName, string.Join(&#39;.&#39;, actual.PackageName.Identifiers)); } } We used the first few imports from AuthenticatorActivity, as you can see. We are also joining the identifiers as we did last time, which is becoming a bit tedious; we will improve this in the refactor step. Running this test will lead to 🔴 since code hasn’t been implemented. Let’s write the Parser now: public static readonly Parser&lt;ImportStatement&gt; ImportStatement = from importKeyword in Parse.String(&quot;import&quot;).Token() from packageName in PackageName.Token() from delimiter in Parse.Char(&#39;;&#39;).Token() select new ImportStatement(packageName); Avid readers will notice the previously-unseen-method Token() at the second line. This is one of the most useful methods in Sprache - it will remove whitespace around the character, but will demand it to be there. This means that, for instance, Parse.String(&quot;import&quot;).Token().Parse(&quot; import &quot;) will work, but Parse.String(&quot;import&quot;).Token().Parse(&quot; importasd &quot;) will not. The rest should be very readable - look for the import keyword, then a PackageName structure, and returns a import statement. Run all tests. You should get a 🟢. Moving on, let’s do a bit of refactor. Remember that I said we’d do something about string.Join(&#39;.&#39;, actual.PackageName.Identifiers)? Now it’s the time! The string representation of a package name, say, “android.content.ActivityNotFoundException” is none other than “android.content.ActivityNotFoundException”. So, what do you say we override PackageName.ToString to comply with that behavior? public class PackageName { // ... public override string ToString() { return string.Join(&#39;.&#39;, Identifiers); } } 😎 TIP: When overriding methods and properties, use the /// &lt;inheritdoc/&gt; xml doc tag. Now, following the same idea, we can add a ToString override to ImportStatement: public class ImportStatement { // ... public override string ToString() { return $&quot;import {PackageName};&quot;; } } Now we can update our unit test to reflect this refactor: [Theory] [InlineData(&quot;import android.annotation.TargetApi;&quot;)] [InlineData(&quot;import android.app.Activity;&quot;)] public void Parse_WhenValidPackageName_ReturnsStructureWithCorrectName(string importStatement) { var actual = JavaGrammar.ImportStatement.Parse(importStatement); Assert.Equal(importStatement, actual.ToString()); } ⚠ Warning: in this case the input is formatted exactly as the output of ImportStatement.ToString. However, if you parse something like &quot;import name.surname&quot;, while the parse will work, the ToString will return &quot;import name.surname&quot;, without spaces. This means that the Token() rule isn’t being tested in our suite - the reason for that being that it doesn’t appear in our scope - therefore, tests are a bit brittle and should be improved on most circunstances. I won’t do this during these exercises, but readers should definetely do it. Now, we need a way to read a block of imports in our file. We have called it IMPORT_LIST in the eBNF. The data structure for it need be no more than List&lt;ImportStatement&gt;, but we need a parser for it. Begin with a test: public class ImportListParserTests { public static IEnumerable&lt;object[]&gt; ImportLists() { yield return new string[] { @&quot; import com.google.android.apps.authenticator.util.EmptySpaceClickableDragSortListView; import com.google.android.apps.authenticator.util.annotations.FixWhenMinSdkVersion; import com.google.android.apps.authenticator2.R; import com.google.common.annotations.VisibleForTesting; &quot;.Trim(), }; yield return new string[] { @&quot; import android.support.v7.widget.Toolbar; import android.text.Html; import android.util.Log; import android.view.ActionMode; import android.view.ContextMenu; &quot;.Trim(), }; } [Theory] [MemberData(nameof(ImportLists))] public void Parse_WhenValidPackageName_ReturnsStructureWithCorrectName(string importList) { var expected = importList.Split(Environment.NewLine).ToList(); var actual = JavaGrammar.ImportList.Parse(importList); Assert.Equal(expected, actual.Select(_ =&gt; _.ToString())); } } The implementation for the list is simple: public static readonly Parser&lt;List&lt;ImportStatement&gt;&gt; ImportList = from statements in ImportStatement.Many().Token() select statements.ToList(); Now that imports are dealt with, let’s move to the next code structure in AuthenticatorActivity.java, an annotation. Annotations The next code structure in AuthenticatorActivity is the class declaration. It contains a piece of code that we haven’t talked about before, an annotation. Java annotations are analogous to C# attributes, and look like this: @FixWhenMinSdkVersion(11) Just like in C#, those structures can only appear before declarations, and in this case, it’s a class declaration. We need to create the data structure to accomodate this, and the parser to produce it. As mentioned previously, we’re interactively building the eBNF interactively. This is to make our parser simpler - to just write the code necessary for the structures that are present in the source. That’s why the annotation wasn’t mentioned before. Let’s update it: ANNOTATION = &quot;@&quot;, IDENTIFIER, &quot;(&quot;, ARGUMENT_LIST, &quot;)&quot; ARGUMENT_LIST = ARGUMENT, { &quot;,&quot; ARGUMENT } ARGUMENT = LITERAL LITERAL = INTEGER_LITERAL The above eBNF is partial; For instance, the argument list for the annotation is more complex, allowing for other types. But thus far we only have the integer parameter, so we will keep ourselves to it. The first thing is to define the data structure for an annotation. Looking at it, you can imagine that it has a identifier as its name, and then the argument list. public interface ILiteral { object Value { get; } } public class IntegerLiteral : ILiteral { public IntegerLiteral(int value) { Value = value; } public int Value { get; } object ILiteral.Value =&gt; Value; public override string ToString() { return Value.ToString(); } } public class Annotation { public Annotation(string name, List&lt;ILiteral&gt; arguments) { Name = name; Arguments = arguments; } public string Name { get; } public List&lt;Argument&gt; Arguments { get; } public override string ToString() { return $&quot;@{Name}({string.Join(&quot;, &quot;, Arguments)})&quot;; } } We have introduced a bit of abstraction that might save us some work later - we’ve made it clear that literal can be many things, no only integers. Casting it to the correct structure will enable users to get the typed value - otherwise, for now, we box the int and return it as an object. We need to create a parser for this new structure - am integer literal. Tests: public class IntergerLiteralParserTests { [Theory] [InlineData(11)] public void MyTheory(int value) { var actual = JavaGrammar.IntegerLiteral.Parse(value.ToString()); Assert.Equal(value, actual.Value); } } And the parser: public static readonly Parser&lt;IntegerLiteral&gt; IntegerLiteral = from digits in Parse.Digit.AtLeastOnce() let number = string.Concat(digits) let value = int.Parse(number) select new IntegerLiteral(value); One thing in the code above that might make you wonder is the AtLeastOnce(). This is very close to Many(), with the difference that it will fail parsing when there isn’t at least a single digit. If we do not apply this here, the parser will acceptan an empty argument list. Now we move to the actual Annotation. public class AnnotationParserTests { [Theory] [InlineData(&quot;@Number(11)&quot;, new object[] { 11 })] public void Parse_WhenAnnotationHasParameters_CorrectParameters(string annotation, object[] parameters) { var actual = JavaGrammar.Annotation.Parse(annotation); Assert.Equal(parameters, actual.Arguments.Cast&lt;object&gt;().ToArray()); } } ❗ These tests are very basic; on most production scenarios, I suggest writting tests that have more conditions; for instance, we could test cases like @ SomeAnnotation, splitting the code in two lines, etc. Look at the code being tested to find gaps or risks, and create corresponding tests. Finally, with TDD we should write one test at a time and evolve iteratively. The reason we can get away with such simple tests is we know in advance all the code that need to be parsed, so we can test agaist a real case and check if bugs arise, but even then, I would be careful where this not just a blog post. The implementation will leverage the IntegerLiteral parser we just coded: public static readonly Parser&lt;Annotation&gt; Annotation = from at in Parse.Char(&#39;@&#39;).Once() from identifier in Identifier.Token() from startList in Parse.Char(&#39;(&#39;).Token() from literal in IntegerLiteral.Token().Optional() from endList in Parse.Char(&#39;)&#39;).Token() let arguments = literal.IsDefined ? new List&lt;ILiteral&gt; { literal.Get() } : new List&lt;ILiteral&gt;() select new Annotation(identifier, arguments); Again, we can see an optional parser being called. To get the actual list, we need to do some LINQ gymnastics - either return a list with a single literal or an empty list. In the future, we’ll probably create a ArgumentList parser that should replace this, but until now, there’s no need. Tests should be 🟢. Class Declaration The next thing in the file is the actual class definition. Let’s break it down: @FixWhenMinSdkVersion(11) public class AuthenticatorActivity extends TestableActivity { // ... This is a good example because we will right out of the bat deal with extends, a common but not basal case. The annotation has already been taken care of, so let’s break down the class declaration: visibility │ │ identifier, class identifier, base class │ │ │ ┌──┴─┐ ┌─────────┴─────────┐ ┌──────┴───────┐ public class AuthenticatorActivity extends TestableActivity └─┬─┘ └──┬──┘ │ interface inheritance keyword │ class declaration keyword So we need to expand the EBNF: CLASS_DECLARATION = VISIBILITY, &quot;class&quot;, IDENTIFIER, { &quot;extends&quot;, IDENTIFIER }, &quot;{&quot;, (* ommited *), &quot;}&quot;; VISIBILITY = &quot;public&quot; ❗ We’re not dealing with other visibilities just for the moment, in other to reflect our evolving approach. As we deal with more cases, we expand on the definition. This should be actually simple, but we need to update the class structure to reflect it: public enum Visibility { Public, } public class ClassDefinition { public ClassDefinition(Visibility visibility, string name, string? baseClass = null, Annotation? annotation = null) { Visibility = visibility; Name = name; BaseClass = baseClass; Annotation = annotation; } public Visibility Visibility { get; } public string Name { get; } public string? BaseClass { get; } public Annotation? Annotation { get; } } A few things to note: we’re strictly adhering to the code excerpt that is being processed, so, even though there’s a Visibility member, it’s only possible value is Public; although Java allows for multiple annotations, we are just considering a single annotation, etc. The reason I’m folowing this approach is that we don’t know yet if those cases will arise within code. If they do, we’ll rewrite the code above. Now let’s create our tests: public class ClassDefinitionParserTests { [Fact] public void Parse_AnnotatedClassWithExtends_CorrectParameters() { var code = @&quot; @FixWhenMinSdkVersion(11) public class AuthenticatorActivity extends TestableActivity &quot;.Trim(); var actual = JavaGrammar.ClassDefinition.Parse(code); Assert.Equal(&quot;FixWhenMinSdkVersion&quot;, actual.Annotation.Name); Assert.Equal(11, actual.Annotation.Arguments[0].Value); Assert.Equal(Visibility.Public, actual.Visibility); Assert.Equal(&quot;AuthenticatorActivity&quot;, actual.Name); Assert.Equal(&quot;TestableActivity&quot;, actual.BaseClass); } } Again, the tests deal only with what we’ve seen so far. I’ve used a Fact instead of a Theory because we are only dealing with a single case. Once we have more cases to test, I’ll convert it to Theory. Ah! I’m testing the result of the annotation parsing, which is actually repeating the tests already done in the AnnotationParserTests. We could do this a bit differently and just make sure that the correct parser was called, but for now, let’s keep this simple and repeat the test. Now the implementation, albeit long, is simple, just parse each fragment we saw in the breakdown above: public static readonly Parser&lt;ClassDefinition&gt; ClassDefinition = from annotation in Annotation.Token() from visibility in Parse.String(&quot;public&quot;).Token() from classKeyword in Parse.String(&quot;class&quot;).Token() from className in Identifier.Token() from extendsKeyword in Parse.String(&quot;extends&quot;).Token() from baseClassName in Identifier.Token() select new ClassDefinition(Visibility.Public, className, baseClassName, annotation); I cut some corners here, like parsing visibility directly. We will also deal with this once we need to. Run your tests and appreciate your 🟢. Summary With this article, we’ve completed the first step: we are able to parse all top-level elements of a Java source file. You’ve learned a bit more about how to use Sprache and combine parsers, and probably picked up some techniques on how to create code that is fit for purpose, using a test-driven approach, and evolving previous code as we advance in our understanding of the problem domain, a process that is called discovery. All code produced thus far has been stored at Github. You’re welcome to fork it and use it in whichever way you want. To get the exact version of this code, use this tag. In the next article, we’ll start parsing class elements like constructors, fields and methods. We will be even more focused, dealing only with the code structures that appear in code, and hopefully we can finish parsing our first class. See you next time!" /> <link rel="canonical" href="https://blog.brunobrant.net/parsing-code-with-sprache-part-2/" /> <meta property="og:url" content="https://blog.brunobrant.net/parsing-code-with-sprache-part-2/" /> <meta property="og:site_name" content="TECHNOLOGY MATTERS" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2021-03-13T10:00:00+00:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Parsing code with Sprache - Part 2" /> <script type="application/ld+json"> {"datePublished":"2021-03-13T10:00:00+00:00","description":"😎 This the second article of a multiple part series on _how to parse code with Sprache. You can read the first part here. In the previous post, we saw how to parse some text (in particular, Java code) using Sprache, a might library for C#. We saw how to use an incremental approach, and how to use unit tests to drive the development with this tool. So far we wrote a parser for Identifier and PackageName (check it here). Now we are going to move forward a bit faster. Remember that we are targeting the Java/Android source project Google Authenticator and that our final goal is to output a graph of class dependencies for this project. In this article, we’re going to try and parse all top-level elements of the current file that we’re working on, AuthenticatorActivity.java. ❗ In all code in the blog I’ve elided the inner docs for clarity. Check the repo to see the comments. Refactoring our way to success Before increment the current code, I identified a small adjustment that will help us in the next step. You see, the PackageName parser is actually parsing a package statement. Package names are used in other places so we will increase reuse by extracting a PackageName from the current parser. First, rename the parser JavaGrammar.PackageName to JavaGrammar.PackageStament, the correct name for what it’s parsing; use your IDE refactor tools for that. You also need to rename the previous test unit from PackageNameParserTests to PackageStatementParserTests to keep things coherent. Next, let’s extract the parsing of a PackageName from JavaGrammar.PackageStament. See the lines below: public static readonly Parser&lt;PackageName&gt; PackageStatement = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() // ↓↓↓↓↓↓↓ Parsing of Package Name ↓↓↓↓↓↓↓ from packageHead in Identifier from packageTail in (from delimiter in Sprache.Parse.Char(&#39;.&#39;).Once() from identifier in Identifier select identifier).Many() // ↑↑↑↑↑↑↑ Parsing of Package Name ↑↑↑↑↑↑↑ from terminator in Sprache.Parse.Char(&#39;;&#39;) // ↓↓↓↓↓↓↓ And this is how the result is build ↓↓↓↓↓↓↓ select new PackageName(new[] { packageHead }.Concat(packageTail).ToList()); // ↑↑↑↑↑↑↑ And this is how the result is build ↑↑↑↑↑↑↑↑ We will extract that into an isolated parser, this one actually called PackageName: public static readonly Parser&lt;PackageName&gt; PackageName = from packageHead in Identifier from packageTail in (from delimiter in Sprache.Parse.Char(&#39;.&#39;).Once() from identifier in Identifier select identifier).Many() select new PackageName(new[] { packageHead }.Concat(packageTail).ToList()); We need to create a structure to represent the package statement: public class PackageStatement { public PackageStatement(PackageName packageName) { PackageName = packageName; } public PackageName PackageName { get; } } Let’s update PackageStatement parser to return the structure, using PackageName parser: public static readonly Parser&lt;PackageName&gt; PackageStatement = from packageKeyword in Sprache.Parse.String(&quot;package&quot;).Once() from space in Sprache.Parse.WhiteSpace.Many() from packageName in PackageName from terminator in Sprache.Parse.Char(&#39;;&#39;) select packageName; Run all tests, and you will find out that everything is working as it should. This refactor has been commited under the tag Refactor_PackageName. Parsing more structures Let’s go back to creating new parsers. The next natural structure is an import statement which has the following BNF: Import Statement IMPORT = &quot;import&quot;, PACKAGE_NAME, &quot;;&quot;; Let’s begin by updating our previous Import class. Change its name from Import to ImportStatement, which is more exact. Use your IDE refactor tool to rename the class. I’ve also created a constructor for it that initializes the PackageName: public class ImportStatement { public ImportStatement(PackageName packageName) { PackageName = packageName; } public PackageName PackageName { get; } } Now, let’s create a test for it: 😎 I’m creating a test file for each parser, even though they are (currently) all part of the same class. This isn’t standard, as it is best practice to have unit test class per class, but writing it this way makes it easier to find the tests and lets us keep our tests more organized. public class ImportStatementParserTests { [Theory] [InlineData(&quot;import android.annotation.TargetApi;&quot;)] [InlineData(&quot;import android.app.Activity;&quot;)] public void Parse_WhenValidPackageName_ReturnsStructureWithCorrectName(string importStatement) { var actual = JavaGrammar.ImportStatement.Parse(importStatement); Assert.Equal(packageName, string.Join(&#39;.&#39;, actual.PackageName.Identifiers)); } } We used the first few imports from AuthenticatorActivity, as you can see. We are also joining the identifiers as we did last time, which is becoming a bit tedious; we will improve this in the refactor step. Running this test will lead to 🔴 since code hasn’t been implemented. Let’s write the Parser now: public static readonly Parser&lt;ImportStatement&gt; ImportStatement = from importKeyword in Parse.String(&quot;import&quot;).Token() from packageName in PackageName.Token() from delimiter in Parse.Char(&#39;;&#39;).Token() select new ImportStatement(packageName); Avid readers will notice the previously-unseen-method Token() at the second line. This is one of the most useful methods in Sprache - it will remove whitespace around the character, but will demand it to be there. This means that, for instance, Parse.String(&quot;import&quot;).Token().Parse(&quot; import &quot;) will work, but Parse.String(&quot;import&quot;).Token().Parse(&quot; importasd &quot;) will not. The rest should be very readable - look for the import keyword, then a PackageName structure, and returns a import statement. Run all tests. You should get a 🟢. Moving on, let’s do a bit of refactor. Remember that I said we’d do something about string.Join(&#39;.&#39;, actual.PackageName.Identifiers)? Now it’s the time! The string representation of a package name, say, “android.content.ActivityNotFoundException” is none other than “android.content.ActivityNotFoundException”. So, what do you say we override PackageName.ToString to comply with that behavior? public class PackageName { // ... public override string ToString() { return string.Join(&#39;.&#39;, Identifiers); } } 😎 TIP: When overriding methods and properties, use the /// &lt;inheritdoc/&gt; xml doc tag. Now, following the same idea, we can add a ToString override to ImportStatement: public class ImportStatement { // ... public override string ToString() { return $&quot;import {PackageName};&quot;; } } Now we can update our unit test to reflect this refactor: [Theory] [InlineData(&quot;import android.annotation.TargetApi;&quot;)] [InlineData(&quot;import android.app.Activity;&quot;)] public void Parse_WhenValidPackageName_ReturnsStructureWithCorrectName(string importStatement) { var actual = JavaGrammar.ImportStatement.Parse(importStatement); Assert.Equal(importStatement, actual.ToString()); } ⚠ Warning: in this case the input is formatted exactly as the output of ImportStatement.ToString. However, if you parse something like &quot;import name.surname&quot;, while the parse will work, the ToString will return &quot;import name.surname&quot;, without spaces. This means that the Token() rule isn’t being tested in our suite - the reason for that being that it doesn’t appear in our scope - therefore, tests are a bit brittle and should be improved on most circunstances. I won’t do this during these exercises, but readers should definetely do it. Now, we need a way to read a block of imports in our file. We have called it IMPORT_LIST in the eBNF. The data structure for it need be no more than List&lt;ImportStatement&gt;, but we need a parser for it. Begin with a test: public class ImportListParserTests { public static IEnumerable&lt;object[]&gt; ImportLists() { yield return new string[] { @&quot; import com.google.android.apps.authenticator.util.EmptySpaceClickableDragSortListView; import com.google.android.apps.authenticator.util.annotations.FixWhenMinSdkVersion; import com.google.android.apps.authenticator2.R; import com.google.common.annotations.VisibleForTesting; &quot;.Trim(), }; yield return new string[] { @&quot; import android.support.v7.widget.Toolbar; import android.text.Html; import android.util.Log; import android.view.ActionMode; import android.view.ContextMenu; &quot;.Trim(), }; } [Theory] [MemberData(nameof(ImportLists))] public void Parse_WhenValidPackageName_ReturnsStructureWithCorrectName(string importList) { var expected = importList.Split(Environment.NewLine).ToList(); var actual = JavaGrammar.ImportList.Parse(importList); Assert.Equal(expected, actual.Select(_ =&gt; _.ToString())); } } The implementation for the list is simple: public static readonly Parser&lt;List&lt;ImportStatement&gt;&gt; ImportList = from statements in ImportStatement.Many().Token() select statements.ToList(); Now that imports are dealt with, let’s move to the next code structure in AuthenticatorActivity.java, an annotation. Annotations The next code structure in AuthenticatorActivity is the class declaration. It contains a piece of code that we haven’t talked about before, an annotation. Java annotations are analogous to C# attributes, and look like this: @FixWhenMinSdkVersion(11) Just like in C#, those structures can only appear before declarations, and in this case, it’s a class declaration. We need to create the data structure to accomodate this, and the parser to produce it. As mentioned previously, we’re interactively building the eBNF interactively. This is to make our parser simpler - to just write the code necessary for the structures that are present in the source. That’s why the annotation wasn’t mentioned before. Let’s update it: ANNOTATION = &quot;@&quot;, IDENTIFIER, &quot;(&quot;, ARGUMENT_LIST, &quot;)&quot; ARGUMENT_LIST = ARGUMENT, { &quot;,&quot; ARGUMENT } ARGUMENT = LITERAL LITERAL = INTEGER_LITERAL The above eBNF is partial; For instance, the argument list for the annotation is more complex, allowing for other types. But thus far we only have the integer parameter, so we will keep ourselves to it. The first thing is to define the data structure for an annotation. Looking at it, you can imagine that it has a identifier as its name, and then the argument list. public interface ILiteral { object Value { get; } } public class IntegerLiteral : ILiteral { public IntegerLiteral(int value) { Value = value; } public int Value { get; } object ILiteral.Value =&gt; Value; public override string ToString() { return Value.ToString(); } } public class Annotation { public Annotation(string name, List&lt;ILiteral&gt; arguments) { Name = name; Arguments = arguments; } public string Name { get; } public List&lt;Argument&gt; Arguments { get; } public override string ToString() { return $&quot;@{Name}({string.Join(&quot;, &quot;, Arguments)})&quot;; } } We have introduced a bit of abstraction that might save us some work later - we’ve made it clear that literal can be many things, no only integers. Casting it to the correct structure will enable users to get the typed value - otherwise, for now, we box the int and return it as an object. We need to create a parser for this new structure - am integer literal. Tests: public class IntergerLiteralParserTests { [Theory] [InlineData(11)] public void MyTheory(int value) { var actual = JavaGrammar.IntegerLiteral.Parse(value.ToString()); Assert.Equal(value, actual.Value); } } And the parser: public static readonly Parser&lt;IntegerLiteral&gt; IntegerLiteral = from digits in Parse.Digit.AtLeastOnce() let number = string.Concat(digits) let value = int.Parse(number) select new IntegerLiteral(value); One thing in the code above that might make you wonder is the AtLeastOnce(). This is very close to Many(), with the difference that it will fail parsing when there isn’t at least a single digit. If we do not apply this here, the parser will acceptan an empty argument list. Now we move to the actual Annotation. public class AnnotationParserTests { [Theory] [InlineData(&quot;@Number(11)&quot;, new object[] { 11 })] public void Parse_WhenAnnotationHasParameters_CorrectParameters(string annotation, object[] parameters) { var actual = JavaGrammar.Annotation.Parse(annotation); Assert.Equal(parameters, actual.Arguments.Cast&lt;object&gt;().ToArray()); } } ❗ These tests are very basic; on most production scenarios, I suggest writting tests that have more conditions; for instance, we could test cases like @ SomeAnnotation, splitting the code in two lines, etc. Look at the code being tested to find gaps or risks, and create corresponding tests. Finally, with TDD we should write one test at a time and evolve iteratively. The reason we can get away with such simple tests is we know in advance all the code that need to be parsed, so we can test agaist a real case and check if bugs arise, but even then, I would be careful where this not just a blog post. The implementation will leverage the IntegerLiteral parser we just coded: public static readonly Parser&lt;Annotation&gt; Annotation = from at in Parse.Char(&#39;@&#39;).Once() from identifier in Identifier.Token() from startList in Parse.Char(&#39;(&#39;).Token() from literal in IntegerLiteral.Token().Optional() from endList in Parse.Char(&#39;)&#39;).Token() let arguments = literal.IsDefined ? new List&lt;ILiteral&gt; { literal.Get() } : new List&lt;ILiteral&gt;() select new Annotation(identifier, arguments); Again, we can see an optional parser being called. To get the actual list, we need to do some LINQ gymnastics - either return a list with a single literal or an empty list. In the future, we’ll probably create a ArgumentList parser that should replace this, but until now, there’s no need. Tests should be 🟢. Class Declaration The next thing in the file is the actual class definition. Let’s break it down: @FixWhenMinSdkVersion(11) public class AuthenticatorActivity extends TestableActivity { // ... This is a good example because we will right out of the bat deal with extends, a common but not basal case. The annotation has already been taken care of, so let’s break down the class declaration: visibility │ │ identifier, class identifier, base class │ │ │ ┌──┴─┐ ┌─────────┴─────────┐ ┌──────┴───────┐ public class AuthenticatorActivity extends TestableActivity └─┬─┘ └──┬──┘ │ interface inheritance keyword │ class declaration keyword So we need to expand the EBNF: CLASS_DECLARATION = VISIBILITY, &quot;class&quot;, IDENTIFIER, { &quot;extends&quot;, IDENTIFIER }, &quot;{&quot;, (* ommited *), &quot;}&quot;; VISIBILITY = &quot;public&quot; ❗ We’re not dealing with other visibilities just for the moment, in other to reflect our evolving approach. As we deal with more cases, we expand on the definition. This should be actually simple, but we need to update the class structure to reflect it: public enum Visibility { Public, } public class ClassDefinition { public ClassDefinition(Visibility visibility, string name, string? baseClass = null, Annotation? annotation = null) { Visibility = visibility; Name = name; BaseClass = baseClass; Annotation = annotation; } public Visibility Visibility { get; } public string Name { get; } public string? BaseClass { get; } public Annotation? Annotation { get; } } A few things to note: we’re strictly adhering to the code excerpt that is being processed, so, even though there’s a Visibility member, it’s only possible value is Public; although Java allows for multiple annotations, we are just considering a single annotation, etc. The reason I’m folowing this approach is that we don’t know yet if those cases will arise within code. If they do, we’ll rewrite the code above. Now let’s create our tests: public class ClassDefinitionParserTests { [Fact] public void Parse_AnnotatedClassWithExtends_CorrectParameters() { var code = @&quot; @FixWhenMinSdkVersion(11) public class AuthenticatorActivity extends TestableActivity &quot;.Trim(); var actual = JavaGrammar.ClassDefinition.Parse(code); Assert.Equal(&quot;FixWhenMinSdkVersion&quot;, actual.Annotation.Name); Assert.Equal(11, actual.Annotation.Arguments[0].Value); Assert.Equal(Visibility.Public, actual.Visibility); Assert.Equal(&quot;AuthenticatorActivity&quot;, actual.Name); Assert.Equal(&quot;TestableActivity&quot;, actual.BaseClass); } } Again, the tests deal only with what we’ve seen so far. I’ve used a Fact instead of a Theory because we are only dealing with a single case. Once we have more cases to test, I’ll convert it to Theory. Ah! I’m testing the result of the annotation parsing, which is actually repeating the tests already done in the AnnotationParserTests. We could do this a bit differently and just make sure that the correct parser was called, but for now, let’s keep this simple and repeat the test. Now the implementation, albeit long, is simple, just parse each fragment we saw in the breakdown above: public static readonly Parser&lt;ClassDefinition&gt; ClassDefinition = from annotation in Annotation.Token() from visibility in Parse.String(&quot;public&quot;).Token() from classKeyword in Parse.String(&quot;class&quot;).Token() from className in Identifier.Token() from extendsKeyword in Parse.String(&quot;extends&quot;).Token() from baseClassName in Identifier.Token() select new ClassDefinition(Visibility.Public, className, baseClassName, annotation); I cut some corners here, like parsing visibility directly. We will also deal with this once we need to. Run your tests and appreciate your 🟢. Summary With this article, we’ve completed the first step: we are able to parse all top-level elements of a Java source file. You’ve learned a bit more about how to use Sprache and combine parsers, and probably picked up some techniques on how to create code that is fit for purpose, using a test-driven approach, and evolving previous code as we advance in our understanding of the problem domain, a process that is called discovery. All code produced thus far has been stored at Github. You’re welcome to fork it and use it in whichever way you want. To get the exact version of this code, use this tag. In the next article, we’ll start parsing class elements like constructors, fields and methods. We will be even more focused, dealing only with the code structures that appear in code, and hopefully we can finish parsing our first class. See you next time!","url":"https://blog.brunobrant.net/parsing-code-with-sprache-part-2/","@type":"BlogPosting","dateModified":"2021-03-13T10:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.brunobrant.net/parsing-code-with-sprache-part-2/"},"author":{"@type":"Person","name":"Bruno Brant"},"headline":"Parsing code with Sprache - Part 2","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <script> /* Toggle between adding and removing the "responsive" class to topnav when the user clicks on the icon */ function openNavigation() { const navigationElems = document.getElementsByClassName("navigation"); if (navigationElems.length != 1) { console.warn("Couldn't find navbar"); return; } const x = navigationElems[0]; if (x.className === "navigation") { x.className += " responsive"; } else { x.className = "navigation"; } } </script> <body> <div class="container content"> <header class="masthead"> <h3 class="masthead-title"> <a href="/" title="Home" class="masthead-title-main">TECHNOLOGY MATTERS</a><br> <small>a bunch of unsorted thoughts about tech, software, etc.</small> </h3> <!-- Change navigation links here --> <div class="navigation"> <ul id="navigation-list"> <li> <a href="/">HOME</a> </li> <li> <a href="/archive/">POSTS</a> </li> <li> <a href="/tags/">TAGS</a> </li> <li> <a href="/categories/">CATEGORIES</a> </li> <li> <a href="/about/">ABOUT</a> </li> <li id="subscribe"> <a href="/feed.xml"> <p>SUBSCRIBE</p> <svg class="svg-icon grey" style="fill: #f66a0a;"> <use xlink:href="/assets/minima-social-icons.svg#rss"></use> </svg> </a> </li> </ul> <div style="float:right"> <a href="javascript:void(0);" class="navigation-icon" onclick="openNavigation()">☰</a> </div> </div> <!-- Language selector --> <div class="language-selector"> <span class="language-selector-label">read this site in:</span> <a href="/parsing-code-with-sprache-part-2/"><span>🇺🇸</span></a> | <a href="/pt/parsing-code-with-sprache-part-2/"><span>🇧🇷</span></a> </div> </header> <main> <!-- Change navigation links here --> <article class="post"> <h1 class="post-title">Parsing code with Sprache - Part 2</h1> <time datetime="2021-03-13T10:00:00+00:00" class="post-date">March 13th, 2021 in <a href="/categories/#Development">Development</a> </time> <blockquote> <p>😎 This the second article of a multiple part series on _how to parse code with Sprache. You can read the first part <a href="2021-02-13-parsing-code-with-sprache">here</a>.</p> </blockquote> <p>In the previous post, we saw how to parse some text (in particular, Java code) using <a href="https://github.com/sprache/Sprache" target="_blank" rel="noopener noreferrer">Sprache</a>, a might library for C#. We saw how to use an incremental approach, and how to use unit tests to drive the development with this tool. So far we wrote a parser for <code class="language-plaintext highlighter-rouge">Identifier</code> and <code class="language-plaintext highlighter-rouge">PackageName</code> (check it <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser/blob/c5f7f6ce78382ac47e8ab0d03ca43851425d1545/src/TinyJavaParser/JavaGrammar.cs" target="_blank" rel="noopener noreferrer">here</a>).</p> <p>Now we are going to move forward a bit faster. Remember that we are targeting the Java/Android source project <a href="https://github.com/google/google-authenticator-android/tree/master/java/com/google/android/apps/authenticator" target="_blank" rel="noopener noreferrer">Google Authenticator</a> and that our final goal is to output a graph of class dependencies for this project. In this article, we’re going to try and parse all top-level elements of the current file that we’re working on, <a href="https://github.com/google/google-authenticator-android/blob/master/java/com/google/android/apps/authenticator/AuthenticatorActivity.java" target="_blank" rel="noopener noreferrer">AuthenticatorActivity.java</a>.</p> <blockquote> <p>❗ In all code in the blog I’ve elided the inner docs for clarity. Check the <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser" target="_blank" rel="noopener noreferrer">repo</a> to see the comments.</p> </blockquote> <h1 id="refactoring-our-way-to-success">Refactoring our way to success</h1> <p>Before increment the current code, I identified a small adjustment that will help us in the next step. You see, the <code class="language-plaintext highlighter-rouge">PackageName</code> parser is actually parsing a <em>package statement</em>. Package names are used in other places so we will increase reuse by extracting a <code class="language-plaintext highlighter-rouge">PackageName</code> from the current parser.</p> <p>First, rename the parser <code class="language-plaintext highlighter-rouge">JavaGrammar.PackageName</code> to <code class="language-plaintext highlighter-rouge">JavaGrammar.PackageStament</code>, the correct name for what it’s parsing; use your IDE refactor tools for that. You also need to rename the previous test unit from <code class="language-plaintext highlighter-rouge">PackageNameParserTests</code> to <code class="language-plaintext highlighter-rouge">PackageStatementParserTests</code> to keep things coherent.</p> <p>Next, let’s extract the parsing of a <code class="language-plaintext highlighter-rouge">PackageName</code> from <code class="language-plaintext highlighter-rouge">JavaGrammar.PackageStament</code>. See the lines below:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">PackageStatement</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
	<span class="c1">// ↓↓↓↓↓↓↓ Parsing of Package Name ↓↓↓↓↓↓↓</span>
	<span class="k">from</span> <span class="n">packageHead</span> <span class="k">in</span> <span class="n">Identifier</span>
	<span class="k">from</span> <span class="n">packageTail</span> <span class="k">in</span> <span class="p">(</span><span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'.'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
							<span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">Identifier</span>
							<span class="k">select</span> <span class="n">identifier</span><span class="p">).</span><span class="nf">Many</span><span class="p">()</span>
	<span class="c1">// ↑↑↑↑↑↑↑ Parsing of Package Name ↑↑↑↑↑↑↑</span>
	<span class="k">from</span> <span class="n">terminator</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
	<span class="c1">// ↓↓↓↓↓↓↓ And this is how the result is build ↓↓↓↓↓↓↓</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">PackageName</span><span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="n">packageHead</span> <span class="p">}.</span><span class="nf">Concat</span><span class="p">(</span><span class="n">packageTail</span><span class="p">).</span><span class="nf">ToList</span><span class="p">());</span>
	<span class="c1">// ↑↑↑↑↑↑↑ And this is how the result is build ↑↑↑↑↑↑↑↑</span>
</code></pre></div></div> <p>We will extract that into an isolated parser, this one actually called <code class="language-plaintext highlighter-rouge">PackageName</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">PackageName</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">packageHead</span> <span class="k">in</span> <span class="n">Identifier</span>
	<span class="k">from</span> <span class="n">packageTail</span> <span class="k">in</span> <span class="p">(</span><span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'.'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
						 <span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">Identifier</span>
						 <span class="k">select</span> <span class="n">identifier</span><span class="p">).</span><span class="nf">Many</span><span class="p">()</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">PackageName</span><span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="n">packageHead</span> <span class="p">}.</span><span class="nf">Concat</span><span class="p">(</span><span class="n">packageTail</span><span class="p">).</span><span class="nf">ToList</span><span class="p">());</span>
</code></pre></div></div> <p>We need to create a structure to represent the <em>package statement</em>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageStatement</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">PackageStatement</span><span class="p">(</span><span class="n">PackageName</span> <span class="n">packageName</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">PackageName</span> <span class="p">=</span> <span class="n">packageName</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">PackageName</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Let’s update <code class="language-plaintext highlighter-rouge">PackageStatement</code> parser to return the structure, using <code class="language-plaintext highlighter-rouge">PackageName</code> parser:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">PackageName</span><span class="p">&gt;</span> <span class="n">PackageStatement</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">packageKeyword</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"package"</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">space</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="n">WhiteSpace</span><span class="p">.</span><span class="nf">Many</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">packageName</span> <span class="k">in</span> <span class="n">PackageName</span>
	<span class="k">from</span> <span class="n">terminator</span> <span class="k">in</span> <span class="n">Sprache</span><span class="p">.</span><span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">)</span>
	<span class="k">select</span> <span class="n">packageName</span><span class="p">;</span>
</code></pre></div></div> <p>Run all tests, and you will find out that everything is working as it should. This refactor has been commited under the tag <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser/tree/Refactor_PackageName" target="_blank" rel="noopener noreferrer">Refactor_PackageName</a>.</p> <h1 id="parsing-more-structures">Parsing more structures</h1> <p>Let’s go back to creating new parsers. The next natural structure is an import statement which has the following BNF:</p> <h2 id="import-statement">Import Statement</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IMPORT = "import", PACKAGE_NAME, ";";
</code></pre></div></div> <p>Let’s begin by updating our previous <code class="language-plaintext highlighter-rouge">Import</code> class. Change its name from <code class="language-plaintext highlighter-rouge">Import</code> to <code class="language-plaintext highlighter-rouge">ImportStatement</code>, which is more exact. <strong>Use your IDE refactor tool to rename the class.</strong> I’ve also created a constructor for it that initializes the <code class="language-plaintext highlighter-rouge">PackageName</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ImportStatement</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">ImportStatement</span><span class="p">(</span><span class="n">PackageName</span> <span class="n">packageName</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">PackageName</span> <span class="p">=</span> <span class="n">packageName</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">PackageName</span> <span class="n">PackageName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Now, let’s create a test for it:</p> <blockquote> <p>😎 I’m creating a test file for each parser, even though they are (currently) all part of the same class. This isn’t <em>standard</em>, as it is best practice to have unit test class <em>per class</em>, but writing it this way makes it easier to find the tests and lets us keep our tests more organized.</p> </blockquote> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ImportStatementParserTests</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
	<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"import android.annotation.TargetApi;"</span><span class="p">)]</span>
	<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"import android.app.Activity;"</span><span class="p">)]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackageName_ReturnsStructureWithCorrectName</span><span class="p">(</span><span class="kt">string</span> <span class="n">importStatement</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">ImportStatement</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">importStatement</span><span class="p">);</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">packageName</span><span class="p">,</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">PackageName</span><span class="p">.</span><span class="n">Identifiers</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>We used the first few imports from <code class="language-plaintext highlighter-rouge">AuthenticatorActivity</code>, as you can see. We are also joining the identifiers as we did last time, which is becoming a bit tedious; we will improve this in the <em>refactor</em> step.</p> <p>Running this test will lead to 🔴 since code hasn’t been implemented. Let’s write the Parser now:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">ImportStatement</span><span class="p">&gt;</span> <span class="n">ImportStatement</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">importKeyword</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"import"</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">packageName</span> <span class="k">in</span> <span class="n">PackageName</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">delimiter</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">';'</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">ImportStatement</span><span class="p">(</span><span class="n">packageName</span><span class="p">);</span>
</code></pre></div></div> <p>Avid readers will notice the previously-unseen-method <code class="language-plaintext highlighter-rouge">Token()</code> at the second line. This is one of the most useful methods in Sprache - it will remove whitespace around the character, but will <em>demand</em> it to be there. This means that, for instance, <code class="language-plaintext highlighter-rouge">Parse.String("import").Token().Parse(" import ")</code> will work, but <code class="language-plaintext highlighter-rouge">Parse.String("import").Token().Parse(" importasd ")</code> will not.</p> <p>The rest should be very readable - look for the <code class="language-plaintext highlighter-rouge">import</code> keyword, then a PackageName structure, and returns a import statement. <strong>Run all tests.</strong> You should get a 🟢.</p> <p>Moving on, let’s do a bit of refactor. Remember that I said we’d do something about <code class="language-plaintext highlighter-rouge">string.Join('.', actual.PackageName.Identifiers)</code>? Now it’s the time!</p> <p>The string representation of a package name, say, “android.content.ActivityNotFoundException” is none other than “android.content.ActivityNotFoundException”. So, what do you say we override <code class="language-plaintext highlighter-rouge">PackageName.ToString</code> to comply with that behavior?</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PackageName</span>
<span class="p">{</span>
	<span class="c1">// ...</span>

	<span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="sc">'.'</span><span class="p">,</span> <span class="n">Identifiers</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>😎 <strong>TIP:</strong> When overriding methods and properties, use the <code class="language-plaintext highlighter-rouge">/// &lt;inheritdoc/&gt;</code> xml doc tag.</p> </blockquote> <p>Now, following the same idea, we can add a <code class="language-plaintext highlighter-rouge">ToString</code> override to <code class="language-plaintext highlighter-rouge">ImportStatement</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ImportStatement</span>
<span class="p">{</span>
	<span class="c1">// ...</span>

	<span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="s">$"import </span><span class="p">{</span><span class="n">PackageName</span><span class="p">}</span><span class="s">;"</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Now we can update our unit test to reflect this refactor:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"import android.annotation.TargetApi;"</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"import android.app.Activity;"</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackageName_ReturnsStructureWithCorrectName</span><span class="p">(</span><span class="kt">string</span> <span class="n">importStatement</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">ImportStatement</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">importStatement</span><span class="p">);</span>

	<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">importStatement</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="nf">ToString</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>⚠ <strong>Warning</strong>: in this case the input is formatted exactly as the output of <code class="language-plaintext highlighter-rouge">ImportStatement.ToString</code>. However, if you parse something like <code class="language-plaintext highlighter-rouge">"import name.surname"</code>, while the parse will work, the <code class="language-plaintext highlighter-rouge">ToString</code> will return <code class="language-plaintext highlighter-rouge">"import name.surname"</code>, without spaces. This means that the <code class="language-plaintext highlighter-rouge">Token()</code> rule isn’t being tested in our suite - the reason for that being that it doesn’t appear in our scope - therefore, tests are a bit brittle and should be improved on most circunstances. I won’t do this during these exercises, but readers should definetely do it.</p> </blockquote> <p>Now, we need a way to read a block of imports in our file. We have called it IMPORT_LIST in the eBNF. The data structure for it need be no more than <code class="language-plaintext highlighter-rouge">List&lt;ImportStatement&gt;</code>, but we need a parser for it. Begin with a test:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ImportListParserTests</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">[</span><span class="k">]&gt;</span> <span class="nf">ImportLists</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">string</span><span class="p">[]</span>
		<span class="p">{</span>
			<span class="s">@"
import com.google.android.apps.authenticator.util.EmptySpaceClickableDragSortListView;
import com.google.android.apps.authenticator.util.annotations.FixWhenMinSdkVersion;
import com.google.android.apps.authenticator2.R;
import com.google.common.annotations.VisibleForTesting;
			"</span><span class="p">.</span><span class="nf">Trim</span><span class="p">(),</span>
		<span class="p">};</span>

		<span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">string</span><span class="p">[]</span>
		<span class="p">{</span>
			<span class="s">@"
import android.support.v7.widget.Toolbar;
import android.text.Html;
import android.util.Log;
import android.view.ActionMode;
import android.view.ContextMenu;
			"</span><span class="p">.</span><span class="nf">Trim</span><span class="p">(),</span>
		<span class="p">};</span>
	<span class="p">}</span>

	<span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
	<span class="p">[</span><span class="nf">MemberData</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">ImportLists</span><span class="p">))]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenValidPackageName_ReturnsStructureWithCorrectName</span><span class="p">(</span><span class="kt">string</span> <span class="n">importList</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">expected</span> <span class="p">=</span> <span class="n">importList</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">).</span><span class="nf">ToList</span><span class="p">();</span>
		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">ImportList</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">importList</span><span class="p">);</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span> <span class="n">_</span><span class="p">.</span><span class="nf">ToString</span><span class="p">()));</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The implementation for the list is simple:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">ImportStatement</span><span class="p">&gt;&gt;</span> <span class="n">ImportList</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">statements</span> <span class="k">in</span> <span class="n">ImportStatement</span><span class="p">.</span><span class="nf">Many</span><span class="p">().</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">select</span> <span class="n">statements</span><span class="p">.</span><span class="nf">ToList</span><span class="p">();</span>
</code></pre></div></div> <p>Now that imports are dealt with, let’s move to the next code structure in <code class="language-plaintext highlighter-rouge">AuthenticatorActivity.java</code>, an <em>annotation</em>.</p> <h2 id="annotations">Annotations</h2> <p>The next code structure in <code class="language-plaintext highlighter-rouge">AuthenticatorActivity</code> is the class declaration. It contains a piece of code that we haven’t talked about before, an annotation.</p> <p>Java annotations are analogous to C# attributes, and look like this:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FixWhenMinSdkVersion</span><span class="o">(</span><span class="mi">11</span><span class="o">)</span>
</code></pre></div></div> <p>Just like in C#, those structures can only appear before declarations, and in this case, it’s a class declaration. We need to create the data structure to accomodate this, and the parser to produce it.</p> <p>As mentioned previously, we’re interactively building the eBNF interactively. This is to make our parser simpler - to just write the code necessary for the structures that are present in the source. That’s why the annotation wasn’t mentioned before. Let’s update it:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ANNOTATION = "@", IDENTIFIER, "(", ARGUMENT_LIST, ")"

ARGUMENT_LIST = ARGUMENT, { "," ARGUMENT }

ARGUMENT = LITERAL

LITERAL = INTEGER_LITERAL
</code></pre></div></div> <p><strong>The above eBNF is partial</strong>; For instance, the argument list for the annotation is more complex, allowing for other types. But thus far we only have the integer parameter, so we will keep ourselves to it.</p> <p>The first thing is to define the data structure for an annotation. Looking at it, you can imagine that it has a identifier as its name, and then the argument list.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">interface</span> <span class="nc">ILiteral</span>
<span class="p">{</span>
	<span class="kt">object</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">IntegerLiteral</span>  <span class="p">:</span> <span class="n">ILiteral</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">IntegerLiteral</span><span class="p">(</span><span class="kt">int</span> <span class="k">value</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="n">Value</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> 

	<span class="kt">object</span> <span class="n">ILiteral</span><span class="p">.</span><span class="n">Value</span> <span class="p">=&gt;</span> <span class="n">Value</span><span class="p">;</span>

	<span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">Value</span><span class="p">.</span><span class="nf">ToString</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Annotation</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">Annotation</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ILiteral</span><span class="p">&gt;</span> <span class="n">arguments</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Name</span> <span class="p">=</span> <span class="n">name</span><span class="p">;</span>
		<span class="n">Arguments</span> <span class="p">=</span> <span class="n">arguments</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

	<span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Argument</span><span class="p">&gt;</span> <span class="n">Arguments</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

	<span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="s">$"@</span><span class="p">{</span><span class="n">Name</span><span class="p">}</span><span class="s">(</span><span class="p">{</span><span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="s">", "</span><span class="p">,</span> <span class="n">Arguments</span><span class="p">)}</span><span class="s">)"</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>We have introduced a bit of abstraction that might save us some work later - we’ve made it clear that literal can be many things, no only integers. Casting it to the correct structure will enable users to get the typed value - otherwise, for now, we box the int and return it as an object.</p> <p>We need to create a parser for this new structure - am integer literal.</p> <p>Tests:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">IntergerLiteralParserTests</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
	<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="m">11</span><span class="p">)]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">MyTheory</span><span class="p">(</span><span class="kt">int</span> <span class="k">value</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">IntegerLiteral</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="k">value</span><span class="p">.</span><span class="nf">ToString</span><span class="p">());</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="k">value</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>And the parser:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">IntegerLiteral</span><span class="p">&gt;</span> <span class="n">IntegerLiteral</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">digits</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="n">Digit</span><span class="p">.</span><span class="nf">AtLeastOnce</span><span class="p">()</span>
	<span class="k">let</span> <span class="n">number</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Concat</span><span class="p">(</span><span class="n">digits</span><span class="p">)</span>
	<span class="k">let</span> <span class="k">value</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">IntegerLiteral</span><span class="p">(</span><span class="k">value</span><span class="p">);</span>
</code></pre></div></div> <p>One thing in the code above that might make you wonder is the <code class="language-plaintext highlighter-rouge">AtLeastOnce()</code>. This is very close to <code class="language-plaintext highlighter-rouge">Many()</code>, with the difference that it will fail parsing when there isn’t at least a single digit. If we do not apply this here, the parser will acceptan an empty argument list.</p> <p>Now we move to the actual Annotation.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">AnnotationParserTests</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
	<span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"@Number(11)"</span><span class="p">,</span> <span class="k">new</span> <span class="kt">object</span><span class="p">[]</span> <span class="p">{</span> <span class="m">11</span> <span class="p">})]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_WhenAnnotationHasParameters_CorrectParameters</span><span class="p">(</span><span class="kt">string</span> <span class="n">annotation</span><span class="p">,</span> <span class="kt">object</span><span class="p">[]</span> <span class="n">parameters</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">Annotation</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">annotation</span><span class="p">);</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Arguments</span><span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;().</span><span class="nf">ToArray</span><span class="p">());</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>❗ These tests are very basic; on most production scenarios, I suggest writting tests that have more conditions; for instance, we could test cases like <code class="language-plaintext highlighter-rouge">@ SomeAnnotation</code>, splitting the code in two lines, etc. Look at the code being tested to find gaps or risks, and create corresponding tests. Finally, with TDD we should write one test at a time and evolve iteratively.</p> <p>The reason we can get away with such simple tests is we know in advance all the code that need to be parsed, so we can test agaist a real case and check if bugs arise, but even then, I would be careful where this not just a blog post.</p> </blockquote> <p>The implementation will leverage the <code class="language-plaintext highlighter-rouge">IntegerLiteral</code> parser we just coded:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">Annotation</span><span class="p">&gt;</span> <span class="n">Annotation</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">at</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'@'</span><span class="p">).</span><span class="nf">Once</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">identifier</span> <span class="k">in</span> <span class="n">Identifier</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">startList</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'('</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">literal</span> <span class="k">in</span> <span class="n">IntegerLiteral</span><span class="p">.</span><span class="nf">Token</span><span class="p">().</span><span class="nf">Optional</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">endList</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">Char</span><span class="p">(</span><span class="sc">')'</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">let</span> <span class="n">arguments</span> <span class="p">=</span> <span class="n">literal</span><span class="p">.</span><span class="n">IsDefined</span>
		<span class="p">?</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ILiteral</span><span class="p">&gt;</span> <span class="p">{</span> <span class="n">literal</span><span class="p">.</span><span class="nf">Get</span><span class="p">()</span> <span class="p">}</span>
		<span class="p">:</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ILiteral</span><span class="p">&gt;()</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">Annotation</span><span class="p">(</span><span class="n">identifier</span><span class="p">,</span> <span class="n">arguments</span><span class="p">);</span>
</code></pre></div></div> <p>Again, we can see an optional parser being called. To get the actual list, we need to do some LINQ gymnastics - either return a list with a single literal or an empty list. In the future, we’ll probably create a <code class="language-plaintext highlighter-rouge">ArgumentList</code> parser that should replace this, but until now, there’s no need.</p> <p>Tests should be 🟢.</p> <h2 id="class-declaration">Class Declaration</h2> <p>The next thing in the file is the actual class definition. Let’s break it down:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FixWhenMinSdkVersion</span><span class="o">(</span><span class="mi">11</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AuthenticatorActivity</span> <span class="kd">extends</span> <span class="nc">TestableActivity</span> <span class="o">{</span>
<span class="c1">// ...</span>
</code></pre></div></div> <p>This is a good example because we will right out of the bat deal with <code class="language-plaintext highlighter-rouge">extends</code>, a common but not basal case. The annotation has already been taken care of, so let’s break down the class declaration:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>visibility
   │
   │          identifier, class          identifier, base class
   │                   │                          │
┌──┴─┐       ┌─────────┴─────────┐         ┌──────┴───────┐
public class AuthenticatorActivity extends TestableActivity 
       └─┬─┘                       └──┬──┘
         │             interface inheritance keyword
         │
class declaration keyword
</code></pre></div></div> <p>So we need to expand the EBNF:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CLASS_DECLARATION = VISIBILITY, "class", IDENTIFIER, { "extends", IDENTIFIER }, "{", (* ommited *), "}";

VISIBILITY = "public" 

</code></pre></div></div> <blockquote> <p>❗ We’re not dealing with other visibilities just for the moment, in other to reflect our evolving approach. As we deal with more cases, we expand on the definition.</p> </blockquote> <p>This should be actually simple, but we need to update the class structure to reflect it:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">enum</span> <span class="n">Visibility</span>
<span class="p">{</span>
	<span class="n">Public</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">ClassDefinition</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">ClassDefinition</span><span class="p">(</span><span class="n">Visibility</span> <span class="n">visibility</span><span class="p">,</span> <span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">string</span><span class="p">?</span> <span class="n">baseClass</span> <span class="p">=</span> <span class="k">null</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">?</span> <span class="n">annotation</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Visibility</span> <span class="p">=</span> <span class="n">visibility</span><span class="p">;</span>
		<span class="n">Name</span> <span class="p">=</span> <span class="n">name</span><span class="p">;</span>
		<span class="n">BaseClass</span> <span class="p">=</span> <span class="n">baseClass</span><span class="p">;</span>
		<span class="n">Annotation</span> <span class="p">=</span> <span class="n">annotation</span><span class="p">;</span>
	<span class="p">}</span>

		<span class="k">public</span> <span class="n">Visibility</span> <span class="n">Visibility</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

		<span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

		<span class="k">public</span> <span class="kt">string</span><span class="p">?</span> <span class="n">BaseClass</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

		<span class="k">public</span> <span class="n">Annotation</span><span class="p">?</span> <span class="n">Annotation</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>A few things to note: we’re strictly adhering to the code excerpt that is being processed, so, even though there’s a Visibility member, it’s only possible value is <code class="language-plaintext highlighter-rouge">Public</code>; although Java allows for multiple annotations, we are just considering a single annotation, etc. The reason I’m folowing this approach is that we don’t know yet if those cases will arise within code. If they do, we’ll rewrite the code above.</p> <p>Now let’s create our tests:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ClassDefinitionParserTests</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
	<span class="k">public</span> <span class="k">void</span> <span class="nf">Parse_AnnotatedClassWithExtends_CorrectParameters</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">code</span> <span class="p">=</span> <span class="s">@"
@FixWhenMinSdkVersion(11)
public class AuthenticatorActivity extends TestableActivity
"</span><span class="p">.</span><span class="nf">Trim</span><span class="p">();</span>

		<span class="kt">var</span> <span class="n">actual</span> <span class="p">=</span> <span class="n">JavaGrammar</span><span class="p">.</span><span class="n">ClassDefinition</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>

		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">"FixWhenMinSdkVersion"</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Annotation</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="m">11</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Annotation</span><span class="p">.</span><span class="n">Arguments</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">Value</span><span class="p">);</span>
		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="n">Visibility</span><span class="p">.</span><span class="n">Public</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Visibility</span><span class="p">);</span>
		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">"AuthenticatorActivity"</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
		<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">"TestableActivity"</span><span class="p">,</span> <span class="n">actual</span><span class="p">.</span><span class="n">BaseClass</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Again, the tests deal only with what we’ve seen so far. I’ve used a <code class="language-plaintext highlighter-rouge">Fact</code> instead of a <code class="language-plaintext highlighter-rouge">Theory</code> because we are only dealing with a single case. Once we have more cases to test, I’ll convert it to <code class="language-plaintext highlighter-rouge">Theory</code>.</p> <p>Ah! I’m testing the result of the annotation parsing, which is actually repeating the tests already done in the <code class="language-plaintext highlighter-rouge">AnnotationParserTests</code>. We could do this a bit differently and just make sure that the correct parser was called, but for now, let’s keep this simple and repeat the test.</p> <p>Now the implementation, albeit long, is simple, just parse each fragment we saw in the breakdown above:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Parser</span><span class="p">&lt;</span><span class="n">ClassDefinition</span><span class="p">&gt;</span> <span class="n">ClassDefinition</span> <span class="p">=</span>
	<span class="k">from</span> <span class="n">annotation</span> <span class="k">in</span> <span class="n">Annotation</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">visibility</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"public"</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">classKeyword</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"class"</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">className</span> <span class="k">in</span> <span class="n">Identifier</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">extendsKeyword</span> <span class="k">in</span> <span class="n">Parse</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">"extends"</span><span class="p">).</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">from</span> <span class="n">baseClassName</span> <span class="k">in</span> <span class="n">Identifier</span><span class="p">.</span><span class="nf">Token</span><span class="p">()</span>
	<span class="k">select</span> <span class="k">new</span> <span class="nf">ClassDefinition</span><span class="p">(</span><span class="n">Visibility</span><span class="p">.</span><span class="n">Public</span><span class="p">,</span> <span class="n">className</span><span class="p">,</span> <span class="n">baseClassName</span><span class="p">,</span> <span class="n">annotation</span><span class="p">);</span>
</code></pre></div></div> <p>I cut some corners here, like parsing visibility directly. We will also deal with this once we need to.</p> <p>Run your tests and appreciate your 🟢.</p> <h1 id="summary">Summary</h1> <p>With this article, we’ve completed the first step: we are able to parse all top-level elements of a Java source file. You’ve learned a bit more about how to use Sprache and combine parsers, and probably picked up some techniques on how to create code that is <em>fit for purpose</em>, using a test-driven approach, and evolving previous code as we advance in our understanding of the problem domain, a process that is called <strong>discovery</strong>.</p> <p>All code produced thus far has been stored at <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser" target="_blank" rel="noopener noreferrer">Github</a>. You’re welcome to fork it and use it in whichever way you want. To get the exact version of this code, use <a href="https://github.com/bruno-brant/dotnet-java-dependency-analyser/releases/tag/SecondArticle" target="_blank" rel="noopener noreferrer">this tag</a>.</p> <p>In the next article, we’ll start parsing class elements like constructors, fields and methods. We will be even more focused, dealing only with the code structures that appear in code, and hopefully we can finish parsing our first class.</p> <p>See you next time!</p> <br> <div class="tag-list"> <a href="/tags/#dotnet">#dotnet</a>   <a href="/tags/#programming">#programming</a>   <a href="/tags/#language">#language</a>   <a href="/tags/#sprache">#sprache</a>   <a href="/tags/#tdd">#tdd</a> </div> </article> <div class="PageNavigation"> <a class="prev" href="/read-my-blog-in-portuguese/">← Previous</a> </div> <aside class="related"> <h3>Related Posts</h3> <ul class="related-posts"> <li> <a href="/read-my-blog-in-portuguese/"> Read my blog in portuguese or english! <small><time datetime="2021-02-17T00:00:00+00:00">February 17th, 2021</time></small> </a> </li> <li> <a href="/parsing-code-with-sprache/"> Parsing code with Sprache - Part 1 <small><time datetime="2021-02-13T10:00:00+00:00">February 13th, 2021</time></small> </a> </li> <li> <a href="/happy-halloween-blog-is-back/"> Happy Halloween! My blog is back! <small><time datetime="2020-10-31T18:00:00+00:00">October 31st, 2020</time></small> </a> </li> </ul> </aside> </main> <footer class="footer"> <div class="wrapper"> <div> © Copyright 2021 Bruno Brant. Theme based on <a href="https://github.com/essentialenemy/noir/" target="_blank" rel="noopener noreferrer">Noir</a> by <a href="https://essentialenemy.com/" target="_blank" rel="noopener noreferrer">Victor Johnson</a>. </div> <div class="social-links">
<ul class="social-media-list">
<li><a rel="noopener noreferrer" href="https://github.com/bruno-brant" title="bruno-brant" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li>
<li><a rel="noopener noreferrer" href="https://stackoverflow.com/users/227332%2Fbruno-brant" title="227332/bruno-brant" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#stackoverflow"></use></svg></a></li>
<li><a rel="noopener noreferrer" href="https://www.linkedin.com/in/brunobrant" title="brunobrant" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg></a></li>
<li><a rel="noopener noreferrer" href="https://twitter.com/HeavyStorm" title="HeavyStorm" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li>
</ul> </div> </div> </footer> </div> </body> </html>
